(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  // Deal with resize.  skip this for node.js apps
  if (typeof window != 'undefined')
    window.addEventListener('resize', function() {
      for (var key in __instances) {
        if (__instances.hasOwnProperty(key)) {
          var instance = __instances[key];
          instance.refresh();
        }
      }
    });

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapĥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'hovers',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.dispatchEvent('coordinatesUpdated');
      self.renderCamera(camera);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'hovers',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph, {
          prefix: c.readPrefix,
          maxLevel: c.settings('nodeQuadtreeMaxLevel'),
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          (c.settings('enableEdgeHovering') ||
            c.settings('edgesClippingWithNodes'))
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            maxLevel: c.settings('edgeQuadtreeMaxLevel'),
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var l,
        i,
        prefix = 0;

    // Call each renderer:
    for (i in this.renderers)
      if (this.settings('skipErrors'))
        try {
          this.renderers[i].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + this.renderers[i] +
              '" crashed on ".render()"'
            );
        }
      else
        this.renderers[i].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "'+ a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "'+a[i].id +'" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.5.2';


  /**
   * Disable ES6 features if true:
   */
  sigma.forceES5 = false;


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright © 2013 Alexis Jacomy, Sciences-Po médialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exists or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every jobs that are stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */


  /**
   * SigmaMap wraps an ES6 Object. Methods set, get, has, forEach, delete, and clear
   * have the same signature than the corresponding Map methods.
   */
  function SigmaMap() {
    var self = this;
    var _store;

    if (!sigma.forceES5 &&
      typeof Map !== 'undefined' &&
      Map.prototype.keys !== undefined &&
      Map.prototype.forEach !== undefined
      && Array.from !== undefined) {

      _store = new Map();

      Object.defineProperty(this, 'size', {
        get: function() { return _store.size; },
        set: undefined,
        enumerable: true
      });

      this.set = function(key, value) { _store.set('' + key, value); };
      this.get = function(key) { return _store.get('' + key); };
      this.has = function(key) { return _store.has('' + key); };
      this.forEach = function(func) { return _store.forEach(func); };
      this.delete = function(key) { return _store.delete('' + key); };
      this.clear = function() { _store.clear(); };

      this.keyList = function () {
        return Array.from(_store.keys());
      };

      this.valueList = function () {
        var values = [];
        _store.forEach(function(val) {
          values.push(val);
        });
        return values;
      };
    }
    else {
      _store = Object.create(null);
      this.size = 0;

      this.keyList = function () {
        return Object.keys(_store).filter(function(key) {
          return _store[key] !== undefined;
        });
      };

      this.valueList = function () {
        var keys = Object.keys(_store);
        var values = [];

        for (var i = 0; i < keys.length; i++) {
          var val = _store[keys[i]];
          if (val !== undefined) {
            values.push(val);
          }
        }
        return values;
      };

      this.set = function (key, value) {
        if (_store[key] === undefined) self.size++;

        _store[key] = value;
      };

      this.get = function (key) {
        return _store[key];
      };

      this.has = function (key) {
        return _store[key] !== undefined;
      };

      this.forEach = function (func) {
        var keys = Object.keys(_store);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i],
              obj = _store[key];

          if (typeof obj !== 'undefined') {
            func(obj, key);
          }
        }
      };

      this.delete = function (key) {
        var value = _store[key];
        _store[key] = undefined;

        if (value !== undefined) self.size--;

        return value;
      };

      this.clear = function () {
        for (var k in _store)
          if (!('hasOwnProperty' in _store) || _store.hasOwnProperty(k))
            delete _store[k];

        _store = Object.create(null);
        self.size = 0;
      };
    }
  }

  sigma.utils.map = SigmaMap;


  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number}  x1  The X coordinate of the start point.
   * @param  {number}  y1  The Y coordinate of the start point.
   * @param  {number}  x2  The X coordinate of the end point.
   * @param  {number}  y2  The Y coordinate of the end point.
   * @param  {?number} cc  The curvature coefficients.
   * @return {x,y}         The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2, cc) {
    cc = this.extend(cc, { x: 2, y: 4 });
    return {
      x: (x1 + x2) / cc.x + (y2 - y1) / cc.y,
      y: (y1 + y2) / cc.x + (x1 - x2) / cc.y
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * xi + t * t * x2,
      y: (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * yi + t * t * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = (1 - t) * (1 - t) * (1 - t),
        B1_t = 3 * t * (1 - t) * (1 - t),
        B2_t = 3 * t * t * (1 - t),
        B3_t = t * t * t;

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    return sigma.utils.distancePointToSegment(x, y, x1, y1, x2, y2) < epsilon;
  };

  /**
    * Compute the distance of a point to a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @return {number}         Distance to the segment
  */
  sigma.utils.distancePointToSegment = function(x, y, x1, y1, x2, y2) {
    // http://stackoverflow.com/a/6853926/1075195
    var A = x - x1,
        B = y - y1,
        C = x2 - x1,
        D = y2 - y1,
        dot = A * C + B * D,
        len_sq = C * C + D * D,
        param = -1,
        xx, yy;

    if (len_sq !== 0) //in case of 0 length line
        param = dot / len_sq;

    if (param < 0) {
      xx = x1;
      yy = y1;
    }
    else if (param > 1) {
      xx = x2;
      yy = y2;
    }
    else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    var dx = x - xx;
    var dy = y - yy;
    return Math.sqrt(dx * dx + dy * dy);
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio),
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */

  /**
   * Return true if the browser support webgl
   *
   * @return {boolean}
   */
  sigma.utils.isWebGLSupported = function() {
    var canvas,
        webgl = !!window.WebGLRenderingContext;
    if (webgl) {
      canvas = document.createElement('canvas');
      try {
        return !!(
          canvas.getContext('webgl') ||
          canvas.getContext('experimental-webgl')
        );
      } catch (e) {}
    }
    return false;
  };

  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };

  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };


  /**
   * ************
   * CANVAS UTILS:
   * ************
   */
  /**
   * Calculate the width of the text either approximated via the font size or
   * via the more expensive but accurate context.measureText.
   *
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {boolean}     approximate   Approximate or not.
   * @param  {integer}     fontSize      Font size of the text.
   * @param  {string}      text          The text to use.
   *
   * @return {float}       Returns the width.
   */
   sigma.utils.canvas = {};
   sigma.utils.canvas.getTextWidth =
        function(context, approximate, fontSize, text) {

    if (!text) return 0;

    return approximate ? 0.6 * text.length * fontSize :
      context.measureText(text).width;
  };

  /**
   * Set the shadow values of the specified context according to the level
   * to create visual depth.
   *
   * @param  {number}     level     The level (from 1 to 5).
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   */
  sigma.utils.canvas.setLevel = function(level, context) {
    if (level) {
      context.shadowOffsetX = 0;
      // inspired by Material Design shadows, level from 1 to 5:
      switch(level) {
        case 1:
          context.shadowOffsetY = 1.5;
          context.shadowBlur = 4;
          context.shadowColor = 'rgba(0,0,0,0.36)';
          break;
        case 2:
          context.shadowOffsetY = 3;
          context.shadowBlur = 12;
          context.shadowColor = 'rgba(0,0,0,0.39)';
          break;
        case 3:
          context.shadowOffsetY = 6;
          context.shadowBlur = 12;
          context.shadowColor = 'rgba(0,0,0,0.42)';
          break;
        case 4:
          context.shadowOffsetY = 10;
          context.shadowBlur = 20;
          context.shadowColor = 'rgba(0,0,0,0.47)';
          break;
        case 5:
          context.shadowOffsetY = 15;
          context.shadowBlur = 24;
          context.shadowColor = 'rgba(0,0,0,0.52)';
          break;
      }
    }
  };

  /**
   * Reset the shadow values.
   *
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   */
  sigma.utils.canvas.resetLevel = function(context) {
    context.shadowOffsetY = 0;
    context.shadowBlur = 0;
    context.shadowColor = '#000000';
  };

  // incrementally scaled, not automatically resized for now
  // (ie. possible memory leak if there are many graph load / unload)
  var imgCache = {};

  /**
   * Draw an image inside the specified node on the canvas.
   *
   * @param  {object}                   node     The node object.
   * @param  {number}                   x        The node x coordinate.
   * @param  {number}                   y        The node y coordinate.
   * @param  {number}                   size     The node size.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {string}                   imgCrossOrigin Cross-origin URL or '*'.
   * @param  {number}                  threshold Display if node size is larger
   * @param  {function}                 clipFn    The clipping shape function.
   */
  sigma.utils.canvas.drawImage =
    function(node, x, y, size, context, imgCrossOrigin, threshold, clipFn) {

    if(!node.image || !node.image.url || size < threshold) return;

    var url = node.image.url;
    var ih = node.image.h || 1; // 1 is arbitrary, anyway only the ratio counts
    var iw = node.image.w || 1;
    var scale = node.image.scale || 1;
    var clip = node.image.clip || 1;

    // create new IMG or get from imgCache
    var image = imgCache[url];
    if(!image) {
      image = document.createElement('IMG');
      image.setAttribute('crossOrigin', imgCrossOrigin);
      image.src = url;
      image.onload = function() {
        window.dispatchEvent(new Event('resize'));
      };
      imgCache[url] = image;
    }

    // calculate position and draw
    var xratio = (iw < ih) ? (iw / ih) : 1;
    var yratio = (ih < iw) ? (ih / iw) : 1;
    var r = size * scale;

    context.save(); // enter clipping mode
      context.beginPath();
    if (typeof clipFn === 'function') {
      clipFn(node, x, y, size, context, clip);
    }
    else {
      // Draw the clipping disc:
      context.arc(x, y, size * clip, 0, Math. PI * 2, true);
    }
    context.closePath();
    context.clip();

    // Draw the actual image
    context.drawImage(
      image,
      x + Math.sin(-3.142 / 4) * r * xratio,
      y - Math.cos(-3.142 / 4) * r * yratio,
      r * xratio * 2 * Math.sin(-3.142 / 4) * (-1),
      r * yratio * 2 * Math.cos(-3.142 / 4)
    );
    context.restore(); // exit clipping mode
  };

  /**
   * Draw an icon inside the specified node on the canvas.
   *
   * @param  {object}                   node     The node object.
   * @param  {number}                   x        The node x coordinate.
   * @param  {number}                   y        The node y coordinate.
   * @param  {number}                   size     The node size.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {number}                  threshold Display if node size is larger
   */
  sigma.utils.canvas.drawIcon = function(node, x, y, size, context, threshold){
    if(!node.icon || size < threshold) return;

    var font = node.icon.font || 'Arial',
        fgColor = node.icon.color || '#F00',
        text = node.icon.content || '?',
        px = node.icon.x || 0.5,
        py = node.icon.y || 0.5,
        height = size,
        width = size;

    var fontSizeRatio = 0.70;
    if (typeof node.icon.scale === "number") {
      fontSizeRatio = Math.abs(Math.max(0.01, node.icon.scale));
    }

    var fontSize = Math.round(fontSizeRatio * height);

    context.save();
    context.fillStyle = fgColor;

    context.font = '' + fontSize + 'px ' + font;
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, x, y);
    context.restore();
  };

}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik Möller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: false,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Label position relative to its node. Available values:
    //          "right", "left", "top", "bottom", "center", "inside"
    labelAlignment: 'right',
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} Maximum length of a node's label (in characters). Displays the label on several lines. 0 disables it
    // (the whole label is displayed on one line)
    maxNodeLabelLineLength: 0,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of nodes.
    nodeBorderSize: 0,
    // {number} The default node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,
    // {boolean} Approximate labels width instead of using canvas.measureText
    approximateLabelWidth: true,
    // {boolean} Hide edges from nodes too far away
    edgesClippingWithNodes: true,
    // {number} if sigma.canvas.edges.autoCurve is called, set relative
    // distance between curved parallel edges (i.e. edges with same
    // extremities). Smaller value increases distances.
    autoCurveRatio: 1,
    // {boolean} if sigma.canvas.edges.autoCurve is called, sort edges by
    // direction.
    autoCurveSortByDirection: true,


    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean} If true, the user will need to click on the visualization element
    // in order to focus it
    clickToFocus: false,
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {boolean} Defines whether the zoom focuses on the mouse location.
    zoomOnLocation: true,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,



    /**
     * SPATIAL INDEXING SETTINGS:
     * ****************
     */
    // {number} Max height of the node quad tree.
    nodeQuadtreeMaxLevel: 4,
    // {number} Max height of the edge quad tree.
    edgeQuadtreeMaxLevel: 4,



    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: new sigma.utils.map(),
      edgesIndex: new sigma.utils.map(),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: new sigma.utils.map(),
      outNeighborsIndex: new sigma.utils.map(),
      allNeighborsIndex: new sigma.utils.map()
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex.get(node.id))
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Try to fix the node coordinates and size
    if (validNode.x !== undefined && typeof validNode.x !== 'number') {
      validNode.x = parseFloat(validNode.x);
    }
    if (validNode.y !== undefined && typeof validNode.y !== 'number') {
      validNode.y = parseFloat(validNode.y);
    }
    if (validNode.size !== undefined && typeof validNode.size !== 'number') {
      validNode.size = parseFloat(validNode.size);
    }

    // Check node size
    if (!validNode.size || validNode.size <= 0) {
      validNode.size = 1;
    }

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex.set(id, new sigma.utils.map());
    this.outNeighborsIndex.set(id, new sigma.utils.map());
    this.allNeighborsIndex.set(id, new sigma.utils.map());

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex.set(validNode.id, validNode);

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex.get(edge.source))
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex.get(edge.target))
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex.get(edge.id))
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Try to fix the edge size
    if (validEdge.size !== undefined && typeof validEdge.size !== 'number') {
      validEdge.size = parseFloat(validEdge.size);
    }

    // Check edge size
    if (!validEdge.size || validEdge.size <= 0) {
      validEdge.size = 1;
    }

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex.set(validEdge.id, validEdge);

    if (!this.inNeighborsIndex.get(validEdge.target).get(validEdge.source))
      this.inNeighborsIndex.get(validEdge.target).set(validEdge.source,
        new sigma.utils.map());
    this.inNeighborsIndex.get(validEdge.target).get(validEdge.source).set(validEdge.id,
      validEdge);

    if (!this.outNeighborsIndex.get(validEdge.source).get(validEdge.target))
      this.outNeighborsIndex.get(validEdge.source).set(validEdge.target,
        new sigma.utils.map());
    this.outNeighborsIndex.get(validEdge.source).get(validEdge.target).set(validEdge.id,
      validEdge);

    if (!this.allNeighborsIndex.get(validEdge.source).get(validEdge.target))
      this.allNeighborsIndex.get(validEdge.source).set(validEdge.target,
        new sigma.utils.map());
    this.allNeighborsIndex.get(validEdge.source).get(validEdge.target).set(validEdge.id,
      validEdge);

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex.get(validEdge.target).get(validEdge.source))
        this.allNeighborsIndex.get(validEdge.target).set(validEdge.source,
          new sigma.utils.map());
      this.allNeighborsIndex.get(validEdge.target).get(validEdge.source).set(validEdge.id,
        validEdge);
    }

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex.get(id))
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    this.nodesIndex.delete(id);
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    this.inNeighborsIndex.delete(id);
    this.outNeighborsIndex.delete(id);
    this.allNeighborsIndex.delete(id);

    var self = this;
    this.nodesIndex.forEach(function(n, k) {
      self.inNeighborsIndex.get(k).delete(id);
      self.outNeighborsIndex.get(k).delete(id);
      self.allNeighborsIndex.get(k).delete(id);
    });

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex.get(id))
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex.get(id);
    this.edgesIndex.delete(id);
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    this.inNeighborsIndex.get(edge.target).get(edge.source).delete(edge.id);
    if (this.inNeighborsIndex.get(edge.target).get(edge.source).size == 0)
      this.inNeighborsIndex.get(edge.target).delete(edge.source);

    this.outNeighborsIndex.get(edge.source).get(edge.target).delete(edge.id);
    if (this.outNeighborsIndex.get(edge.source).get(edge.target).size == 0)
      this.outNeighborsIndex.get(edge.source).delete(edge.target);

    this.allNeighborsIndex.get(edge.source).get(edge.target).delete(edge.id);
    if (this.allNeighborsIndex.get(edge.source).get(edge.target).size == 0)
      this.allNeighborsIndex.get(edge.source).delete(edge.target);

    if (edge.target !== edge.source) {
      this.allNeighborsIndex.get(edge.target).get(edge.source).delete(edge.id);
      if (this.allNeighborsIndex.get(edge.target).get(edge.source).size == 0)
        this.allNeighborsIndex.get(edge.target).delete(edge.source);
    }

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    this.nodesIndex.clear();
    this.edgesIndex.clear();
    this.nodesIndex.clear();
    this.inNeighborsIndex.clear();
    this.outNeighborsIndex.clear();
    this.allNeighborsIndex.clear();

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex.get(v);

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex.get(v[i]));
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsIndex,
      'out': this.outNeighborsIndex
    }[which || ''] || this.allNeighborsIndex;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which.get(v).size;

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which.get(v[i]).size);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex.get(v);

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex.get(v[i]));
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ('ratio' in coordinates && !this.settings('zoomOnLocation'))
          ? ['ratio', 'angle'] : ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal), Sébastien Heymann, Damien Marié
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },


    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          (r.x2 - r.x1) * (r.x2 - r.x1) +
          (r.y2 - r.y1) * (r.y2 - r.y1)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (a.x * a.x + a.y * a.y)
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * @param  {boolean?} indexEdges Tell to index edges or nodes
   *
   * property {object} _tree       Property holding the quadtree object
   * property {object} _geom       Exposition of the _geom namespace for testing
   * property {object} _cache      Cache for the area method
   */
  var quad = function(indexEdges) {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
    this._indexEdges = indexEdges || false;
  };

  /**
   * Index a graph by inserting its elements into the quadtree.
   *
   * @param  {array}  graph      The graph to index
   * @param  {object} params     An object of parameters with at least the quad
   *                             bounds.
   * @return {object}            The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(graph, params) {
    if (!this._enabled) {
      return this._tree;
    }

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        cc = params.curvatureCoefficients,
        source,
        target,
        i,
        l,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    if (!this._indexEdges) {
      var nodes = graph.nodes();
      // Inserting graph nodes into the tree
      for (i = 0, l = nodes.length; i < l; i++) {

        // Inserting node
        _quadInsert(
          nodes[i],
          _geom.pointToSquare({
            x: nodes[i][prefix + 'x'],
            y: nodes[i][prefix + 'y'],
            size: nodes[i][prefix + 'size']
          }),
          this._tree
        );
      }
    } else {
      var edges = graph.edges();
      // Inserting graph edges into the tree
      for (i = 0, l = edges.length; i < l; i++) {
        source = graph.nodes(edges[i].source);
        target = graph.nodes(edges[i].target);
        e = {
          x1: source[prefix + 'x'],
          y1: source[prefix + 'y'],
          x2: target[prefix + 'x'],
          y2: target[prefix + 'y'],
          size: edges[i][prefix + 'size'] || 0
        };

        // Inserting edge
        if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
          if (source.id === target.id) {
            n = {
              x: source[prefix + 'x'],
              y: source[prefix + 'y'],
              size: source[prefix + 'size'] || 0
            };
            _quadInsert(
              edges[i],
              _geom.selfLoopToSquare(n),
              this._tree);
          }
          else {
            cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2, edges[i].cc || cc);
            _quadInsert(
              edges[i],
              _geom.quadraticCurveToSquare(e, cp),
              this._tree);
          }
        }
        else {
          _quadInsert(
            edges[i],
            _geom.lineToSquare(e),
            this._tree);
        }
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var elements = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var elementsArr = [];
    for (var i in elements)
      elementsArr.push(elements[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = elementsArr;

    return elementsArr;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
    this.sigma.classes.edgequad = quad.bind(this, true);
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;

}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    this.eltFocused = false;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    _target.addEventListener('mouseenter', _enterHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    function _enterHandler(e) {
      if (!_settings('clickToFocus')) {
        target.focus();
      }
    }

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      _self.eltFocused = false;
      target.blur();

      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      _self.eltFocused = true;
      target.focus();

      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && (!_settings('clickToFocus') || _self.eltFocused)) {
        ratio = sigma.utils.getDelta(e) > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };

  /**
   * Static method to render edges or nodes with the given renderers
   *
   * @param  {object}       params     The parameters passed in an object
   * {
   *   renderers: {object}              Renderers indexed by types
   *   type:      {string}              "edges" or "nodes"
   *   ctx:       {Context2D}           Canvas Context to draw on
   *   settings:  {object}              Settings object to use
   *   elements:  {array}               Elements to render
   *   graph?:    {sigma.classes.graph} Graph object
   *                                    (only necessary for edge rendering)
   *   start?:    {integer}             Starting index of the elements to render
   *   end?:      {integer}             Last index of the elements to render
   * }
   */
  sigma.renderers.canvas.applyRenderers = function(params) {
    var i,
        renderer,
        specializedRenderer,
        def,
        render,
        els = params.elements,
        ctx_infos = {font: params.ctx.font},
        elementType = (params.elements || params.type == 'edges' ?
              'defaultEdgeType' : 'defaultNodeType');

    params.start = params.start || 0;
    params.end = params.end || params.elements.length;
    params.end = Math.min(params.elements.length, params.end);

    params.ctx.save();

    for (i = params.start; i < params.end; i++) {
      if (!els[i].hidden) {
        specializedRenderer = params.renderers[
          els[i].type || params.settings(elementType)
        ];
        def = (specializedRenderer || params.renderers.def);
        if (params.type == 'edges') {
          def(
            els[i],
            params.graph.nodes(els[i].source),
            params.graph.nodes(els[i].target),
            params.ctx,
            params.settings,
            {ctx: ctx_infos}
          );
        }else {
          def(
            els[i],
            params.ctx,
            params.settings,
            {ctx: ctx_infos}
          );
        }
      }
    }

    params.ctx.restore();
  };


  /**
   * Render a batch of edges
   *
   * @param    {integer}      start    Starting index of the elements to render
   * @param    {integer}      end      Last index of the elements to render
   * @param    {object}       settings Settings to use
   */
  sigma.renderers.canvas.prototype.renderEdges =
          function(start, end, settings) {
    var renderParams = {
      renderers: sigma.canvas.edges,
      type: 'edges',
      elements: this.edgesOnScreen,
      ctx: this.contexts.edges,
      start: start,
      end: end,
      graph: this.graph,
      settings: settings
    };
    sigma.renderers.canvas.applyRenderers(renderParams);
    if (settings('drawEdgeLabels')) {
      renderParams.renderers = sigma.canvas.edges.labels;
      renderParams.ctx = this.contexts.labels;
      sigma.renderers.canvas.applyRenderers(renderParams);
    }
  };

  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    this.dispatchEvent('beforeRender');

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      this.edgesOnScreen = [];
      if (embedSettings('edgesClippingWithNodes')) {
        // Identify which edges to draw by keeping every edges that have at
        // least one extremity displayed according to the quadtree and the
        // "hidden" attribute. We also do not keep hidden edges.
        for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
          o = a[i];
          if (
            (index[o.source] || index[o.target]) &&
            (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
          )
            this.edgesOnScreen.push(o);
        }
      } else {
        this.edgesOnScreen = this.camera.edgequadtree.area(
          this.camera.getRectangle(this.width, this.height)
        );
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (embedSettings('batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          this.renderEdges(start, end, embedSettings);

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        this.renderEdges(0, this.edgesOnScreen.length, embedSettings);
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      sigma.renderers.canvas.applyRenderers({
        renderers: sigma.canvas.nodes,
        type: 'nodes',
        ctx: this.contexts.nodes,
        elements: this.nodesOnScreen,
        settings: embedSettings
      });
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      sigma.renderers.canvas.applyRenderers({
        renderers: sigma.canvas.labels,
        type: 'nodes',
        ctx: this.contexts.labels,
        elements: this.nodesOnScreen,
        settings: embedSettings
      });
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      edgelabels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    this.dispatchEvent('beforeRender');

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);
    this.hideDOMElements(this.domElements.edgelabels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          if (drawLabels) {
            e = (subrenderers[a[i].type] || subrenderers.def).create(
              a[i],
              embedSettings
            );

            this.domElements.labels[a[i].id] = e;
            this.domElements.groups.labels.appendChild(e);
          }
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        if (drawLabels) {
          (subrenderers[a[i].type] || subrenderers.def).update(
            a[i],
            this.domElements.labels[a[i].id],
            embedSettings
          );
        }
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;
    subrenderers = sigma.svg.edges.labels;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] ||
            renderers[defaultEdgeType] ||
            renderers.def
          ).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);

          // Label
          if (drawEdgeLabels) {

            e = (subrenderers[a[i].type] ||
              subrenderers[defaultEdgeType]  ||
              subrenderers.def
            ).create(
              a[i],
              embedSettings
            );
            this.domElements.edgelabels[a[i].id] = e;
            this.domElements.groups.edgelabels.appendChild(e);
          }
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] ||
          renderers[defaultEdgeType] ||
          renderers.def
        ).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );

        // Label
        if (drawEdgeLabels) {
          (subrenderers[a[i].type] ||
            subrenderers[defaultEdgeType] ||
            subrenderers.def
          ).update(
            a[i],
            source,
            target,
            this.domElements.edgelabels[a[i].id],
            embedSettings
          );
        }
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'edgelabels', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function updateHovers(e) {
      var node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      if (e.data.enter.nodes.length > 0) { // over
        node = e.data.enter.nodes[0];
        var hover = (renderers[node.type] || renderers.def).create(
          node,
          self.domElements.nodes[node.id],
          self.measurementCanvas,
          embedSettings
        );

        self.domElements.hovers[node.id] = hover;

        // Inserting the hover in the dom
        self.domElements.groups.hovers.appendChild(hover);
        hoveredNode = node;
      } else if (e.data.leave.nodes.length > 0) { // out
        node = e.data.leave.nodes[0];

        // Deleting element
        self.domElements.groups.hovers.removeChild(
          self.domElements.hovers[node.id]
        );
        hoveredNode = null;
        delete self.domElements.hovers[node.id];

        // Reinstate
        self.domElements.groups.nodes.appendChild(
          self.domElements.nodes[node.id]
        );
      }
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('hovers', updateHovers);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = this.width + 'px';
      this.domElements.graph.style.height = this.height + 'px';
    }

    return this;
  };

  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
  sigma.utils.pkg('sigma.svg.edgelabels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Copy the good renderer:
  sigma.renderers.def = sigma.utils.isWebGLSupported() ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will display the label of the node
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   * @param  {object?}                  infos    The batch infos.
   */
  sigma.canvas.labels.def = function(node, context, settings, infos) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'] || 1,
        fontStyle = settings('fontStyle'),
        borderSize = settings('nodeBorderSize'),
        labelWidth,
        labelOffsetX,
        labelOffsetY,
        alignment = settings('labelAlignment'),
        maxLineLength = settings('maxNodeLabelLineLength') || 0;

    if (size <= settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    var new_font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' +
      (node.active ?
        settings('activeFont') || settings('font') :
        settings('font'));

    if (infos && infos.ctx.font != new_font) { //use font value caching
      context.font = new_font;
      infos.ctx.font = new_font;
    } else {
      context.font = new_font;
    }

    context.fillStyle =
        (settings('labelColor') === 'node') ?
        node.color || settings('defaultNodeColor') :
        settings('defaultLabelColor');

    labelOffsetX = 0;
    labelOffsetY = fontSize / 3;
    context.textAlign = 'center';

    switch (alignment) {
      case 'bottom':
        labelOffsetY = + size + 4 * fontSize / 3;
        break;
      case 'center':
        break;
      case 'left':
        context.textAlign = 'right';
        labelOffsetX = - size - borderSize - 3;
        break;
      case 'top':
        labelOffsetY = - size - 2 * fontSize / 3;
        break;
      case 'inside':
        labelWidth = sigma.utils.canvas.getTextWidth(context, settings('approximateLabelWidth'), fontSize, node.label);
        if (labelWidth <= (size + fontSize / 3) * 2) {
          break;
        }
      /* falls through*/
      case 'right':
      /* falls through*/
      default:
        labelOffsetX = size + borderSize + 3;
        context.textAlign = 'left';
        break;
    }

    var lines = getLines(node.label, maxLineLength),
        baseX = node[prefix + 'x'] + labelOffsetX,
        baseY = Math.round(node[prefix + 'y'] + labelOffsetY);

    for (var i = 0; i < lines.length; ++i) {
      context.fillText(lines[i], baseX, baseY + i * (fontSize + 1));
    }
  };

  /**
   * Split a text into several lines. Each line won't be longer than the specified maximum length.
   * @param {string}  text            Text to split
   * @param {number}  maxLineLength   Maximum length of a line. A value <= 1 will be treated as "infinity".
   * @returns {Array<string>}         List of lines
   */
  function getLines(text, maxLineLength) {
    if (maxLineLength <= 1) {
      return [text];
    }

    var words = text.split(' '),
        lines = [],
        lineLength = 0,
        lineIndex = -1,
        lineList = [],
        lineFull = true;

    for (var i = 0; i < words.length; ++i) {
      if (lineFull) {
        if (words[i].length > maxLineLength) {
          var parts = splitWord(words[i], maxLineLength);
          for (var j = 0; j < parts.length; ++j) {
            lines.push([parts[j]]);
            ++lineIndex;
          }
          lineLength = parts[parts.length - 1].length;
        } else {
          lines.push([words[i]
          ]);
          ++lineIndex;
          lineLength = words[i].length + 1;
        }
        lineFull = false;
      } else if (lineLength + words[i].length <= maxLineLength) {
        lines[lineIndex].push(words[i]);
        lineLength += words[i].length + 1;
      } else {
        lineFull = true;
        --i;
      }
    }

    for (i = 0; i < lines.length; ++i) {
      lineList.push(lines[i].join(' '))
    }

    return lineList;
  }

  /**
   * Split a word into several lines (with a '-' at the end of each line but the last).
   * @param {string} word       Word to split
   * @param {number} maxLength  Maximum length of a line
   * @returns {Array<string>}   List of lines
   */
  function splitWord(word, maxLength) {
    var parts = [];

    for (var i = 0; i < word.length; i += maxLength - 1) {
      parts.push(word.substr(i, maxLength - 1) + '-');
    }

    var lastPartLen = parts[parts.length - 1].length;
    parts[parts.length - 1] = parts[parts.length - 1].substr(0, lastPartLen - 1) + ' ';

    return parts;
  }
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        labelX,
        labelY,
        lines,
        baseX,
        baseY,
        borderSize = settings('nodeBorderSize'),
        alignment = settings('labelAlignment'),
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        maxLineLength = settings('maxNodeLabelLineLength') || 0,
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;


    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    lines = getLines(node.label, maxLineLength);
    drawHoverBorder(alignment, context, fontSize, node, lines, maxLineLength);

    // Node border:
    if (borderSize > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + borderSize,
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');
      var labelWidth = sigma.utils.canvas.getTextWidth(context,
            settings('approximateLabelWidth'), fontSize, node.label),
          labelOffsetX = - labelWidth / 2,
          labelOffsetY = fontSize / 3;

      switch (alignment) {
        case 'bottom':
          labelOffsetY = + size + 4 * fontSize / 3;
          break;
        case 'center':
          break;
        case 'left':
          labelOffsetX = - size - borderSize - 3 - labelWidth;
          break;
        case 'top':
          labelOffsetY = - size - 2 * fontSize / 3;
          break;
        case 'inside':
          if (labelWidth <= (size + fontSize / 3) * 2) {
            break;
          }
        /* falls through*/
        case 'right':
        /* falls through*/
        default:
          labelOffsetX = size + borderSize + 3;
          break;
      }

      baseX = node[prefix + 'x'] + labelOffsetX;
      baseY = Math.round(node[prefix + 'y'] + labelOffsetY);

      for (var i = 0; i < lines.length; ++i) {
        context.fillText(lines[i], baseX, baseY + i * (fontSize + 1));
      }
    }

    function drawHoverBorder(alignment, context, fontSize, node, lines, maxLineLength) {
      var labelWidth =
        (maxLineLength > 1 && lines.length > 1) ?
        0.6 * maxLineLength * fontSize :
        sigma.utils.canvas.getTextWidth(
          context,
          settings('approximateLabelWidth'),
          fontSize,
          lines[0]
        );

      var x = Math.round(node[prefix + 'x']),
          y = Math.round(node[prefix + 'y']),
          h = ((fontSize + 1) * lines.length) + 4,
          e = Math.round(size + fontSize / 4),
          w = Math.round(labelWidth + size + 1.5 + fontSize / 3);

      if (node.label && typeof node.label === 'string') {
        // draw a rectangle for the label
        switch (alignment) {
          case 'center':
            break;
          case 'left':
            x = Math.round(node[prefix + 'x'] + fontSize / 2 + 2);
            y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);

            context.moveTo(x, y + e);
            context.arcTo(x, y, x - e, y, e);
            context.lineTo(x - w - borderSize - e, y);
            context.lineTo(x - w - borderSize - e, y + h);
            context.lineTo(x - e, y + h);
            context.arcTo(x, y + h, x, y + h - e, e);
            context.lineTo(x, y + e);
            break;
          case 'top':
            context.rect(x - w / 2, y - e - h, w, h);
            break;
          case 'bottom':
            context.rect(x - w / 2, y + e, w, h);
            break;
          case 'inside':
            if (labelWidth <= e * 2) {
              // don't draw anything
              break;
            }
            // use default setting, falling through
          /* falls through*/
          case 'right':
          /* falls through*/
          default:
            x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
            y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);

            context.moveTo(x, y + e);
            context.arcTo(x, y, x + e, y, e);
            context.lineTo(x + w + borderSize + e, y);
            context.lineTo(x + w + borderSize + e, y + h);
            context.lineTo(x + e, y + h);
            context.arcTo(x, y + h, x, y + h - e, e);
            context.lineTo(x, y + e);
            break;
        }
      }

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    /**
     * Split a text into several lines. Each line won't be longer than the specified maximum length.
     * @param {string}  text            Text to split
     * @param {number}  maxLineLength   Maximum length of a line. A value <= 1 will be treated as "infinity".
     * @returns {Array<string>}         List of lines
     */
    function getLines(text, maxLineLength) {
      if (maxLineLength <= 1) {
        return [text];
      }

      var words = text.split(' '),
        lines = [],
        lineLength = 0,
        lineIndex = -1,
        lineList = [],
        lineFull = true;

      for (var i = 0; i < words.length; ++i) {
        if (lineFull) {
          if (words[i].length > maxLineLength) {
            var parts = splitWord(words[i], maxLineLength);
            for (var j = 0; j < parts.length; ++j) {
              lines.push([parts[j]]);
              ++lineIndex;
            }
            lineLength = parts[parts.length - 1].length;
          } else {
            lines.push([words[i]
            ]);
            ++lineIndex;
            lineLength = words[i].length + 1;
          }
          lineFull = false;
        } else if (lineLength + words[i].length <= maxLineLength) {
          lines[lineIndex].push(words[i]);
          lineLength += words[i].length + 1;
        } else {
          lineFull = true;
          --i;
        }
      }

      for (i = 0; i < lines.length; ++i) {
        lineList.push(lines[i].join(' '))
      }

      return lineList;
    }

    /**
     * Split a word into several lines (with a '-' at the end of each line but the last).
     * @param {string} word       Word to split
     * @param {number} maxLength  Maximum length of a line
     * @returns {Array<string>}   List of lines
     */
    function splitWord(word, maxLength) {
      var parts = [];

      for (var i = 0; i < word.length; i += maxLength - 1) {
        parts.push(word.substr(i, maxLength - 1) + '-');
      }

      var lastPartLen = parts[parts.length - 1].length;
      parts[parts.length - 1] = parts[parts.length - 1].substr(0, lastPartLen - 1) + ' ';

      return parts;
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as curves.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.curve = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt((tX - sX) * (tX - sX) + (tY - sY) * (tY - sY)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as curves with arrow heading.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (source.id === target.id) {
      d = Math.sqrt((tX - cp.x1) * (tX - cp.x1) + (tY - cp.y1) * (tY - cp.y1));
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt((tX - cp.x) * (tX - cp.x) + (tY - cp.y) * (tY - cp.y));
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt((tX - sX) * (tX - sX) + (tY - sY) * (tY - sY)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (source.id === target.id) {
      d = Math.sqrt((tX - cp.x1) * (tX - cp.x1) + (tY - cp.y1) * (tY - cp.y1));
      aSize = Math.max(size * 2.5, settings('minArrowSize'));
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt((tX - cp.x) * (tX - cp.x) + (tY - cp.y) * (tY - cp.y));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the edge as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               path       The path DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '',
          sSize = source[prefix + 'size'],
          sX = source[prefix + 'x'],
          sY = source[prefix + 'y'],
          tX = target[prefix + 'x'],
          tY = target[prefix + 'y'],
          cp,
          p;

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      if (source.id === target.id) {
        cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'C' + cp.x1 + ',' + cp.y1 + ' ' +
            cp.x2 + ',' + cp.y2 + ' ' +
            tX + ',' + tY;
      }
      else {
        cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'Q' + cp.x + ',' + cp.y + ' ' +
            tX + ',' + tY;
      }

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * TODO add arrow
   */
  sigma.svg.edges.curvedArrow = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               path       The path DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '',
          sSize = source[prefix + 'size'],
          sX = source[prefix + 'x'],
          sY = source[prefix + 'y'],
          tX = target[prefix + 'x'],
          tY = target[prefix + 'y'],
          cp,
          p;

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      if (source.id === target.id) {
        cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'C' + cp.x1 + ',' + cp.y1 + ' ' +
            cp.x2 + ',' + cp.y2 + ' ' +
            tX + ',' + tY;
      }
      else {
        cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'Q' + cp.x + ',' + cp.y + ' ' +
            tX + ',' + tY;
      }

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    if (np) {
      /**
       * First, we compute the scaling ratio, without considering the sizes
       * of the nodes : Each node will have its center in the canvas, but might
       * be partially out of it.
       */
      scale = settings('scalingMode') === 'outside' ?
        Math.max(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        ) :
        Math.min(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        );

      /**
       * Then, we correct that scaling ratio considering a margin, which is
       * basically the size of the biggest node.
       * This has to be done as a correction since to compare the size of the
       * biggest node to the X and Y values, we have to first get an
       * approximation of the scaling ratio.
       **/
      margin =
        (
          settings('rescaleIgnoreSize') ?
            0 :
            (settings('maxNodeSize') || sizeMax) / scale
        ) +
        (settings('sideMargin') || 0);
      maxX += margin;
      minX -= margin;
      maxY += margin;
      minY -= margin;

      // Fix the scaling with the new extrema:
      scale = settings('scalingMode') === 'outside' ?
        Math.max(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        ) :
        Math.min(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        );
    }

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);

      if (np) {
        n[i][writePrefix + 'x'] =
          (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * scale;
        n[i][writePrefix + 'y'] =
          (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * scale;
      }
      else {
        n[i][writePrefix + 'x'] = n[i][readPrefix + 'x'];
        n[i][writePrefix + 'y'] = n[i][readPrefix + 'y'];
      }
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              (modifiedX - x) * (modifiedX - x) +
              (modifiedY - y) * (modifiedY - y)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  edge.cc);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            event = {
              current: { nodes: [], edges: [], },
              enter: { nodes: [], edges: [], },
              leave: { nodes: [], edges: [], },
              captor: e.data
            },
            leave = event.leave;

        for (k in overNodes)
          leave.nodes.push(overNodes[k]);

        for (k in overEdges)
          leave.edges.push(overEdges[k]);

        overNodes = {};
        overEdges = {};

        if (leave.nodes.length || leave.edges.length) {
          self.dispatchEvent('hovers', event);
        }
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {};

        // Check newly overred nodes:
        for (i = 0; i < nodes.length; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Check newly overred edges:
        for (i = 0; i < edges.length; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        if (newOutEdges.length || newOverEdges.length ||
             newOutNodes.length || newOverNodes.length) {
          self.dispatchEvent('hovers', {
            current: {
              nodes: nodes,
              edges: edges,
            },
            enter: {
              nodes: newOverNodes,
              edges: newOverEdges,
            },
            leave: {
              nodes: newOutNodes,
              edges: newOutEdges,
            },
            captor: e.data
          });
        }
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph,
        hovered = {nodes: [], edges: []};

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', sigma.utils.mouseCoords(e));

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', sigma.utils.mouseCoords(e));

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el_svg = new Element(target),
        event = {
          leave: {nodes: [], edges: []},
          enter: {nodes: [], edges: []},
          captor: sigma.utils.mouseCoords(e),
        },
        el;

      if (el_svg.isNode()) {
        el = graph.nodes(el_svg.attr('data-node-id'));
        event.enter.nodes = [el];
        hovered.nodes.push(el);
      } else if (el_svg.isEdge()) {
        el = graph.edges(el_svg.attr('data-edge-id'));
        event.enter.edges = [el];
        hovered.edges.push(el);
      }

      event.current = hovered;
      self.dispatchEvent('hovers', event);
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el_svg = new Element(target),
        event = {
          leave: {nodes: [], edges: []},
          enter: {nodes: [], edges: []},
          captor: sigma.utils.mouseCoords(e),
        },
        el;

      if (el_svg.isNode()) {
        el = graph.nodes(el_svg.attr('data-node-id'));
        event.leave.nodes = [el];
        hovered.nodes.push(el);
      } else if (el_svg.isEdge()) {
        el = graph.edges(el_svg.attr('data-edge-id'));
        event.leave.edges = [el];
        hovered.edges.push(el);
      } else {
        return;
      }

      event.current = hovered;
      self.dispatchEvent('hovers', event);
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "hovers" events from a renderer and renders
   * the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        current = {nodes: [], edges: []};

    this.bind('hovers', function(event) {
      current = event.data.current;
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {
      var c = self.contexts.hover.canvas,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          }),
          end = embedSettings('singleHover') ? 1 : undefined,
          renderParams = {
            elements: current.nodes,
            renderers: sigma.canvas.hovers,
            type: 'nodes',
            ctx: self.contexts.hover,
            end: end,
            graph: self.graph,
            settings: embedSettings,
          };

      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render
      if (current.nodes.length > 0 && embedSettings('enableHovering')) {
        sigma.renderers.canvas.applyRenderers(renderParams);
      }

      // Edge render
      if (current.edges.length > 0 && embedSettings('enableEdgeHovering')) {
        renderParams.renderers = sigma.canvas.edgehovers;
        renderParams.elements = current.edges;
        renderParams.type = 'edges';
        sigma.renderers.canvas.applyRenderers(renderParams);

        if (embedSettings('edgeHoverExtremities')) {
          renderParams.renderers = sigma.canvas.extremities;
          sigma.renderers.canvas.applyRenderers(renderParams);
        } else { //draw nodes over edges
          renderParams.ctx = self.contexts.nodes;
          renderParams.type = 'nodes';
          renderParams.renderers = sigma.canvas.nodes;
          renderParams.elements = current.nodes;
          sigma.renderers.canvas.applyRenderers(renderParams);
        }
      }
    }
  };
}).call(this);

},{}],2:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma is not declared');

  // Initialize package:
  sigma.utils.pkg('sigma.layouts.noverlap');

  /**
   * Noverlap Layout
   * ===============================
   *
   * Author: @apitts / Andrew Pitts
   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)
   * Acknowledgement: @sheyman / Sébastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)
   * Version: 0.1
   */

  var settings = {
    speed: 3,
    scaleNodes: 1.2,
    nodeMargin: 5.0,
    gridSize: 20,
    permittedExpansion: 1.1,
    rendererIndex: 0,
    maxIterations: 500
  };

  var _instance = {};

  /**
   * Event emitter Object
   * ------------------
   */
  var _eventEmitter = {};

   /**
   * Noverlap Object
   * ------------------
   */
  function Noverlap() {
    var self = this;

    this.init = function (sigInst, options) {
      options = options || {};

      // Properties
      this.sigInst = sigInst;
      this.config = sigma.utils.extend(options, settings);
      this.easing = options.easing;
      this.duration = options.duration;

      if (options.nodes) {
        this.nodes = options.nodes;
        delete options.nodes;
      }

      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {
        throw new Error('sigma.plugins.animate is not declared');
      }

      // State
      this.running = false;
    };

    /**
     * Single layout iteration.
     */
    this.atomicGo = function () {
      if (!this.running || this.iterCount < 1) return false;

      var nodes = this.nodes || this.sigInst.graph.nodes(),
          nodesCount = nodes.length,
          i,
          n,
          n1,
          n2,
          xmin = Infinity,
          xmax = -Infinity,
          ymin = Infinity,
          ymax = -Infinity,
          xwidth,
          yheight,
          xcenter,
          ycenter,
          grid,
          row,
          col,
          minXBox,
          maxXBox,
          minYBox,
          maxYBox,
          adjacentNodes,
          subRow,
          subCol,
          nxmin,
          nxmax,
          nymin,
          nymax;

      this.iterCount--;
      this.running = false;

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        n.dn.dx = 0;
        n.dn.dy = 0;

        //Find the min and max for both x and y across all nodes
        xmin = Math.min(xmin, n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        xmax = Math.max(xmax, n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymin = Math.min(ymin, n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymax = Math.max(ymax, n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );

      }

      xwidth = xmax - xmin;
      yheight = ymax - ymin;
      xcenter = (xmin + xmax) / 2;
      ycenter = (ymin + ymax) / 2;
      xmin = xcenter - self.config.permittedExpansion*xwidth / 2;
      xmax = xcenter + self.config.permittedExpansion*xwidth / 2;
      ymin = ycenter - self.config.permittedExpansion*yheight / 2;
      ymax = ycenter + self.config.permittedExpansion*yheight / 2;

      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid

      for(row = 0; row < self.config.gridSize; row++) {
        grid[row] = {};
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col] = [];
        }
      }

      //Place nodes in grid
      for (i=0; i < nodesCount; i++) {
        n = nodes[i];

        nxmin = n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nxmax = n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymin = n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymax = n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);

        minXBox = Math.floor(self.config.gridSize* (nxmin - xmin) / (xmax - xmin) );
        maxXBox = Math.floor(self.config.gridSize* (nxmax - xmin) / (xmax - xmin) );
        minYBox = Math.floor(self.config.gridSize* (nymin - ymin) / (ymax - ymin) );
        maxYBox = Math.floor(self.config.gridSize* (nymax - ymin) / (ymax - ymin) );
        for(col = minXBox; col <= maxXBox; col++) {
          for(row = minYBox; row <= maxYBox; row++) {
            grid[row][col].push(n.id);
          }
        }
      }


      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes

      for(row = 0; row < self.config.gridSize; row++) {
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col].forEach(function(nodeId) {
            if(!adjacentNodes[nodeId]) {
              adjacentNodes[nodeId] = [];
            }
            for(subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {
              for(subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1,  self.config.gridSize - 1); subCol++) {
                grid[subRow][subCol].forEach(function(subNodeId) {
                  if(subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {
                    adjacentNodes[nodeId].push(subNodeId);
                  }
                });
              }
            }
          });
        }
      }

      //If two nodes overlap then repulse them
      for (i=0; i < nodesCount; i++) {
        n1 = nodes[i];
        adjacentNodes[n1.id].forEach(function(nodeId) {
          var n2 = self.sigInst.graph.nodes(nodeId);
          var xDist = n2.dn_x - n1.dn_x;
          var yDist = n2.dn_y - n1.dn_y;
          var dist = Math.sqrt(xDist*xDist + yDist*yDist);
          var collision = (dist < ((n1.dn_size*self.config.scaleNodes + self.config.nodeMargin) + (n2.dn_size*self.config.scaleNodes + self.config.nodeMargin)));
          if(collision) {
            self.running = true;
            if(dist > 0) {
              n2.dn.dx += xDist / dist * (1 + n1.dn_size);
              n2.dn.dy += yDist / dist * (1 + n1.dn_size);
            } else {
              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());
              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());
            }
          }
        });
      }

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        if(!n.fixed) {
          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;
          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;
        }
      }

      if(this.running && this.iterCount < 1) {
        this.running = false;
      }

      return this.running;
    };

    this.go = function () {
      this.iterCount = this.config.maxIterations;

      while (this.running) {
        this.atomicGo();
      };

      this.stop();
    };

    this.start = function() {
      if (this.running) return;

      var nodes = this.sigInst.graph.nodes();

      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;

      this.running = true;

      // Init nodes
      for (var i = 0; i < nodes.length; i++) {
        nodes[i].dn_x = nodes[i][prefix + 'x'];
        nodes[i].dn_y = nodes[i][prefix + 'y'];
        nodes[i].dn_size = nodes[i][prefix + 'size'];
        nodes[i].dn = {
          dx: 0,
          dy: 0
        };
      }
      _eventEmitter[self.sigInst.id].dispatchEvent('start');
      this.go();
    };

    this.stop = function() {
      var nodes = this.sigInst.graph.nodes();

      this.running = false;

      if (this.easing) {
        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');
        sigma.plugins.animate(
          self.sigInst,
          {
            x: 'dn_x',
            y: 'dn_y'
          },
          {
            easing: self.easing,
            onComplete: function() {
              self.sigInst.refresh();
              for (var i = 0; i < nodes.length; i++) {
                nodes[i].dn = null;
                nodes[i].dn_x = null;
                nodes[i].dn_y = null;
              }
              _eventEmitter[self.sigInst.id].dispatchEvent('stop');
            },
            duration: self.duration
          }
        );
      }
      else {
        // Apply changes
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].x = nodes[i].dn_x;
          nodes[i].y = nodes[i].dn_y;
        }

        this.sigInst.refresh();

        for (var i = 0; i < nodes.length; i++) {
          nodes[i].dn = null;
          nodes[i].dn_x = null;
          nodes[i].dn_y = null;
        }
        _eventEmitter[self.sigInst.id].dispatchEvent('stop');
      }
    };

    this.kill = function() {
      this.sigInst = null;
      this.config = null;
      this.easing = null;
    };
  };

  /**
   * Interface
   * ----------
   */

  /**
   * Configure the layout algorithm.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object:
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */
  sigma.prototype.configNoverlap = function(config) {

    var sigInst = this;

    if (!config) throw new Error('Missing argument: "config"');

    // Create instance if undefined
    if (!_instance[sigInst.id]) {
      _instance[sigInst.id] = new Noverlap();

      _eventEmitter[sigInst.id] = {};
      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]);

      // Binding on kill to clear the references
      sigInst.bind('kill', function() {
        _instance[sigInst.id].kill();
        _instance[sigInst.id] = null;
        _eventEmitter[sigInst.id] = null;
      });
    }

    _instance[sigInst.id].init(sigInst, config);

    return _eventEmitter[sigInst.id];
  };

  /**
   * Start the layout algorithm. It will use the existing configuration if no
   * new configuration is passed.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */

  sigma.prototype.startNoverlap = function(config) {

    var sigInst = this;

    if (config) {
      this.configNoverlap(sigInst, config);
    }

    _instance[sigInst.id].start();

    return _eventEmitter[sigInst.id];
  };

  /**
   * Returns true if the layout has started and is not completed.
   *
   * @return {boolean}
   */
  sigma.prototype.isNoverlapRunning = function() {

    var sigInst = this;

    return !!_instance[sigInst.id] && _instance[sigInst.id].running;
  };

}).call(this);
},{}],3:[function(require,module,exports){
/**
 * This plugin provides a method to animate a sigma instance by interpolating
 * some node properties. Check the sigma.plugins.animate function doc or the
 * examples/animate.html code sample to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');

  var _id = 0,
      _cache = {};

  // TOOLING FUNCTIONS:
  // ******************
  function parseColor(val) {
    if (_cache[val])
      return _cache[val];

    var result = [0, 0, 0];

    if (val.match(/^#/)) {
      val = (val || '').replace(/^#/, '');
      result = (val.length === 3) ?
        [
          parseInt(val.charAt(0) + val.charAt(0), 16),
          parseInt(val.charAt(1) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(2), 16)
        ] :
        [
          parseInt(val.charAt(0) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(3), 16),
          parseInt(val.charAt(4) + val.charAt(5), 16)
        ];
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      result = [
        +val[1],
        +val[2],
        +val[3]
      ];
    }

    _cache[val] = {
      r: result[0],
      g: result[1],
      b: result[2]
    };

    return _cache[val];
  }

  function interpolateColors(c1, c2, p) {
    c1 = parseColor(c1);
    c2 = parseColor(c2);

    var c = {
      r: c1.r * (1 - p) + c2.r * p,
      g: c1.g * (1 - p) + c2.g * p,
      b: c1.b * (1 - p) + c2.b * p
    };

    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';
  }

  /**
   * This function will animate some specified node properties. It will
   * basically call requestAnimationFrame, interpolate the values and call the
   * refresh method during a specified duration.
   *
   * Events fired though sigma instance:
   * *************
   * animate.start  Fired at the beginning of the animation.
   * animate.end    Fired at the end of the animation.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {?array}             nodes      An array of node objects or node ids. If
   *                                   not specified, all nodes of the graph
   *                                   will be animated.
   *   {?(function|string)} easing     Either the name of an easing in the
   *                                   sigma.utils.easings package or a
   *                                   function. If not specified, the
   *                                   quadraticInOut easing from this package
   *                                   will be used instead.
   *   {?number}            duration   The duration of the animation. If not
   *                                   specified, the "animationsTime" setting
   *                                   value of the sigma instance will be used
   *                                   instead.
   *   {?function}          onComplete Eventually a function to call when the
   *                                   animation is ended.
   *
   * @param  {sigma}   s       The related sigma instance.
   * @param  {object}  animate An hash with the keys being the node properties
   *                           to interpolate, and the values being the related
   *                           target values.
   * @param  {?object} options Eventually an object with options.
   */
  sigma.plugins.animate = function(s, animate, options) {
    var o = options || {},
        id = ++_id,
        duration = o.duration || s.settings('animationsTime'),
        easing = typeof o.easing === 'string' ?
          sigma.utils.easings[o.easing] :
          typeof o.easing === 'function' ?
          o.easing :
          sigma.utils.easings.quadraticInOut,
        start = sigma.utils.dateNow(),
        nodes,
        startPositions;

    if (o.nodes && o.nodes.length) {
      if (typeof o.nodes[0] === 'object')
        nodes = o.nodes;
      else
        nodes = s.graph.nodes(o.nodes); // argument is an array of IDs
    }
    else
      nodes = s.graph.nodes();

    // Store initial positions:
    startPositions = nodes.reduce(function(res, node) {
      var k;
      res[node.id] = {};
      for (k in animate)
        if (k in node)
          res[node.id][k] = node[k];
      return res;
    }, {});

    s.animations = s.animations || Object.create({});
    sigma.plugins.killAnimate(s);

    s.dispatchEvent('animate.start'); // send a sigma event

    function step() {
      var p = (sigma.utils.dateNow() - start) / duration;

      if (p >= 1) {
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate && animate[k] in node)
              node[k] = node[animate[k]];
        });

        s.refresh({skipIndexation: true});
        if (typeof o.onComplete === 'function') {
          o.onComplete();
        }
        s.dispatchEvent('animate.end'); // send a sigma event
      }
      else {
        p = easing(p);
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate && animate[k] in node) {
              if (k.match(/color$/))
                node[k] = interpolateColors(
                  startPositions[node.id][k],
                  node[animate[k]],
                  p
                );
              else
                node[k] =
                  node[animate[k]] * p +
                  startPositions[node.id][k] * (1 - p);
            }
        });

        s.refresh({skipIndexation: true});
        s.animations[id] = requestAnimationFrame(step);
      }
    }

    step();
  };

  sigma.plugins.killAnimate = function(s) {
    for (var k in (s.animations || {}))
      cancelAnimationFrame(s.animations[k]);
  };
}).call(window);

},{}],4:[function(require,module,exports){
/**
 * This plugin provides a method to drag & drop nodes. Check the
 * sigma.plugins.dragNodes function doc or the examples/drag-nodes.html code
 * sample to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');


  /**
   * This function will add `mousedown`, `mouseup` & `mousemove` events to the
   * nodes in the `overNode`event to perform drag & drop operations. It uses
   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]
   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to
   * calculate the X and Y coordinates from the `cam` or `renderer` node
   * attributes. These attributes represent the coordinates of the nodes in
   * the real container, not in canvas.
   *
   * Fired events:
   * *************
   * startdrag  Fired at the beginning of the drag.
   * drag       Fired while the node is dragged.
   * drop       Fired at the end of the drag if the node has been dragged.
   * dragend    Fired at the end of the drag.
   *
   * Recognized parameters:
   * **********************
   * @param  {sigma}                      s        The related sigma instance.
   * @param  {renderer}                   renderer The related renderer instance.
   * @param  {?sigma.plugins.activeState} a        The activeState plugin instance.
   */
  function DragNodes(s, renderer, a) {
    sigma.classes.dispatcher.extend(this);

    // A quick hardcoded rule to prevent people from using this plugin with the
    // WebGL renderer (which is impossible at the moment):
    if (
      sigma.renderers.webgl &&
      renderer instanceof sigma.renderers.webgl
    )
      throw new Error(
        'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'
      );

    // Init variables:
    var _self = this,
      _s = s,
      _a = a,
      _body = document.body,
      _renderer = renderer,
      _mouse = renderer.container.getElementsByClassName('sigma-mouse')[0],
      _prefix = renderer.options.prefix,
      _node = null,
      _draggingNode = null,
      _hoveredNode = null,
      _isMouseDown = false,
      _isMouseOverCanvas = false,
      _drag = false,
      _sticky = true,
      _enabled = true;

    if (renderer instanceof sigma.renderers.svg) {
        _mouse = renderer.container.firstChild;
    }

    renderer.bind('hovers', nodeMouseOver);
    renderer.bind('hovers', treatOutNode);
    renderer.bind('click', click);

    /**
     * Enable dragging and events.
     */
    this.enable = function() {
      _enabled = true;
    }

    /**
     * Disable dragging and events.
     */
    this.disable = function() {
      _enabled = false;
      _node = null,
      _draggingNode = null,
      _hoveredNode = null;
      _isMouseDown = false,
      _isMouseOverCanvas = false,
      _drag = false,
      _sticky = true;
    }

    /**
     * Unbind all event listeners.
     */
    this.unbindAll = function() {
      _mouse.removeEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);
      _renderer.unbind('hovers', nodeMouseOver);
      _renderer.unbind('hovers', treatOutNode);
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function calculateOffset(element) {
      var style = window.getComputedStyle(element);
      var getCssProperty = function(prop) {
        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
      };
      return {
        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
        top: element.getBoundingClientRect().top + getCssProperty('padding-top')
      };
    };

    function click(event) {
      // event triggered at the end of the click
      _isMouseDown = false;
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      if (!_hoveredNode) {
        _node = null;
      }
      else {
        // Drag node right after click instead of needing mouse out + mouse over:
        setTimeout(function() {
          // Set the current node to be the last hovered node
          _node = _hoveredNode;
          _mouse.addEventListener('mousedown', nodeMouseDown);
        }, 0);
      }
    };

    function nodeMouseOver(event) {
      if (event.data.enter.nodes.length == 0) {
        return;
      }
      var n = event.data.enter.nodes[0];

      // Don't treat the node if it is already registered
      if (_hoveredNode && _hoveredNode.id === n.id) {
        return;
      }

      // Set reference to the hovered node
      _hoveredNode = n;

      if(!_isMouseDown) {
        // Set the current node to be the last hovered node
        _node = _hoveredNode;
        _mouse.addEventListener('mousedown', nodeMouseDown);
      }
    };

    function treatOutNode(event) {
      if (event.data.leave.nodes.length == 0) {
        return;
      }
      var n = event.data.leave.nodes[0];

      if (_hoveredNode && _hoveredNode.id === n.id) {
        _hoveredNode = null;
        _node = null;
      }
      else if (!_hoveredNode) {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
      }
    };

    function nodeMouseDown(event) {
      if(!_enabled || event.which == 3) return; // Right mouse button pressed

      _isMouseDown = true;
      if (_node && _s.graph.nodes().length > 0) {
        _sticky = true;
        _mouse.removeEventListener('mousedown', nodeMouseDown);
        _body.addEventListener('mousemove', nodeMouseMove);
        _body.addEventListener('mouseup', nodeMouseUp);

        // Deactivate drag graph.
        _renderer.settings({mouseEnabled: false, enableHovering: false});

        _self.dispatchEvent('startdrag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };

    function nodeMouseUp(event) {
      _isMouseDown = false;
      _mouse.addEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      // Activate drag graph.
      _renderer.settings({mouseEnabled: true, enableHovering: true});

      if (_drag) {
        _self.dispatchEvent('drop', {
          node: _draggingNode,
          captor: event,
          renderer: _renderer
        });

        if(_a) {
          var activeNodes = _a.nodes();
          for(var i = 0; i < activeNodes.length; i++) {
            activeNodes[i].alphaX = undefined;
            activeNodes[i].alphaY = undefined;
          }
        }

        _s.refresh();
      }
      _self.dispatchEvent('dragend', {
        node: _node,
        captor: event,
        renderer: _renderer
      });

      _drag = false;
      _draggingNode = null;
    };

    function nodeMouseMove(event) {
      if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        clearTimeout(timeOut);
        var timeOut = setTimeout(executeNodeMouseMove, 0);
      } else {
        executeNodeMouseMove();
      }

      function executeNodeMouseMove() {
        var offset = calculateOffset(_renderer.container),
            x = event.clientX - offset.left,
            y = event.clientY - offset.top,
            cos = Math.cos(_renderer.camera.angle),
            sin = Math.sin(_renderer.camera.angle),
            nodes = _s.graph.nodes(),
            ref = [],
            x2,
            y2,
            activeNodes,
            n,
            aux,
            isHoveredNodeActive,
            dist;

        if (_a && _a.nbNodes() === nodes.length) return;

        if (!_enabled || nodes.length < 2) return;

        dist = sigma.utils.getDistance(x, y, _node[_prefix + 'x'],_node[_prefix + 'y']);

        if (_sticky && dist < _node[_prefix + 'size']) return;
        _sticky = false;

        // Find two reference points and derotate them
        // We take the first node as a first reference point and then try to find
        // another node not aligned with it
        for (var i = 0;;i++) {
          if(!_enabled) break;

          n = nodes[i];
          if (n) {
            aux = {
              x: n.x * cos + n.y * sin,
              y: n.y * cos - n.x * sin,
              renX: n[_prefix + 'x'], //renderer X
              renY: n[_prefix + 'y'], //renderer Y
            };
            ref.push(aux);
          }
          if(i == nodes.length - 1) { //we tried all nodes
            break
          }
          if (i > 0) {
            if (ref[0].x == ref[1].x || ref[0].y == ref[1].y) {
              ref.pop() // drop last nodes and try to find another one
            } else { // we managed to find two nodes not aligned
              break
            }
          }
        }

        var a = ref[0], b = ref[1];

        // Applying linear interpolation.
        var divx = (b.renX - a.renX);
        if (divx === 0) divx = 1; //fix edge case where axis are aligned

        var divy = (b.renY - a.renY);
        if (divy === 0) divy = 1; //fix edge case where axis are aligned

        x = ((x - a.renX) / divx) * (b.x - a.x) + a.x;
        y = ((y - a.renY) / divy) * (b.y - a.y) + a.y;

        x2 = x * cos - y * sin;
        y2 = y * cos + x * sin;

        // Drag multiple nodes, Keep distance
        if(_a) {
          activeNodes = _a.nodes();

          // If hovered node is active, drag active nodes
          isHoveredNodeActive = (-1 < activeNodes.map(function(node) {
            return node.id;
          }).indexOf(_node.id));

          if (isHoveredNodeActive) {
            for(var i = 0; i < activeNodes.length; i++) {
              // Delete old reference
              if(_draggingNode != _node) {
                activeNodes[i].alphaX = undefined;
                activeNodes[i].alphaY = undefined;
              }

              // Calcul first position of activeNodes
              if(!activeNodes[i].alphaX || !activeNodes[i].alphaY) {
                activeNodes[i].alphaX = activeNodes[i].x - x;
                activeNodes[i].alphaY = activeNodes[i].y - y;
              }

              // Move activeNodes to keep same distance between dragged nodes
              // and active nodes
              activeNodes[i].x = _node.x + activeNodes[i].alphaX;
              activeNodes[i].y = _node.y + activeNodes[i].alphaY;
            }
          }
        }

        // Rotating the coordinates.
        _node.x = x2;
        _node.y = y2;

        _s.refresh({skipIndexation: true});

        _drag = true;
        _draggingNode = _node;

        _self.dispatchEvent('drag', {
          node: _draggingNode,
          captor: event,
          renderer: _renderer
        });
      }
    };
  };

  /**
   * Interface
   * ------------------
   *
   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0], a);
   */
  var _instance = {};

  /**
   * @param  {sigma}                      s        The related sigma instance.
   * @param  {renderer}                   renderer The related renderer instance.
   * @param  {?sigma.plugins.activeState} a        The activeState plugin instance.
   */
  sigma.plugins.dragNodes = function(s, renderer, a) {
    // Create object if undefined
    if (!_instance[s.id]) {
      // Handle drag events:
      _instance[s.id] = new DragNodes(s, renderer, a);
    }

    s.bind('kill', function() {
      sigma.plugins.killDragNodes(s);
    });

    // disable on plugins.animate start.
    s.bind('animate.start', function() {
      _instance[s.id].disable();
    });

    // enable on plugins.animate end.
    s.bind('animate.end', function() {
      _instance[s.id].enable();
    });

    return _instance[s.id];
  };

  /**
   * This method removes the event listeners and kills the dragNodes instance.
   *
   * @param  {sigma} s The related sigma instance.
   */
  sigma.plugins.killDragNodes = function(s) {
    if (_instance[s.id] instanceof DragNodes) {
      _instance[s.id].unbindAll();
      delete _instance[s.id];
    }
  };

}).call(window);

},{}],5:[function(require,module,exports){
;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  var drawBorder = function(context, x, y, radius, color, line_width) {
    context.beginPath();
    context.strokeStyle = color;
	  context.lineWidth = line_width;
    context.arc(x, y, radius, 0, Math.PI * 2, true);
    context.closePath();
    context.stroke();
  };


  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   * @param  {?object}                  options  Force optional parameters (e.g. color).
   */
  sigma.canvas.nodes.def = function(node, context, settings, options) {
    var o = options || {},
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'] || 1,
        x = node[prefix + 'x'],
        y = node[prefix + 'y'],
        defaultNodeColor = settings('defaultNodeColor'),
        imgCrossOrigin = settings('imgCrossOrigin') || 'anonymous',
        borderSize = node.border_size || settings('nodeBorderSize'),
        outerBorderSize = settings('nodeOuterBorderSize'),
        activeBorderSize = node.border_size || settings('nodeActiveBorderSize'),
        activeOuterBorderSize = settings('nodeActiveOuterBorderSize'),
        color = o.color || node.color || defaultNodeColor,
	      borderColor = settings('nodeBorderColor') === 'default'
          ? settings('defaultNodeBorderColor')
          : (o.borderColor || node.border_color || node.color || defaultNodeColor),
        level = node.active ? settings('nodeActiveLevel') : node.level;

    // Level:
    sigma.utils.canvas.setLevel(level, context);

    if (node.active) {
      // Color:
      if (settings('nodeActiveColor') === 'node') {
        color = node.active_color || color;
      }
      else {
        color = settings('defaultNodeActiveColor') || color;
      }

      // Outer Border:
      if (activeOuterBorderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeActiveOuterBorderColor') === 'node' ?
          (color || defaultNodeColor) :
          settings('defaultNodeActiveOuterBorderColor');
        context.arc(x, y, size + activeBorderSize + activeOuterBorderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }
      // Border:
      if (activeBorderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeActiveBorderColor') === 'node'
          ? borderColor
          : settings('defaultNodeActiveBorderColor');
        context.arc(x, y, size + activeBorderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }
    }
    else {
      // Outer Border:
      if (outerBorderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeOuterBorderColor') === 'node' ?
          (color || defaultNodeColor) :
          settings('defaultNodeOuterBorderColor');
        context.arc(x, y, size + borderSize + outerBorderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }

      // Border:
      if (borderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeBorderColor') === 'node'
          ? borderColor
          : settings('defaultNodeBorderColor');
        context.arc(x, y, size + borderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }
    }

    if ((!node.active ||
      (node.active && settings('nodeActiveColor') === 'node')) &&
      node.colors &&
      node.colors.length) {

      // see http://jsfiddle.net/hvYkM/1/
      var i,
          l = node.colors.length,
          j = 1 / l,
          lastend = 0;

      for (i = 0; i < l; i++) {
        context.fillStyle = node.colors[i];
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, size, lastend, lastend + (Math.PI * 2 * j), false);
        context.lineTo(x, y);
        context.closePath();
        context.fill();
        lastend += Math.PI * 2 * j;
      }
      sigma.utils.canvas.resetLevel(context);
    }
    else {
      context.fillStyle = color;
      context.beginPath();
      context.arc(x, y, size, 0, Math.PI * 2, true);
      context.closePath();
      context.fill();

      sigma.utils.canvas.resetLevel(context);

      if (!node.active && borderSize > 0 && (size > 2 * borderSize)) {
		    drawBorder(context, x, y, size, borderColor, borderSize);
      }
    }

    // Image:
    if (node.image) {
      sigma.utils.canvas.drawImage(
        node, x, y, size, context, imgCrossOrigin, settings('imageThreshold')
      );
    }

    // Icon:
    if (node.icon) {
      sigma.utils.canvas.drawIcon(node, x, y, size, context, settings('iconThreshold'));
    }

  };
})();

},{}],6:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapĥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _self = this,
        _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'overNode',
        'overNodes',
        'outNode',
        'outNodes',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

    // Deal with resize:
    window.addEventListener('resize', function() {
      if (_self.settings)
        _self.refresh();
    });
  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.renderCamera(camera, camera.isAnimated);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'overNode',
          'overNodes',
          'overEdge',
          'overEdges',
          'outNode',
          'outNodes',
          'outEdge',
          'outEdges',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph.nodes(), {
          prefix: c.readPrefix,
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          c.settings('enableEdgeHovering')
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var i,
        l,
        a,
        prefix = 0;

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.settings('skipErrors'))
        try {
          this.renderers[a[i]].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".render()"'
            );
        }
      else
        this.renderers[a[i]].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "' + a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "' +
                    a[i].id +
                    '" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.2.1';




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright © 2013 Alexis Jacomy, Sciences-Po médialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exist or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every job that is stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */
  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number} x1  The X coordinate of the start point.
   * @param  {number} y1  The Y coordinate of the start point.
   * @param  {number} x2  The X coordinate of the end point.
   * @param  {number} y2  The Y coordinate of the end point.
   * @return {x,y}        The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {
    return {
      x: (x1 + x2) / 2 + (y2 - y1) / 4,
      y: (y1 + y2) / 2 + (x1 - x2) / 4
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,
      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = Math.pow(1 - t, 3),
        B1_t = 3 * t * Math.pow(1 - t, 2),
        B2_t = 3 * Math.pow(t, 2) * (1 - t),
        B3_t = Math.pow(t, 3);

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    // http://stackoverflow.com/a/328122
    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
        d = sigma.utils.getDistance(x1, y1, x2, y2),
        nCrossProduct = crossProduct / d; // normalized cross product

    return (nCrossProduct < epsilon &&
     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&
     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio)
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */
  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };




  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };
}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik Möller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: true,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of hovered nodes.
    borderSize: 0,
    // {number} The default hovered node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,




    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the instance has to refresh itself
    //           automatically when a "resize" event is dispatched from the
    //           window object.
    autoResize: true,
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,




    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: Object.create(null),
      edgesIndex: Object.create(null),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: Object.create(null),
      outNeighborsIndex: Object.create(null),
      allNeighborsIndex: Object.create(null),

      inNeighborsCount: Object.create(null),
      outNeighborsCount: Object.create(null),
      allNeighborsCount: Object.create(null)
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex[node.id])
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex[id] = Object.create(null);
    this.outNeighborsIndex[id] = Object.create(null);
    this.allNeighborsIndex[id] = Object.create(null);

    this.inNeighborsCount[id] = 0;
    this.outNeighborsCount[id] = 0;
    this.allNeighborsCount[id] = 0;

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex[validNode.id] = validNode;

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex[edge.source])
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex[edge.target])
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex[edge.id])
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex[validEdge.id] = validEdge;

    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])
      this.inNeighborsIndex[validEdge.target][validEdge.source] =
        Object.create(null);
    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
      validEdge;

    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])
      this.outNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])
      this.allNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])
        this.allNeighborsIndex[validEdge.target][validEdge.source] =
          Object.create(null);
      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
        validEdge;
    }

    // Keep counts up to date:
    this.inNeighborsCount[validEdge.target]++;
    this.outNeighborsCount[validEdge.source]++;
    this.allNeighborsCount[validEdge.target]++;
    this.allNeighborsCount[validEdge.source]++;

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex[id])
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    delete this.nodesIndex[id];
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    delete this.inNeighborsIndex[id];
    delete this.outNeighborsIndex[id];
    delete this.allNeighborsIndex[id];

    delete this.inNeighborsCount[id];
    delete this.outNeighborsCount[id];
    delete this.allNeighborsCount[id];

    for (k in this.nodesIndex) {
      delete this.inNeighborsIndex[k][id];
      delete this.outNeighborsIndex[k][id];
      delete this.allNeighborsIndex[k][id];
    }

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex[id])
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex[id];
    delete this.edgesIndex[id];
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];
    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)
      delete this.inNeighborsIndex[edge.target][edge.source];

    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)
      delete this.outNeighborsIndex[edge.source][edge.target];

    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)
      delete this.allNeighborsIndex[edge.source][edge.target];

    if (edge.target !== edge.source) {
      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];
      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)
        delete this.allNeighborsIndex[edge.target][edge.source];
    }

    this.inNeighborsCount[edge.target]--;
    this.outNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.target]--;

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
    delete this.inNeighborsCount;
    delete this.outNeighborsCount;
    delete this.allNeighborsCount;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    __emptyObject(this.nodesIndex);
    __emptyObject(this.edgesIndex);
    __emptyObject(this.nodesIndex);
    __emptyObject(this.inNeighborsIndex);
    __emptyObject(this.outNeighborsIndex);
    __emptyObject(this.allNeighborsIndex);
    __emptyObject(this.inNeighborsCount);
    __emptyObject(this.outNeighborsCount);
    __emptyObject(this.allNeighborsCount);

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex[v];

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex[v[i]]);
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsCount,
      'out': this.outNeighborsCount
    }[which || ''] || this.allNeighborsCount;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which[v];

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which[v[i]]);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex[v];

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex[v[i]]);
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree  Property holding the quadtree object.
   * property {object} _geom  Exposition of the _geom namespace for testing.
   * property {object} _cache Cache for the area method.
   */
  var quad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
  };

  /**
   * Index a graph by inserting its nodes into the quadtree.
   *
   * @param  {array}  nodes   An array of nodes to index.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(nodes, params) {

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '';

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    // Inserting graph nodes into the tree
    for (var i = 0, l = nodes.length; i < l; i++) {

      // Inserting node
      _quadInsert(
        nodes[i],
        _geom.pointToSquare({
          x: nodes[i][prefix + 'x'],
          y: nodes[i][prefix + 'y'],
          size: nodes[i][prefix + 'size']
        }),
        this._tree
      );
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var nodes = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var nodesArray = [];
    for (var i in nodes)
      nodesArray.push(nodes[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = nodesArray;

    return nodesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module for edges
   * ===============================
   *
   * Author: Sébastien Heymann,
   *   from the quad of Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 40,
      maxLevel: maxLevel || 8,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The edgequad API as exposed to sigma.
   */

  /**
   * The edgequad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree     Property holding the quadtree object.
   * property {object} _geom     Exposition of the _geom namespace for testing.
   * property {object} _cache    Cache for the area method.
   * property {boolean} _enabled Can index and retreive elements.
   */
  var edgequad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
  };

  /**
   * Index a graph by inserting its edges into the quadtree.
   *
   * @param  {object} graph   A graph instance.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for edge geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  edgequad.prototype.index = function(graph, params) {
    if (!this._enabled)
      return this._tree;

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.edgequad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        source,
        target,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    var edges = graph.edges();

    // Inserting graph edges into the tree
    for (var i = 0, l = edges.length; i < l; i++) {
      source = graph.nodes(edges[i].source);
      target = graph.nodes(edges[i].target);
      e = {
        x1: source[prefix + 'x'],
        y1: source[prefix + 'y'],
        x2: target[prefix + 'x'],
        y2: target[prefix + 'y'],
        size: edges[i][prefix + 'size'] || 0
      };

      // Inserting edge
      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
        if (source.id === target.id) {
          n = {
            x: source[prefix + 'x'],
            y: source[prefix + 'y'],
            size: source[prefix + 'size'] || 0
          };
          _quadInsert(
            edges[i],
            _geom.selfLoopToSquare(n),
            this._tree);
        }
        else {
          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);
          _quadInsert(
            edges[i],
            _geom.quadraticCurveToSquare(e, cp),
            this._tree);
        }
      }
      else {
        _quadInsert(
          edges[i],
          _geom.lineToSquare(e),
          this._tree);
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph edges held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph edges within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving edges
    var edges = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var edgesArray = [];
    for (var i in edges)
      edgesArray.push(edges[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = edgesArray;

    return edgesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.edgequad = edgequad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = edgequad;
    exports.edgequad = edgequad;
  } else
    this.edgequad = edgequad;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation,
          wheelDelta = sigma.utils.getDelta(e);

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {
        ratio = wheelDelta > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };




  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        renderers,
        rendererType,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      // First, let's identify which edges to draw. To do this, we just keep
      // every edges that have at least one extremity displayed according to
      // the quadtree and the "hidden" attribute. We also do not keep hidden
      // edges.
      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
        o = a[i];
        if (
          (index[o.source] || index[o.target]) &&
          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
        )
          this.edgesOnScreen.push(o);
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (this.settings(options, 'batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          renderers = sigma.canvas.edges;
          for (i = start; i < end; i++) {
            o = edges[i];
            (renderers[
              o.type || this.settings(options, 'defaultEdgeType')
            ] || renderers.def)(
              o,
              graph.nodes(o.source),
              graph.nodes(o.target),
              this.contexts.edges,
              embedSettings
            );
          }

          // Draw edge labels:
          if (drawEdgeLabels) {
            renderers = sigma.canvas.edges.labels;
            for (i = start; i < end; i++) {
              o = edges[i];
              if (!o.hidden)
                (renderers[
                  o.type || this.settings(options, 'defaultEdgeType')
                ] || renderers.def)(
                  o,
                  graph.nodes(o.source),
                  graph.nodes(o.target),
                  this.contexts.labels,
                  embedSettings
                );
            }
          }

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        renderers = sigma.canvas.edges;
        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
          o = a[i];
          (renderers[
            o.type || this.settings(options, 'defaultEdgeType')
          ] || renderers.def)(
            o,
            graph.nodes(o.source),
            graph.nodes(o.target),
            this.contexts.edges,
            embedSettings
          );
        }

        // Draw edge labels:
        // - No batching
        if (drawEdgeLabels) {
          renderers = sigma.canvas.edges.labels;
          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)
            if (!a[i].hidden)
              (renderers[
                a[i].type || this.settings(options, 'defaultEdgeType')
              ] || renderers.def)(
                a[i],
                graph.nodes(a[i].source),
                graph.nodes(a[i].target),
                this.contexts.labels,
                embedSettings
              );
        }
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      renderers = sigma.canvas.nodes;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.nodes,
            embedSettings
          );
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      renderers = sigma.canvas.labels;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.labels,
            embedSettings
          );
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          e = (subrenderers[a[i].type] || subrenderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.labels[a[i].id] = e;
          this.domElements.groups.labels.appendChild(e);
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        (subrenderers[a[i].type] || subrenderers.def).update(
          a[i],
          this.domElements.labels[a[i].id],
          embedSettings
        );
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function overNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      var hover = (renderers[node.type] || renderers.def).create(
        node,
        self.domElements.nodes[node.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[node.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
      hoveredNode = node;
    }

    function outNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      // Deleting element
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[node.id]
      );
      hoveredNode = null;
      delete self.domElements.hovers[node.id];

      // Reinstate
      self.domElements.groups.nodes.appendChild(
        self.domElements.nodes[node.id]
      );
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('overNode', overNode);
    this.bind('outNode', outNode);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = 1;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = w + 'px';
      this.domElements.graph.style.height = h + 'px';

      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {
        this.domElements.graph.setAttribute('width', (w * pixelRatio));
        this.domElements.graph.setAttribute('height', (h * pixelRatio));
      }
    }

    return this;
  };


  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Check if WebGL is enabled:
  var canvas,
      webgl = !!global.WebGLRenderingContext;
  if (webgl) {
    canvas = document.createElement('canvas');
    try {
      webgl = !!(
        canvas.getContext('webgl') ||
        canvas.getContext('experimental-webgl')
      );
    } catch (e) {
      webgl = false;
    }
  }

  // Copy the good renderer:
  sigma.renderers.def = webgl ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will just display the label on the right of the node.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.labels.def = function(node, context, settings) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'];

    if (size < settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +
      fontSize + 'px ' + settings('font');
    context.fillStyle = (settings('labelColor') === 'node') ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultLabelColor');

    context.fillText(
      node.label,
      Math.round(node[prefix + 'x'] + size + 3),
      Math.round(node[prefix + 'y'] + fontSize / 3)
    );
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;

    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (node.label && settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    if (node.label && typeof node.label === 'string') {
      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
      w = Math.round(
        context.measureText(node.label).width + fontSize / 2 + size + 7
      );
      h = Math.round(fontSize + 4);
      e = Math.round(fontSize / 2 + 2);

      context.moveTo(x, y + e);
      context.arcTo(x, y, x + e, y, e);
      context.lineTo(x + w, y);
      context.lineTo(x + w, y + h);
      context.lineTo(x + e, y + h);
      context.arcTo(x, y + h, x, y + h - e, e);
      context.lineTo(x, y + e);

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    // Node border:
    if (settings('borderSize') > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + settings('borderSize'),
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');

      context.fillText(
        node.label,
        Math.round(node[prefix + 'x'] + size + 3),
        Math.round(node[prefix + 'y'] + fontSize / 3)
      );
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = size * 2.5,
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (source.id === target.id) {
      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));
      aSize = size * 2.5;
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the node as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '';

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      // Control point
      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +
        (target[prefix + 'y'] - source[prefix + 'y']) / 4,
          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +
        (source[prefix + 'x'] - target[prefix + 'x']) / 4;

      // Path
      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +
              'Q' + cx + ',' + cy + ' ' +
              target[prefix + 'x'] + ',' + target[prefix + 'y'];

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    /**
     * First, we compute the scaling ratio, without considering the sizes
     * of the nodes : Each node will have its center in the canvas, but might
     * be partially out of it.
     */
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    /**
     * Then, we correct that scaling ratio considering a margin, which is
     * basically the size of the biggest node.
     * This has to be done as a correction since to compare the size of the
     * biggest node to the X and Y values, we have to first get an
     * approximation of the scaling ratio.
     **/
    margin =
      (
        settings('rescaleIgnoreSize') ?
          0 :
          (settings('maxNodeSize') || sizeMax) / scale
      ) +
      (settings('sideMargin') || 0);
    maxX += margin;
    minX -= margin;
    maxY += margin;
    minY -= margin;

    // Fix the scaling with the new extrema:
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);
      n[i][writePrefix + 'x'] =
        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);
      n[i][writePrefix + 'y'] =
        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              Math.pow(modifiedX - x, 2) +
              Math.pow(modifiedY - y, 2)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y']);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            i,
            l,
            le,
            outNodes = [],
            outEdges = [];

        for (k in overNodes)
          outNodes.push(overNodes[k]);

        overNodes = {};
        // Dispatch both single and multi events:
        for (i = 0, l = outNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: outNodes[i],
            captor: e.data
          });
        if (outNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: outNodes,
            captor: e.data
          });

        overEdges = {};
        // Dispatch both single and multi events:
        for (i = 0, le = outEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: outEdges[i],
            captor: e.data
          });
        if (outEdges.length)
          self.dispatchEvent('outEdges', {
            edges: outEdges,
            captor: e.data
          });
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            l = nodes.length,
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {},
            le = edges.length;

        // Check newly overred nodes:
        for (i = 0; i < l; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, l = newOverNodes.length; i < l; i++)
          self.dispatchEvent('overNode', {
            node: newOverNodes[i],
            captor: e.data
          });
        for (i = 0, l = newOutNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: newOutNodes[i],
            captor: e.data
          });
        if (newOverNodes.length)
          self.dispatchEvent('overNodes', {
            nodes: newOverNodes,
            captor: e.data
          });
        if (newOutNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: newOutNodes,
            captor: e.data
          });

        // Check newly overred edges:
        for (i = 0; i < le; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, le = newOverEdges.length; i < le; i++)
          self.dispatchEvent('overEdge', {
            edge: newOverEdges[i],
            captor: e.data
          });
        for (i = 0, le = newOutEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: newOutEdges[i],
            captor: e.data
          });
        if (newOverEdges.length)
          self.dispatchEvent('overEdges', {
            edges: newOverEdges,
            captor: e.data
          });
        if (newOutEdges.length)
          self.dispatchEvent('outEdges', {
            edges: newOutEdges,
            captor: e.data
          });
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
      self.bind('render', onMove);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph;

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('overNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('overEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('outNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('outEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "overNode", "outNode", "overEdge" and "outEdge"
   * events from a renderer and renders the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        hoveredNodes = {},
        hoveredEdges = {};

    this.bind('overNode', function(event) {
      var node = event.data.node;
      if (!node.hidden) {
        hoveredNodes[node.id] = node;
        draw();
      }
    });

    this.bind('outNode', function(event) {
      delete hoveredNodes[event.data.node.id];
      draw();
    });

    this.bind('overEdge', function(event) {
      var edge = event.data.edge;
      if (!edge.hidden) {
        hoveredEdges[edge.id] = edge;
        draw();
      }
    });

    this.bind('outEdge', function(event) {
      delete hoveredEdges[event.data.edge.id];
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {

      var k,
          source,
          target,
          hoveredNode,
          hoveredEdge,
          c = self.contexts.hover.canvas,
          defaultNodeType = self.settings('defaultNodeType'),
          defaultEdgeType = self.settings('defaultEdgeType'),
          nodeRenderers = sigma.canvas.hovers,
          edgeRenderers = sigma.canvas.edgehovers,
          extremitiesRenderers = sigma.canvas.extremities,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Clear self.contexts.hover:
      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render: single hover
      if (
        embedSettings('enableHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredNodes).length
      ) {
        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];
        (
          nodeRenderers[hoveredNode.type] ||
          nodeRenderers[defaultNodeType] ||
          nodeRenderers.def
        )(
          hoveredNode,
          self.contexts.hover,
          embedSettings
        );
      }

      // Node render: multiple hover
      if (
        embedSettings('enableHovering') &&
        !embedSettings('singleHover')
      )
        for (k in hoveredNodes)
          (
            nodeRenderers[hoveredNodes[k].type] ||
            nodeRenderers[defaultNodeType] ||
            nodeRenderers.def
          )(
            hoveredNodes[k],
            self.contexts.hover,
            embedSettings
          );

      // Edge render: single hover
      if (
        embedSettings('enableEdgeHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredEdges).length
      ) {
        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];
        source = self.graph.nodes(hoveredEdge.source);
        target = self.graph.nodes(hoveredEdge.target);

        if (! hoveredEdge.hidden) {
          (
            edgeRenderers[hoveredEdge.type] ||
            edgeRenderers[defaultEdgeType] ||
            edgeRenderers.def
          ) (
            hoveredEdge,
            source,
            target,
            self.contexts.hover,
            embedSettings
          );

          if (embedSettings('edgeHoverExtremities')) {
            (
              extremitiesRenderers[hoveredEdge.type] ||
              extremitiesRenderers.def
            )(
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

          } else {
            // Avoid edges rendered over nodes:
            (
              sigma.canvas.nodes[source.type] ||
              sigma.canvas.nodes.def
            ) (
              source,
              self.contexts.hover,
              embedSettings
            );
            (
              sigma.canvas.nodes[target.type] ||
              sigma.canvas.nodes.def
            ) (
              target,
              self.contexts.hover,
              embedSettings
            );
          }
        }
      }

      // Edge render: multiple hover
      if (
        embedSettings('enableEdgeHovering') &&
        !embedSettings('singleHover')
      ) {
        for (k in hoveredEdges) {
          hoveredEdge = hoveredEdges[k];
          source = self.graph.nodes(hoveredEdge.source);
          target = self.graph.nodes(hoveredEdge.target);

          if (!hoveredEdge.hidden) {
            (
              edgeRenderers[hoveredEdge.type] ||
              edgeRenderers[defaultEdgeType] ||
              edgeRenderers.def
            ) (
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

            if (embedSettings('edgeHoverExtremities')) {
              (
                extremitiesRenderers[hoveredEdge.type] ||
                extremitiesRenderers.def
              )(
                hoveredEdge,
                source,
                target,
                self.contexts.hover,
                embedSettings
              );
            } else {
              // Avoid edges rendered over nodes:
              (
                sigma.canvas.nodes[source.type] ||
                sigma.canvas.nodes.def
              ) (
                source,
                self.contexts.hover,
                embedSettings
              );
              (
                sigma.canvas.nodes[target.type] ||
                sigma.canvas.nodes.def
              ) (
                target,
                self.contexts.hover,
                embedSettings
              );
            }
          }
        }
      }
    }
  };
}).call(this);

},{}],7:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma is not declared');

  // Initialize package:
  sigma.utils.pkg('sigma.layout.noverlap');

  /**
   * Noverlap Layout
   * ===============================
   *
   * Author: @apitts / Andrew Pitts
   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)
   * Acknowledgement: @sheyman / Sébastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)
   * Version: 0.1
   */

  var settings = {
    speed: 3,
    scaleNodes: 1.2,
    nodeMargin: 5.0,
    gridSize: 20,
    permittedExpansion: 1.1,
    rendererIndex: 0,
    maxIterations: 500
  };

  var _instance = {};

  /**
   * Event emitter Object
   * ------------------
   */
  var _eventEmitter = {};

   /**
   * Noverlap Object
   * ------------------
   */
  function Noverlap() {
    var self = this;

    this.init = function (sigInst, options) {
      options = options || {};

      // Properties
      this.sigInst = sigInst;
      this.config = sigma.utils.extend(options, settings);
      this.easing = options.easing;
      this.duration = options.duration;

      if (options.nodes) {
        this.nodes = options.nodes;
        delete options.nodes;
      }

      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {
        throw new Error('sigma.plugins.animate is not declared');
      }

      // State
      this.running = false;
    };

    /**
     * Single layout iteration.
     */
    this.atomicGo = function () {
      if (!this.running || this.iterCount < 1) return false;

      var nodes = this.nodes || this.sigInst.graph.nodes(),
          nodesCount = nodes.length,
          i,
          n,
          n1,
          n2,
          xmin = Infinity,
          xmax = -Infinity,
          ymin = Infinity,
          ymax = -Infinity,
          xwidth,
          yheight,
          xcenter,
          ycenter,
          grid,
          row,
          col,
          minXBox,
          maxXBox,
          minYBox,
          maxYBox,
          adjacentNodes,
          subRow,
          subCol,
          nxmin,
          nxmax,
          nymin,
          nymax;

      this.iterCount--;
      this.running = false;

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        n.dn.dx = 0;
        n.dn.dy = 0;

        //Find the min and max for both x and y across all nodes
        xmin = Math.min(xmin, n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        xmax = Math.max(xmax, n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymin = Math.min(ymin, n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymax = Math.max(ymax, n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );

      }

      xwidth = xmax - xmin;
      yheight = ymax - ymin;
      xcenter = (xmin + xmax) / 2;
      ycenter = (ymin + ymax) / 2;
      xmin = xcenter - self.config.permittedExpansion*xwidth / 2;
      xmax = xcenter + self.config.permittedExpansion*xwidth / 2;
      ymin = ycenter - self.config.permittedExpansion*yheight / 2;
      ymax = ycenter + self.config.permittedExpansion*yheight / 2;

      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid

      for(row = 0; row < self.config.gridSize; row++) {
        grid[row] = {};
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col] = [];
        }
      }

      //Place nodes in grid
      for (i=0; i < nodesCount; i++) {
        n = nodes[i];

        nxmin = n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nxmax = n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymin = n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymax = n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);

        minXBox = Math.floor(self.config.gridSize* (nxmin - xmin) / (xmax - xmin) );
        maxXBox = Math.floor(self.config.gridSize* (nxmax - xmin) / (xmax - xmin) );
        minYBox = Math.floor(self.config.gridSize* (nymin - ymin) / (ymax - ymin) );
        maxYBox = Math.floor(self.config.gridSize* (nymax - ymin) / (ymax - ymin) );
        for(col = minXBox; col <= maxXBox; col++) {
          for(row = minYBox; row <= maxYBox; row++) {
            grid[row][col].push(n.id);
          }
        }
      }


      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes

      for(row = 0; row < self.config.gridSize; row++) {
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col].forEach(function(nodeId) {
            if(!adjacentNodes[nodeId]) {
              adjacentNodes[nodeId] = [];
            }
            for(subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {
              for(subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1,  self.config.gridSize - 1); subCol++) {
                grid[subRow][subCol].forEach(function(subNodeId) {
                  if(subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {
                    adjacentNodes[nodeId].push(subNodeId);
                  }
                });
              }
            }
          });
        }
      }

      //If two nodes overlap then repulse them
      for (i=0; i < nodesCount; i++) {
        n1 = nodes[i];
        adjacentNodes[n1.id].forEach(function(nodeId) {
          var n2 = self.sigInst.graph.nodes(nodeId);
          var xDist = n2.dn_x - n1.dn_x;
          var yDist = n2.dn_y - n1.dn_y;
          var dist = Math.sqrt(xDist*xDist + yDist*yDist);
          var collision = (dist < ((n1.dn_size*self.config.scaleNodes + self.config.nodeMargin) + (n2.dn_size*self.config.scaleNodes + self.config.nodeMargin)));
          if(collision) {
            self.running = true;
            if(dist > 0) {
              n2.dn.dx += xDist / dist * (1 + n1.dn_size);
              n2.dn.dy += yDist / dist * (1 + n1.dn_size);
            } else {
              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());
              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());
            }
          }
        });
      }

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        if(!n.fixed) {
          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;
          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;
        }
      }

      if(this.running && this.iterCount < 1) {
        this.running = false;
      }

      return this.running;
    };

    this.go = function () {
      this.iterCount = this.config.maxIterations;

      while (this.running) {
        this.atomicGo();
      };

      this.stop();
    };

    this.start = function() {
      if (this.running) return;

      var nodes = this.sigInst.graph.nodes();

      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;

      this.running = true;

      // Init nodes
      for (var i = 0; i < nodes.length; i++) {
        nodes[i].dn_x = nodes[i][prefix + 'x'];
        nodes[i].dn_y = nodes[i][prefix + 'y'];
        nodes[i].dn_size = nodes[i][prefix + 'size'];
        nodes[i].dn = {
          dx: 0,
          dy: 0
        };
      }
      _eventEmitter[self.sigInst.id].dispatchEvent('start');
      this.go();
    };

    this.stop = function() {
      var nodes = this.sigInst.graph.nodes();

      this.running = false;

      if (this.easing) {
        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');
        sigma.plugins.animate(
          self.sigInst,
          {
            x: 'dn_x',
            y: 'dn_y'
          },
          {
            easing: self.easing,
            onComplete: function() {
              self.sigInst.refresh();
              for (var i = 0; i < nodes.length; i++) {
                nodes[i].dn = null;
                nodes[i].dn_x = null;
                nodes[i].dn_y = null;
              }
              _eventEmitter[self.sigInst.id].dispatchEvent('stop');
            },
            duration: self.duration
          }
        );
      }
      else {
        // Apply changes
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].x = nodes[i].dn_x;
          nodes[i].y = nodes[i].dn_y;
        }

        this.sigInst.refresh();

        for (var i = 0; i < nodes.length; i++) {
          nodes[i].dn = null;
          nodes[i].dn_x = null;
          nodes[i].dn_y = null;
        }
        _eventEmitter[self.sigInst.id].dispatchEvent('stop');
      }
    };

    this.kill = function() {
      this.sigInst = null;
      this.config = null;
      this.easing = null;
    };
  };

  /**
   * Interface
   * ----------
   */

  /**
   * Configure the layout algorithm.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object:
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */
  sigma.prototype.configNoverlap = function(config) {

    var sigInst = this;

    if (!config) throw new Error('Missing argument: "config"');

    // Create instance if undefined
    if (!_instance[sigInst.id]) {
      _instance[sigInst.id] = new Noverlap();

      _eventEmitter[sigInst.id] = {};
      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]);

      // Binding on kill to clear the references
      sigInst.bind('kill', function() {
        _instance[sigInst.id].kill();
        _instance[sigInst.id] = null;
        _eventEmitter[sigInst.id] = null;
      });
    }

    _instance[sigInst.id].init(sigInst, config);

    return _eventEmitter[sigInst.id];
  };

  /**
   * Start the layout algorithm. It will use the existing configuration if no
   * new configuration is passed.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */

  sigma.prototype.startNoverlap = function(config) {

    var sigInst = this;

    if (config) {
      this.configNoverlap(sigInst, config);
    }

    _instance[sigInst.id].start();

    return _eventEmitter[sigInst.id];
  };

  /**
   * Returns true if the layout has started and is not completed.
   *
   * @return {boolean}
   */
  sigma.prototype.isNoverlapRunning = function() {

    var sigInst = this;

    return !!_instance[sigInst.id] && _instance[sigInst.id].running;
  };

}).call(this);
},{}],8:[function(require,module,exports){
/**
 * This plugin provides a method to animate a sigma instance by interpolating
 * some node properties. Check the sigma.plugins.animate function doc or the
 * examples/animate.html code sample to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');

  var _id = 0,
      _cache = {};

  // TOOLING FUNCTIONS:
  // ******************
  function parseColor(val) {
    if (_cache[val])
      return _cache[val];

    var result = [0, 0, 0];

    if (val.match(/^#/)) {
      val = (val || '').replace(/^#/, '');
      result = (val.length === 3) ?
        [
          parseInt(val.charAt(0) + val.charAt(0), 16),
          parseInt(val.charAt(1) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(2), 16)
        ] :
        [
          parseInt(val.charAt(0) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(3), 16),
          parseInt(val.charAt(4) + val.charAt(5), 16)
        ];
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      result = [
        +val[1],
        +val[2],
        +val[3]
      ];
    }

    _cache[val] = {
      r: result[0],
      g: result[1],
      b: result[2]
    };

    return _cache[val];
  }

  function interpolateColors(c1, c2, p) {
    c1 = parseColor(c1);
    c2 = parseColor(c2);

    var c = {
      r: c1.r * (1 - p) + c2.r * p,
      g: c1.g * (1 - p) + c2.g * p,
      b: c1.b * (1 - p) + c2.b * p
    };

    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';
  }

  /**
   * This function will animate some specified node properties. It will
   * basically call requestAnimationFrame, interpolate the values and call the
   * refresh method during a specified duration.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {?array}             nodes      An array of node objects or node ids. If
   *                                   not specified, all nodes of the graph
   *                                   will be animated.
   *   {?(function|string)} easing     Either the name of an easing in the
   *                                   sigma.utils.easings package or a
   *                                   function. If not specified, the
   *                                   quadraticInOut easing from this package
   *                                   will be used instead.
   *   {?number}            duration   The duration of the animation. If not
   *                                   specified, the "animationsTime" setting
   *                                   value of the sigma instance will be used
   *                                   instead.
   *   {?function}          onComplete Eventually a function to call when the
   *                                   animation is ended.
   *
   * @param  {sigma}   s       The related sigma instance.
   * @param  {object}  animate An hash with the keys being the node properties
   *                           to interpolate, and the values being the related
   *                           target values.
   * @param  {?object} options Eventually an object with options.
   */
  sigma.plugins.animate = function(s, animate, options) {
    var o = options || {},
        id = ++_id,
        duration = o.duration || s.settings('animationsTime'),
        easing = typeof o.easing === 'string' ?
          sigma.utils.easings[o.easing] :
          typeof o.easing === 'function' ?
          o.easing :
          sigma.utils.easings.quadraticInOut,
        start = sigma.utils.dateNow(),
        nodes,
        startPositions;

    if (o.nodes && o.nodes.length) {
      if (typeof o.nodes[0] === 'object')
        nodes = o.nodes;
      else
        nodes = s.graph.nodes(o.nodes); // argument is an array of IDs
    }
    else
      nodes = s.graph.nodes();

    // Store initial positions:
    startPositions = nodes.reduce(function(res, node) {
      var k;
      res[node.id] = {};
      for (k in animate)
        if (k in node)
          res[node.id][k] = node[k];
      return res;
    }, {});

    s.animations = s.animations || Object.create({});
    sigma.plugins.kill(s);

    // Do not refresh edgequadtree during drag:
    var k,
        c;
    for (k in s.cameras) {
      c = s.cameras[k];
      c.edgequadtree._enabled = false;
    }

    function step() {
      var p = (sigma.utils.dateNow() - start) / duration;

      if (p >= 1) {
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate)
              node[k] = node[animate[k]];
        });

        // Allow to refresh edgequadtree:
        var k,
            c;
        for (k in s.cameras) {
          c = s.cameras[k];
          c.edgequadtree._enabled = true;
        }

        s.refresh();
        if (typeof o.onComplete === 'function')
          o.onComplete();
      } else {
        p = easing(p);
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate) {
              if (k.match(/color$/))
                node[k] = interpolateColors(
                  startPositions[node.id][k],
                  node[animate[k]],
                  p
                );
              else
                node[k] =
                  node[animate[k]] * p +
                  startPositions[node.id][k] * (1 - p);
            }
        });

        s.refresh();
        s.animations[id] = requestAnimationFrame(step);
      }
    }

    step();
  };

  sigma.plugins.kill = function(s) {
    for (var k in (s.animations || {}))
      cancelAnimationFrame(s.animations[k]);

    // Allow to refresh edgequadtree:
    var k,
        c;
    for (k in s.cameras) {
      c = s.cameras[k];
      c.edgequadtree._enabled = true;
    }
  };
}).call(window);

},{}],9:[function(require,module,exports){
/**
 * This plugin provides a method to drag & drop nodes. Check the
 * sigma.plugins.dragNodes function doc or the examples/basic.html &
 * examples/api-candy.html code samples to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');


  /**
   * This function will add `mousedown`, `mouseup` & `mousemove` events to the
   * nodes in the `overNode`event to perform drag & drop operations. It uses
   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]
   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to
   * calculate the X and Y coordinates from the `cam` or `renderer` node
   * attributes. These attributes represent the coordinates of the nodes in
   * the real container, not in canvas.
   *
   * Fired events:
   * *************
   * startdrag  Fired at the beginning of the drag.
   * drag       Fired while the node is dragged.
   * drop       Fired at the end of the drag if the node has been dragged.
   * dragend    Fired at the end of the drag.
   *
   * Recognized parameters:
   * **********************
   * @param  {sigma}    s        The related sigma instance.
   * @param  {renderer} renderer The related renderer instance.
   */
  function DragNodes(s, renderer) {
    sigma.classes.dispatcher.extend(this);

    // A quick hardcoded rule to prevent people from using this plugin with the
    // WebGL renderer (which is impossible at the moment):
    // if (
    //   sigma.renderers.webgl &&
    //   renderer instanceof sigma.renderers.webgl
    // )
    //   throw new Error(
    //     'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'
    //   );

    // Init variables:
    var _self = this,
      _s = s,
      _body = document.body,
      _renderer = renderer,
      _mouse = renderer.container.lastChild,
      _camera = renderer.camera,
      _node = null,
      _prefix = '',
      _hoverStack = [],
      _hoverIndex = {},
      _isMouseDown = false,
      _isMouseOverCanvas = false,
      _drag = false;

    if (renderer instanceof sigma.renderers.svg) {
        _mouse = renderer.container.firstChild;
    }

    // It removes the initial substring ('read_') if it's a WegGL renderer.
    if (renderer instanceof sigma.renderers.webgl) {
      _prefix = renderer.options.prefix.substr(5);
    } else {
      _prefix = renderer.options.prefix;
    }

    renderer.bind('overNode', nodeMouseOver);
    renderer.bind('outNode', treatOutNode);
    renderer.bind('click', click);

    _s.bind('kill', function() {
      _self.unbindAll();
    });

    /**
     * Unbind all event listeners.
     */
    this.unbindAll = function() {
      _mouse.removeEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);
      _renderer.unbind('overNode', nodeMouseOver);
      _renderer.unbind('outNode', treatOutNode);
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function calculateOffset(element) {
      var style = window.getComputedStyle(element);
      var getCssProperty = function(prop) {
        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
      };
      return {
        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
        top: element.getBoundingClientRect().top + getCssProperty('padding-top')
      };
    };

    function click(event) {
      // event triggered at the end of the click
      _isMouseDown = false;
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      if (!_hoverStack.length) {
        _node = null;
      }
    };

    function nodeMouseOver(event) {
      // Don't treat the node if it is already registered
      if (_hoverIndex[event.data.node.id]) {
        return;
      }

      // Add node to array of current nodes over
      _hoverStack.push(event.data.node);
      _hoverIndex[event.data.node.id] = true;

      if(_hoverStack.length && ! _isMouseDown) {
        // Set the current node to be the last one in the array
        _node = _hoverStack[_hoverStack.length - 1];
        _mouse.addEventListener('mousedown', nodeMouseDown);
      }
    };

    function treatOutNode(event) {
      // Remove the node from the array
      var indexCheck = _hoverStack.map(function(e) { return e; }).indexOf(event.data.node);
      _hoverStack.splice(indexCheck, 1);
      delete _hoverIndex[event.data.node.id];

      if(_hoverStack.length && ! _isMouseDown) {
        // On out, set the current node to be the next stated in array
        _node = _hoverStack[_hoverStack.length - 1];
      } else {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
      }
    };

    function nodeMouseDown(event) {
      _isMouseDown = true;
      var size = _s.graph.nodes().length;

      // when there is only node in the graph, the plugin cannot apply
      // linear interpolation. So treat it as if a user is dragging
      // the graph
      if (_node && size > 1) {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
        _body.addEventListener('mousemove', nodeMouseMove);
        _body.addEventListener('mouseup', nodeMouseUp);

        // Do not refresh edgequadtree during drag:
        var k,
            c;
        for (k in _s.cameras) {
          c = _s.cameras[k];
          if (c.edgequadtree !== undefined) {
            c.edgequadtree._enabled = false;
          }
        }

        // Deactivate drag graph.
        _renderer.settings({mouseEnabled: false, enableHovering: false});
        _s.refresh();

        _self.dispatchEvent('startdrag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };

    function nodeMouseUp(event) {
      _isMouseDown = false;
      _mouse.addEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      // Allow to refresh edgequadtree:
      var k,
          c;
      for (k in _s.cameras) {
        c = _s.cameras[k];
        if (c.edgequadtree !== undefined) {
          c.edgequadtree._enabled = true;
        }
      }

      // Activate drag graph.
      _renderer.settings({mouseEnabled: true, enableHovering: true});
      _s.refresh();

      if (_drag) {
        _self.dispatchEvent('drop', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
      _self.dispatchEvent('dragend', {
        node: _node,
        captor: event,
        renderer: _renderer
      });

      _drag = false;
      _node = null;
    };

    function nodeMouseMove(event) {
      if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        clearTimeout(timeOut);
        var timeOut = setTimeout(executeNodeMouseMove, 0);
      } else {
        executeNodeMouseMove();
      }

      function executeNodeMouseMove() {
        var offset = calculateOffset(_renderer.container),
            x = event.clientX - offset.left,
            y = event.clientY - offset.top,
            cos = Math.cos(_camera.angle),
            sin = Math.sin(_camera.angle),
            nodes = _s.graph.nodes(),
            ref = [];

        // Getting and derotating the reference coordinates.
        for (var i = 0; i < 2; i++) {
          var n = nodes[i];
          var aux = {
            x: n.x * cos + n.y * sin,
            y: n.y * cos - n.x * sin,
            renX: n[_prefix + 'x'],
            renY: n[_prefix + 'y'],
          };
          ref.push(aux);
        }

        // Applying linear interpolation.
        // if the nodes are on top of each other, we use the camera ratio to interpolate
        if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {
          var xRatio = (ref[0].renX === 0) ? 1 : ref[0].renX;
          var yRatio = (ref[0].renY === 0) ? 1 : ref[0].renY;
          x = (ref[0].x / xRatio) * (x - ref[0].renX) + ref[0].x;
          y = (ref[0].y / yRatio) * (y - ref[0].renY) + ref[0].y;
        } else {
          var xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);
          var yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);

          // if the coordinates are the same, we use the other ratio to interpolate
          if (ref[1].x === ref[0].x) {
            xRatio = yRatio;
          }

          if (ref[1].y === ref[0].y) {
            yRatio = xRatio;
          }

          x = (x - ref[0].renX) / xRatio + ref[0].x;
          y = (y - ref[0].renY) / yRatio + ref[0].y;
        }

        // Rotating the coordinates.
        _node.x = x * cos - y * sin;
        _node.y = y * cos + x * sin;

        _s.refresh();

        _drag = true;
        _self.dispatchEvent('drag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };
  };

  /**
   * Interface
   * ------------------
   *
   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0]);
   */
  var _instance = {};

  /**
   * @param  {sigma} s The related sigma instance.
   * @param  {renderer} renderer The related renderer instance.
   */
  sigma.plugins.dragNodes = function(s, renderer) {
    // Create object if undefined
    if (!_instance[s.id]) {
      _instance[s.id] = new DragNodes(s, renderer);
    }

    s.bind('kill', function() {
      sigma.plugins.killDragNodes(s);
    });

    return _instance[s.id];
  };

  /**
   * This method removes the event listeners and kills the dragNodes instance.
   *
   * @param  {sigma} s The related sigma instance.
   */
  sigma.plugins.killDragNodes = function(s) {
    if (_instance[s.id] instanceof DragNodes) {
      _instance[s.id].unbindAll();
      delete _instance[s.id];
    }
  };

}).call(window);

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var arrays = require("./arrays");
var LinkedList = /** @class */ (function () {
    /**
    * Creates an empty Linked List.
    * @class A linked list is a data structure consisting of a group of nodes
    * which together represent a sequence.
    * @constructor
    */
    function LinkedList() {
        /**
        * First node in the list
        * @type {Object}
        * @private
        */
        this.firstNode = null;
        /**
        * Last node in the list
        * @type {Object}
        * @private
        */
        this.lastNode = null;
        /**
        * Number of elements in the list
        * @type {number}
        * @private
        */
        this.nElements = 0;
    }
    /**
    * Adds an element to this list.
    * @param {Object} item element to be added.
    * @param {number=} index optional index to add the element. If no index is specified
    * the element is added to the end of this list.
    * @return {boolean} true if the element was added or false if the index is invalid
    * or if the element is undefined.
    */
    LinkedList.prototype.add = function (item, index) {
        if (util.isUndefined(index)) {
            index = this.nElements;
        }
        if (index < 0 || index > this.nElements || util.isUndefined(item)) {
            return false;
        }
        var newNode = this.createNode(item);
        if (this.nElements === 0 || this.lastNode === null) {
            // First node in the list.
            this.firstNode = newNode;
            this.lastNode = newNode;
        }
        else if (index === this.nElements) {
            // Insert at the end.
            this.lastNode.next = newNode;
            this.lastNode = newNode;
        }
        else if (index === 0) {
            // Change first node.
            newNode.next = this.firstNode;
            this.firstNode = newNode;
        }
        else {
            var prev = this.nodeAtIndex(index - 1);
            if (prev == null) {
                return false;
            }
            newNode.next = prev.next;
            prev.next = newNode;
        }
        this.nElements++;
        return true;
    };
    /**
    * Returns the first element in this list.
    * @return {*} the first element of the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.first = function () {
        if (this.firstNode !== null) {
            return this.firstNode.element;
        }
        return undefined;
    };
    /**
    * Returns the last element in this list.
    * @return {*} the last element in the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.last = function () {
        if (this.lastNode !== null) {
            return this.lastNode.element;
        }
        return undefined;
    };
    /**
     * Returns the element at the specified position in this list.
     * @param {number} index desired index.
     * @return {*} the element at the given index or undefined if the index is
     * out of bounds.
     */
    LinkedList.prototype.elementAtIndex = function (index) {
        var node = this.nodeAtIndex(index);
        if (node === null) {
            return undefined;
        }
        return node.element;
    };
    /**
     * Returns the index in this list of the first occurrence of the
     * specified element, or -1 if the List does not contain this element.
     * <p>If the elements inside this list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {number} the index in this list of the first occurrence
     * of the specified element, or -1 if this list does not contain the
     * element.
     */
    LinkedList.prototype.indexOf = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (util.isUndefined(item)) {
            return -1;
        }
        var currentNode = this.firstNode;
        var index = 0;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                return index;
            }
            index++;
            currentNode = currentNode.next;
        }
        return -1;
    };
    /**
       * Returns true if this list contains the specified element.
       * <p>If the elements inside the list are
       * not comparable with the === operator a custom equals function should be
       * provided to perform searches, the function must receive two arguments and
       * return true if they are equal, false otherwise. Example:</p>
       *
       * <pre>
       * const petsAreEqualByName = function(pet1, pet2) {
       *  return pet1.name === pet2.name;
       * }
       * </pre>
       * @param {Object} item element to search for.
       * @param {function(Object,Object):boolean=} equalsFunction Optional
       * function used to check if two elements are equal.
       * @return {boolean} true if this list contains the specified element, false
       * otherwise.
       */
    LinkedList.prototype.contains = function (item, equalsFunction) {
        return (this.indexOf(item, equalsFunction) >= 0);
    };
    /**
     * Removes the first occurrence of the specified element in this list.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to be removed from this list, if present.
     * @return {boolean} true if the list contained the specified element.
     */
    LinkedList.prototype.remove = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (this.nElements < 1 || util.isUndefined(item)) {
            return false;
        }
        var previous = null;
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                if (previous == null) {
                    this.firstNode = currentNode.next;
                    if (currentNode === this.lastNode) {
                        this.lastNode = null;
                    }
                }
                else if (currentNode === this.lastNode) {
                    this.lastNode = previous;
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                else {
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                this.nElements--;
                return true;
            }
            previous = currentNode;
            currentNode = currentNode.next;
        }
        return false;
    };
    /**
     * Removes all of the elements from this list.
     */
    LinkedList.prototype.clear = function () {
        this.firstNode = null;
        this.lastNode = null;
        this.nElements = 0;
    };
    /**
     * Returns true if this list is equal to the given list.
     * Two lists are equal if they have the same elements in the same order.
     * @param {LinkedList} other the other list.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function used to check if two elements are equal. If the elements in the lists
     * are custom objects you should provide a function, otherwise
     * the === operator is used to check equality between elements.
     * @return {boolean} true if this list is equal to the given list.
     */
    LinkedList.prototype.equals = function (other, equalsFunction) {
        var eqF = equalsFunction || util.defaultEquals;
        if (!(other instanceof LinkedList)) {
            return false;
        }
        if (this.size() !== other.size()) {
            return false;
        }
        return this.equalsAux(this.firstNode, other.firstNode, eqF);
    };
    /**
    * @private
    */
    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {
        while (n1 !== null && n2 !== null) {
            if (!eqF(n1.element, n2.element)) {
                return false;
            }
            n1 = n1.next;
            n2 = n2.next;
        }
        return true;
    };
    /**
     * Removes the element at the specified position in this list.
     * @param {number} index given index.
     * @return {*} removed element or undefined if the index is out of bounds.
     */
    LinkedList.prototype.removeElementAtIndex = function (index) {
        if (index < 0 || index >= this.nElements || this.firstNode === null || this.lastNode === null) {
            return undefined;
        }
        var element;
        if (this.nElements === 1) {
            //First node in the list.
            element = this.firstNode.element;
            this.firstNode = null;
            this.lastNode = null;
        }
        else {
            var previous = this.nodeAtIndex(index - 1);
            if (previous === null) {
                element = this.firstNode.element;
                this.firstNode = this.firstNode.next;
            }
            else if (previous.next === this.lastNode) {
                element = this.lastNode.element;
                this.lastNode = previous;
            }
            if (previous !== null && previous.next !== null) {
                element = previous.next.element;
                previous.next = previous.next.next;
            }
        }
        this.nElements--;
        return element;
    };
    /**
     * Executes the provided function once for each element present in this list in order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    LinkedList.prototype.forEach = function (callback) {
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (callback(currentNode.element) === false) {
                break;
            }
            currentNode = currentNode.next;
        }
    };
    /**
     * Reverses the order of the elements in this linked list (makes the last
     * element first, and the first element last).
     */
    LinkedList.prototype.reverse = function () {
        var previous = null;
        var current = this.firstNode;
        var temp = null;
        while (current !== null) {
            temp = current.next;
            current.next = previous;
            previous = current;
            current = temp;
        }
        temp = this.firstNode;
        this.firstNode = this.lastNode;
        this.lastNode = temp;
    };
    /**
     * Returns an array containing all of the elements in this list in proper
     * sequence.
     * @return {Array.<*>} an array containing all of the elements in this list,
     * in proper sequence.
     */
    LinkedList.prototype.toArray = function () {
        var array = [];
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            array.push(currentNode.element);
            currentNode = currentNode.next;
        }
        return array;
    };
    /**
     * Returns the number of elements in this list.
     * @return {number} the number of elements in this list.
     */
    LinkedList.prototype.size = function () {
        return this.nElements;
    };
    /**
     * Returns true if this list contains no elements.
     * @return {boolean} true if this list contains no elements.
     */
    LinkedList.prototype.isEmpty = function () {
        return this.nElements <= 0;
    };
    LinkedList.prototype.toString = function () {
        return arrays.toString(this.toArray());
    };
    /**
     * @private
     */
    LinkedList.prototype.nodeAtIndex = function (index) {
        if (index < 0 || index >= this.nElements) {
            return null;
        }
        if (index === (this.nElements - 1)) {
            return this.lastNode;
        }
        var node = this.firstNode;
        for (var i = 0; i < index && node != null; i++) {
            node = node.next;
        }
        return node;
    };
    /**
     * @private
     */
    LinkedList.prototype.createNode = function (item) {
        return {
            element: item,
            next: null
        };
    };
    return LinkedList;
}()); // End of linked list
exports.default = LinkedList;

},{"./arrays":12,"./util":13}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LinkedList_1 = require("./LinkedList");
var Queue = /** @class */ (function () {
    /**
     * Creates an empty queue.
     * @class A queue is a First-In-First-Out (FIFO) data structure, the first
     * element added to the queue will be the first one to be removed. This
     * implementation uses a linked list as a container.
     * @constructor
     */
    function Queue() {
        this.list = new LinkedList_1.default();
    }
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.enqueue = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.add = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Retrieves and removes the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.dequeue = function () {
        if (this.list.size() !== 0) {
            var el = this.list.first();
            this.list.removeElementAtIndex(0);
            return el;
        }
        return undefined;
    };
    /**
     * Retrieves, but does not remove, the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.peek = function () {
        if (this.list.size() !== 0) {
            return this.list.first();
        }
        return undefined;
    };
    /**
     * Returns the number of elements in this queue.
     * @return {number} the number of elements in this queue.
     */
    Queue.prototype.size = function () {
        return this.list.size();
    };
    /**
     * Returns true if this queue contains the specified element.
     * <p>If the elements inside this stack are
     * not comparable with the === operator, a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName (pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} elem element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function to check if two elements are equal.
     * @return {boolean} true if this queue contains the specified element,
     * false otherwise.
     */
    Queue.prototype.contains = function (elem, equalsFunction) {
        return this.list.contains(elem, equalsFunction);
    };
    /**
     * Checks if this queue is empty.
     * @return {boolean} true if and only if this queue contains no items; false
     * otherwise.
     */
    Queue.prototype.isEmpty = function () {
        return this.list.size() <= 0;
    };
    /**
     * Removes all of the elements from this queue.
     */
    Queue.prototype.clear = function () {
        this.list.clear();
    };
    /**
     * Executes the provided function once for each element present in this queue in
     * FIFO order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    Queue.prototype.forEach = function (callback) {
        this.list.forEach(callback);
    };
    return Queue;
}()); // End of queue
exports.default = Queue;

},{"./LinkedList":10}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
/**
 * Returns the position of the first occurrence of the specified item
 * within the specified array.4
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the first occurrence of the specified element
 * within the specified array, or -1 if not found.
 */
function indexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.indexOf = indexOf;
/**
 * Returns the position of the last occurrence of the specified element
 * within the specified array.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the last occurrence of the specified element
 * within the specified array or -1 if not found.
 */
function lastIndexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = length - 1; i >= 0; i--) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.lastIndexOf = lastIndexOf;
/**
 * Returns true if the specified array contains the specified element.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the specified array contains the specified element.
 */
function contains(array, item, equalsFunction) {
    return indexOf(array, item, equalsFunction) >= 0;
}
exports.contains = contains;
/**
 * Removes the first ocurrence of the specified element from the specified array.
 * @param {*} array the array in which to search element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the array changed after this call.
 */
function remove(array, item, equalsFunction) {
    var index = indexOf(array, item, equalsFunction);
    if (index < 0) {
        return false;
    }
    array.splice(index, 1);
    return true;
}
exports.remove = remove;
/**
 * Returns the number of elements in the specified array equal
 * to the specified object.
 * @param {Array} array the array in which to determine the frequency of the element.
 * @param {Object} item the element whose frequency is to be determined.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the number of elements in the specified array
 * equal to the specified object.
 */
function frequency(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    var freq = 0;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            freq++;
        }
    }
    return freq;
}
exports.frequency = frequency;
/**
 * Returns true if the two specified arrays are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number
 * of elements, and all corresponding pairs of elements in the two
 * arrays are equal and are in the same order.
 * @param {Array} array1 one array to be tested for equality.
 * @param {Array} array2 the other array to be tested for equality.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between elemements in the arrays.
 * @return {boolean} true if the two arrays are equal
 */
function equals(array1, array2, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    if (array1.length !== array2.length) {
        return false;
    }
    var length = array1.length;
    for (var i = 0; i < length; i++) {
        if (!equals(array1[i], array2[i])) {
            return false;
        }
    }
    return true;
}
exports.equals = equals;
/**
 * Returns shallow a copy of the specified array.
 * @param {*} array the array to copy.
 * @return {Array} a copy of the specified array
 */
function copy(array) {
    return array.concat();
}
exports.copy = copy;
/**
 * Swaps the elements at the specified positions in the specified array.
 * @param {Array} array The array in which to swap elements.
 * @param {number} i the index of one element to be swapped.
 * @param {number} j the index of the other element to be swapped.
 * @return {boolean} true if the array is defined and the indexes are valid.
 */
function swap(array, i, j) {
    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {
        return false;
    }
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
    return true;
}
exports.swap = swap;
function toString(array) {
    return '[' + array.toString() + ']';
}
exports.toString = toString;
/**
 * Executes the provided function once for each element present in this array
 * starting from index 0 to length - 1.
 * @param {Array} array The array in which to iterate.
 * @param {function(Object):*} callback function to execute, it is
 * invoked with one argument: the element value, to break the iteration you can
 * optionally return false.
 */
function forEach(array, callback) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var ele = array_1[_i];
        if (callback(ele) === false) {
            return;
        }
    }
}
exports.forEach = forEach;

},{"./util":13}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
exports.has = function (obj, prop) {
    return _hasOwnProperty.call(obj, prop);
};
/**
 * Default function to compare element order.
 * @function
 */
function defaultCompare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a === b) {
        return 0;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
/**
 * Default function to test equality.
 * @function
 */
function defaultEquals(a, b) {
    return a === b;
}
exports.defaultEquals = defaultEquals;
/**
 * Default function to convert an object to a string.
 * @function
 */
function defaultToString(item) {
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return '$s' + item;
    }
    else {
        return '$o' + item.toString();
    }
}
exports.defaultToString = defaultToString;
/**
* Joins all the properies of the object using the provided join string
*/
function makeString(item, join) {
    if (join === void 0) { join = ','; }
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return item.toString();
    }
    else {
        var toret = '{';
        var first = true;
        for (var prop in item) {
            if (exports.has(item, prop)) {
                if (first) {
                    first = false;
                }
                else {
                    toret = toret + join;
                }
                toret = toret + prop + ':' + item[prop];
            }
        }
        return toret + '}';
    }
}
exports.makeString = makeString;
/**
 * Checks if the given argument is a function.
 * @function
 */
function isFunction(func) {
    return (typeof func) === 'function';
}
exports.isFunction = isFunction;
/**
 * Checks if the given argument is undefined.
 * @function
 */
function isUndefined(obj) {
    return (typeof obj) === 'undefined';
}
exports.isUndefined = isUndefined;
/**
 * Checks if the given argument is a string.
 * @function
 */
function isString(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
}
exports.isString = isString;
/**
 * Reverses a compare function.
 * @function
 */
function reverseCompareFunction(compareFunction) {
    if (isUndefined(compareFunction) || !isFunction(compareFunction)) {
        return function (a, b) {
            if (a < b) {
                return 1;
            }
            else if (a === b) {
                return 0;
            }
            else {
                return -1;
            }
        };
    }
    else {
        return function (d, v) {
            return compareFunction(d, v) * -1;
        };
    }
}
exports.reverseCompareFunction = reverseCompareFunction;
/**
 * Returns an equal function given a compare function.
 * @function
 */
function compareToEquals(compareFunction) {
    return function (a, b) {
        return compareFunction(a, b) === 0;
    };
}
exports.compareToEquals = compareToEquals;

},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("typescript-collections/dist/lib/Queue");
const util_1 = require("typescript-collections/dist/lib/util");
let sigma = require('sigma');
window.sigma = sigma;
require('sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes');
require('sigma/plugins/sigma.plugins.animate/sigma.plugins.animate');
require('sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap');
var Status;
(function (Status) {
    Status[Status["RUNNING"] = 0] = "RUNNING";
    Status[Status["SUCCESS"] = 1] = "SUCCESS";
    Status[Status["FAILURE"] = 2] = "FAILURE";
})(Status = exports.Status || (exports.Status = {}));
function terminateAndReturn(id, blackboard, status) {
    delete blackboard[id];
    return status;
}
var blackboard = {};
function getActionTick(id) {
    return (precondition, effect, ticksRequired = 1) => {
        return () => {
            if (precondition()) {
                if (!blackboard[id]) {
                    blackboard[id] = {};
                    blackboard[id].ticksDone = ticksRequired;
                }
                if (blackboard[id].ticksDone > 0) {
                    blackboard[id].ticksDone--;
                    return Status.RUNNING;
                }
                else {
                    effect();
                    return terminateAndReturn(id, blackboard, Status.SUCCESS);
                }
            }
            else {
                return Status.FAILURE;
            }
        };
    };
}
function getGuardTick() {
    return (precondition, astTick, negate = false) => {
        return () => {
            let proceed = negate ? !precondition() : precondition();
            return proceed ? execute(astTick) : Status.FAILURE;
        };
    };
}
function getSequenceTick(id) {
    return (astTicks) => {
        return () => {
            if (!blackboard[id]) {
                blackboard[id] = {};
                blackboard[id].currentIndex = 0;
            }
            while (blackboard[id].currentIndex < astTicks.length) {
                var childStatus = execute(astTicks[blackboard[id].currentIndex]);
                if (childStatus == Status.RUNNING)
                    return Status.RUNNING;
                else if (childStatus == Status.FAILURE)
                    return terminateAndReturn(id, blackboard, Status.FAILURE);
                else if (childStatus == Status.SUCCESS)
                    blackboard[id].currentIndex += 1;
            }
            return terminateAndReturn(id, blackboard, Status.SUCCESS);
        };
    };
}
function getSelectorTick(id) {
    return (astTicks) => {
        return () => {
            if (!blackboard[id]) {
                blackboard[id] = {};
                blackboard[id].currentIndex = 0;
            }
            while (blackboard[id].currentIndex < astTicks.length) {
                var childStatus = execute(astTicks[blackboard[id].currentIndex]);
                if (childStatus == Status.RUNNING)
                    return Status.RUNNING;
                else if (childStatus == Status.SUCCESS)
                    return terminateAndReturn(id, blackboard, Status.SUCCESS);
                else if (childStatus == Status.FAILURE)
                    blackboard[id].currentIndex += 1;
            }
            return terminateAndReturn(id, blackboard, Status.FAILURE);
        };
    };
}
function execute(astTick) {
    return astTick();
}
exports.execute = execute;
var globalIdCounter = 0;
function action(precondition, effect, ticksRequired) {
    return getActionTick(globalIdCounter++)(precondition, effect, ticksRequired);
}
exports.action = action;
function guard(precondition, astTick) {
    return getGuardTick()(precondition, astTick);
}
exports.guard = guard;
function neg_guard(precondition, astTick) {
    return getGuardTick()(precondition, astTick, true);
}
exports.neg_guard = neg_guard;
/**
 * Cycles over its children: iterates to the next child on success of a child
 * Succeeds if all succeed, else fails
 * @param {Tick[]} astTicks
 * @returns {Tick}
 */
function sequence(astTicks) {
    return getSequenceTick(globalIdCounter++)(astTicks);
}
exports.sequence = sequence;
/**
 * Cycles over its children: iterates to the next child on failure of a child(think of it as if-else blocks)
 * Succeeds if even one succeeds, else fails
 * @param {Tick[]} astTicks
 * @returns {Tick}
 */
function selector(astTicks) {
    return getSelectorTick(globalIdCounter++)(astTicks);
}
exports.selector = selector;
/*--------------- APIs --------------- */
//0. utilities
// min and max are inclusive
function getRandNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
exports.getRandNumber = getRandNumber;
//1. story instance
//1.1 locations
exports.locationGraph = {};
//add to both sides
function addLocation(locationName, adjacentLocations) {
    if (exports.locationGraph[locationName] == undefined) {
        exports.locationGraph[locationName] = [];
    }
    exports.locationGraph[locationName] = exports.locationGraph[locationName].concat(adjacentLocations);
    for (var i = 0; i < adjacentLocations.length; i++) {
        if (exports.locationGraph[adjacentLocations[i]] == undefined) {
            exports.locationGraph[adjacentLocations[i]] = [];
        }
        exports.locationGraph[adjacentLocations[i]].push(locationName);
    }
}
exports.addLocation = addLocation;
function areAdjacent(location1, location2) {
    console.log("Are adjacent: " + location1 + ", " + location2);
    if (exports.locationGraph[location1] == undefined || exports.locationGraph[location2] == undefined) {
        console.log("Either one/both locations undefined");
        return false;
    }
    for (var i = 0; i < exports.locationGraph[location1].length; i++) {
        if (exports.locationGraph[location1][i] == location2) {
            return true;
        }
    }
    return false;
}
exports.areAdjacent = areAdjacent;
//pathfinding primitives
function getNextLocation(start, destination) {
    var visited = {};
    var previous = {};
    for (var key in exports.locationGraph) {
        visited[key] = false;
    }
    visited[start] = true;
    var myQueue = new Queue_1.default();
    myQueue.enqueue(start);
    while (!myQueue.isEmpty()) {
        var current = myQueue.dequeue();
        if (current === destination) {
            break;
        }
        var neighbors = exports.locationGraph[current];
        for (var i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                myQueue.enqueue(neighbors[i]);
                visited[neighbors[i]] = true;
                previous[neighbors[i]] = current;
            }
        }
    }
    var current = destination;
    if (current == start)
        return current;
    while (previous[current] != start) {
        current = previous[current];
    }
    return current;
}
exports.getNextLocation = getNextLocation;
//1.2 agents
var agents = [];
function addAgent(agentName) {
    agents.push(agentName);
    return agentName;
}
exports.addAgent = addAgent;
//1.3 items
var items = [];
function addItem(itemName) {
    items.push(itemName);
    return itemName;
}
exports.addItem = addItem;
//1.4 variables
var variables = {};
var agentVariables = {};
var itemVariables = {};
function setVariable(varName, value) {
    variables[varName] = value;
    return varName;
}
exports.setVariable = setVariable;
function setAgentVariable(agent, varName, value) {
    if (util_1.isUndefined(agentVariables[agent]))
        agentVariables[agent] = {};
    agentVariables[agent][varName] = value;
    return value;
}
exports.setAgentVariable = setAgentVariable;
function getVariable(varName) {
    if (util_1.isUndefined(variables[varName])) {
        console.log("Variable " + varName + " not set!");
        return;
    }
    return variables[varName];
}
exports.getVariable = getVariable;
function getAgentVariable(agent, varName) {
    if (util_1.isUndefined(agentVariables[agent]) || util_1.isUndefined(agentVariables[agent][varName])) {
        console.log("Variable " + varName + " for agent " + agent + " not set!");
        return;
    }
    return agentVariables[agent][varName];
}
exports.getAgentVariable = getAgentVariable;
function isVariableNotSet(varName) {
    return util_1.isUndefined(variables[varName]);
}
exports.isVariableNotSet = isVariableNotSet;
function isAgentVariableNotSet(agent, varName) {
    return util_1.isUndefined(agentVariables[agent]) || util_1.isUndefined(agentVariables[agent][varName]);
}
exports.isAgentVariableNotSet = isAgentVariableNotSet;
function setItemVariable(item, varName, value) {
    if (util_1.isUndefined(itemVariables[item]))
        itemVariables[item] = {};
    itemVariables[item][varName] = value;
    return value;
}
exports.setItemVariable = setItemVariable;
function getItemVariable(item, varName) {
    if (util_1.isUndefined(itemVariables[item]) || util_1.isUndefined(itemVariables[item][varName])) {
        console.log("Variable " + varName + " for item " + item + " not set!");
        return;
    }
    return itemVariables[item][varName];
}
exports.getItemVariable = getItemVariable;
//2
//agent-behavior tree mapping
var agentTrees = {};
function attachTreeToAgent(agent, tree) {
    agentTrees[agent] = tree;
}
exports.attachTreeToAgent = attachTreeToAgent;
//3.1
//user actions
//TODO add variables to user action texts
var userInteractionObject = {
    text: "",
    userActionsText: [],
    actionEffectsText: ""
};
var userInteractionTrees = [];
var userActions = {};
function runUserInteractionTrees() {
    userInteractionObject.text = "";
    userInteractionObject.userActionsText = [];
    userActions = {}; //{"Go to location X" : effect
    for (var i = 0; i < userInteractionTrees.length; i++) {
        execute(userInteractionTrees[i]);
    }
}
exports.displayDescriptionAction = (text) => action(() => true, () => userInteractionObject.text += "\n" + text, 0);
exports.displayActionEffectText = (text) => userInteractionObject.actionEffectsText += "\n" + text;
exports.addUserActionTree = (text, effectTree) => action(() => true, () => mapUserActionToTree(text, effectTree), 0);
exports.addUserAction = (text, effect) => action(() => true, () => mapUserActionToTree(text, action(() => true, effect, 0)), 0);
function mapUserActionToTree(text, tree) {
    userActions[text] = tree;
    userInteractionObject.userActionsText.push(text);
}
function addUserInteractionTree(tick) {
    userInteractionTrees.push(tick);
}
exports.addUserInteractionTree = addUserInteractionTree;
function executeUserAction(text) {
    //execute the user action
    userInteractionObject.actionEffectsText = "";
    var userActionEffectTree = userActions[text];
    execute(userActionEffectTree);
}
exports.executeUserAction = executeUserAction;
//4.
function initialize() {
    runUserInteractionTrees();
}
exports.initialize = initialize;
function getUserInteractionObject() {
    return userInteractionObject;
}
exports.getUserInteractionObject = getUserInteractionObject;
function worldTick() {
    //all agent ticks
    for (var i = 0; i < agents.length; i++) {
        var tree = agentTrees[agents[i]];
        if (!util_1.isUndefined(tree)) {
            setVariable("executingAgent", agents[i]);
            execute(tree);
        }
    }
    runUserInteractionTrees();
}
exports.worldTick = worldTick;

},{"sigma":6,"sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap":7,"sigma/plugins/sigma.plugins.animate/sigma.plugins.animate":8,"sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes":9,"typescript-collections/dist/lib/Queue":11,"typescript-collections/dist/lib/util":13}],15:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/* /// <reference path="scripting.ts"/> */
const scripting_1 = require("./scripting");
const util_1 = require("typescript-collections/dist/lib/util");
let sigma = require('linkurious');
window.sigma = sigma;
require('linkurious/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes');
require('linkurious/plugins/sigma.plugins.animate/sigma.plugins.animate');
require('linkurious/plugins/sigma.layouts.noverlap/sigma.layouts.noverlap');
require('linkurious/plugins/sigma.renderers.linkurious/canvas/sigma.canvas.nodes.def');
var filePrefix = "../data/university/";
var fileSuffix = ".csv";
let files = ["cfgGramma", "Prefix"];
class cfgTrees {
    constructor(name, rule, prefix, prevName) {
        var cleanName;
        this.branches = null;
        this.idLabel = {};
        if (name.startsWith('#')) {
            this.branches = [];
            if (name.endsWith('*')) {
                cleanName = name.substring(1, name.length - 1);
                this.val = cleanName;
                this.idLabel[this.val] = cleanName;
            }
            else if (name.endsWith('$')) {
                cleanName = name.substring(1, name.length - 1);
                this.val = prevName + " " + cleanName;
                this.idLabel[this.val] = cleanName;
            }
            else {
                cleanName = name.substring(1, name.length);
                this.val = retRand(prefix) + " " + cleanName;
                this.idLabel[this.val] = this.val;
            }
            var children = rule[cleanName];
            for (let value of children) {
                var newBranch = new cfgTrees(value, rule, prefix, this.val);
                combine(this.idLabel, newBranch.idLabel);
                this.branches.push(newBranch);
            }
        }
        else if (name.endsWith('*')) {
            cleanName = name.substring(0, name.length - 1);
            this.val = cleanName;
            this.idLabel[this.val] = cleanName;
        }
        else if (name.endsWith('$')) {
            cleanName = name.substring(0, name.length - 1);
            this.val = prevName + " " + cleanName;
            this.idLabel[this.val] = cleanName;
        }
        else {
            cleanName = name;
            this.val = retRand(prefix) + " " + cleanName;
            this.idLabel[this.val] = this.val;
        }
    }
    getValue() {
        return this.val;
    }
    getBranches() {
        return this.branches;
    }
    isLeaf() {
        return (this.branches == null);
    }
    getIdLabelPair() {
        return this.idLabel;
    }
    getBranchValues() {
        let ret = [];
        if (this.branches != null) {
            for (let value of this.branches) {
                ret.push(value.val);
            }
        }
        return ret;
    }
    getExpandList() {
        let expandList = {};
        if (this.branches != null) {
            expandList[this.val] = this.getBranchValues();
            for (let tree of this.branches) {
                combine(expandList, tree.getExpandList());
            }
        }
        return expandList;
    }
    getPrevnameList() {
        let PrevnameList = {};
        for (var name of this.getBranchValues()) {
            PrevnameList[name] = this.val;
        }
        if (this.branches != null) {
            for (let tree of this.branches) {
                combine(PrevnameList, tree.getPrevnameList());
            }
        }
        return PrevnameList;
    }
    getExpandGraph() {
        let expandList = this.getExpandList();
        let expandGraph = {};
        for (var keys of Object.keys(expandList)) {
            expandGraph[keys] = connectNodes(expandList[keys]);
        }
        return expandGraph;
    }
    //This method ignores the first value of the tree
    getAllValues() {
        var ret = [];
        ret = ret.concat(this.getBranchValues());
        if (this.branches != null) {
            for (let tree of this.branches) {
                ret = ret.concat(tree.getBranchValues());
            }
        }
        return ret;
    }
    print() {
        if (this.branches != null) {
            console.log(this.branches);
            for (let value of this.branches) {
                value.print();
            }
        }
    }
}
function combine(dict1, dict2) {
    for (var val of Object.keys(dict2)) {
        dict1[val] = dict2[val];
    }
    return dict1;
}
function retRand(list) {
    var index = scripting_1.getRandNumber(0, list.length - 1);
    var ret = list[index];
    list.splice(index, 1);
    return ret;
}
function readFiles() {
    return __awaiter(this, void 0, void 0, function* () {
        let data = {};
        for (var file of files) {
            let value = yield new Promise(function (resolve, reject) {
                var req = new XMLHttpRequest();
                req.onreadystatechange = function () {
                    if (this.readyState == 4) {
                        if (this.status == 200) {
                            var lines = this.responseText.split(/\n|\r\n/);
                            data[file] = lines;
                            resolve(lines);
                        }
                        else {
                            reject(Error(req.statusText));
                        }
                    }
                };
                req.open("GET", filePrefix + file + fileSuffix, true);
                req.responseType = "text";
                req.send(null);
            });
        }
        return Promise.resolve(data);
    });
}
readFiles().then(function (value) {
    var tree = processData(value);
    InitializeVilillane(tree);
});
function processData(data) {
    let Prefix = data['Prefix'];
    let newRule = {};
    let rawRule = data['cfgGramma'];
    for (let i = 0; i < rawRule.length; i++) {
        let rows = rawRule[i].split(',');
        var children = rows[1].split(';');
        var result = [];
        for (let j = 0; j < children.length; j++) {
            let elements = children[j].split('.');
            let num = scripting_1.getRandNumber(Number(elements[1]), Number(elements[2]));
            for (let k = 0; k < num; k++) {
                result.push(elements[0]);
            }
        }
        newRule[rows[0]] = result;
    }
    let newTree = new cfgTrees('#University', newRule, Prefix, '');
    return newTree;
}
function connectNodes(location) {
    let nodes = {};
    let visited = {};
    for (let i = 0; i < location.length; i++) {
        visited[location[i]] = false;
    }
    let stack = [];
    let rest = [];
    //randomly generate a graph
    for (let i = 0; i < location.length; i++) {
        if (util_1.isUndefined(nodes[location[i]])) {
            nodes[location[i]] = [];
        }
        for (let j = i + 1; j < location.length; j++) {
            if (util_1.isUndefined(nodes[location[j]])) {
                nodes[location[j]] = [];
            }
            if (Math.random() < (2 / location.length)) {
                nodes[location[i]].push(location[j]);
            }
        }
    }
    //making sure it is connected
    for (let i = 0; i < location.length; i++) {
        if (visited[location[i]] == false) {
            let item = location[i];
            stack.push(location[i]);
            while (stack.length > 0) {
                var cur = stack.pop();
                if (cur !== undefined) {
                    if (visited[cur] == false) {
                        visited[cur] = true;
                        if (Math.random() < 0.3) {
                            item = cur;
                        }
                        for (let val of nodes[cur]) {
                            stack.push(val);
                        }
                    }
                }
            }
            rest.push(item);
        }
    }
    for (let i = 0; i < rest.length - 1; i++) {
        nodes[rest[i]].push(rest[i + 1]);
    }
    return nodes;
}
function InitializeVilillane(Tree) {
    var expandGraph = Tree.getExpandGraph();
    var expandList = Tree.getExpandList();
    var idLabelPair = Tree.getIdLabelPair();
    var PrevnameList = Tree.getPrevnameList();
    var bool = {};
    for (var val of Tree.getAllValues()) {
        bool[val] = false;
    }
    //Add locations to villanelle
    function addLocationGraph(graph) {
        for (var key in graph) {
            if (key !== Tree.getValue()) {
                scripting_1.addLocation(key, graph[key]);
            }
        }
    }
    addLocationGraph(expandList);
    for (var key in expandGraph) {
        addLocationGraph(expandGraph[key]);
    }
    var locations = Object.keys(scripting_1.locationGraph);
    // agents
    var alien = scripting_1.addAgent("Alien");
    // items
    var crewCard1 = scripting_1.addItem("Crew card1");
    var crewCard2 = scripting_1.addItem("Crew card2");
    scripting_1.setItemVariable(crewCard1, "currentLocation", retRand(locations));
    scripting_1.setItemVariable(crewCard2, "currentLocation", retRand(locations));
    // variables
    //alien
    scripting_1.setAgentVariable(alien, "currentLocation", retRand(locations));
    //player
    var playerLocation = scripting_1.setVariable("playerLocation", retRand(locations));
    var crewCardsCollected = scripting_1.setVariable("crewCardsCollected", 0);
    console.log(scripting_1.getVariable(playerLocation));
    // 2. Define BTs
    // create ground actions
    //Recover location array
    locations = Object.keys(scripting_1.locationGraph);
    let setRandNumber = scripting_1.action(() => true, () => {
        scripting_1.setVariable("randNumber", scripting_1.getRandNumber(1, locations.length));
    }, 0);
    var BTlist = [];
    let id = 0;
    for (let i = 0; i < locations.length; i++) {
        //console.log(locations[i]);
        let actions = scripting_1.action(() => scripting_1.getVariable("randNumber") == i + 1, () => scripting_1.setVariable("destination", locations[i]), 0);
        BTlist.push(actions);
    }
    let atDestination = () => scripting_1.getVariable("destination") == scripting_1.getAgentVariable(alien, "currentLocation");
    let setDestinationPrecond = () => scripting_1.isVariableNotSet("destination") || atDestination();
    // create behavior trees
    let setNextDestination = scripting_1.sequence([
        setRandNumber,
        scripting_1.selector(BTlist),
    ]);
    let gotoNextLocation = scripting_1.action(() => true, () => {
        scripting_1.setAgentVariable(alien, "currentLocation", scripting_1.getNextLocation(scripting_1.getAgentVariable(alien, "currentLocation"), scripting_1.getVariable("destination")));
        console.log("Alien is at: " + scripting_1.getAgentVariable(alien, "currentLocation"));
    }, 0);
    let eatPlayer = scripting_1.action(() => scripting_1.getAgentVariable(alien, "currentLocation") == scripting_1.getVariable(playerLocation), () => {
        scripting_1.setVariable("endGame", "lose");
        scripting_1.setVariable(playerLocation, "NA");
    }, 0);
    let search = scripting_1.sequence([
        scripting_1.selector([
            scripting_1.guard(setDestinationPrecond, setNextDestination),
            scripting_1.action(() => true, () => {
            }, 0)
        ]),
        gotoNextLocation,
    ]);
    let alienBT = scripting_1.selector([
        eatPlayer,
        scripting_1.sequence([
            search, eatPlayer
        ])
    ]);
    //attach behaviour trees to agents
    scripting_1.attachTreeToAgent(alien, alienBT);
    // 3. Construct story
    // create user actions
    for (let key in scripting_1.locationGraph) {
        let seq = [];
        seq.push(scripting_1.displayDescriptionAction("You enter the " + idLabelPair[key] + "."));
        seq.push(scripting_1.addUserAction("Stay where you are.", () => {
        }));
        if (Object.keys(scripting_1.locationGraph).includes(PrevnameList[key])) {
            seq.push(scripting_1.addUserAction("Go outside to " + idLabelPair[PrevnameList[key]] + ".", () => {
                scripting_1.setVariable(playerLocation, PrevnameList[key]);
            }));
        }
        if (Object.keys(expandList).includes(key)) {
            seq.push(scripting_1.addUserAction("Go inside " + idLabelPair[key] + " to enter " + idLabelPair[expandList[key][0]] + ".", () => scripting_1.setVariable(playerLocation, expandList[key][0])));
        }
        var graph = completeGraph(expandGraph[PrevnameList[key]]);
        for (let adj of graph[key]) {
            seq.push(scripting_1.addUserAction("Enter the " + idLabelPair[adj] + ".", () => scripting_1.setVariable(playerLocation, adj)));
        }
        var StateBT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == key, scripting_1.sequence(seq));
        scripting_1.addUserInteractionTree(StateBT);
    }
    var crewCard1BT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == scripting_1.getItemVariable(crewCard1, "currentLocation"), scripting_1.sequence([
        scripting_1.displayDescriptionAction("You notice a crew card lying around."),
        scripting_1.addUserActionTree("Pick up the crew card", scripting_1.sequence([
            scripting_1.action(() => true, () => {
                scripting_1.displayActionEffectText("You pick up the crew card.");
                scripting_1.setItemVariable(crewCard1, "currentLocation", "player");
                scripting_1.setVariable(crewCardsCollected, scripting_1.getVariable(crewCardsCollected) + 1);
            }, 0),
            scripting_1.action(() => true, () => {
                scripting_1.displayActionEffectText("Wow you know how to pick up things.");
            }, 0)
        ]))
    ]));
    var crewCard2BT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == scripting_1.getItemVariable(crewCard2, "currentLocation"), scripting_1.sequence([
        scripting_1.displayDescriptionAction("You notice a crew card lying around."),
        scripting_1.addUserAction("Pick up the crew card", () => {
            scripting_1.displayActionEffectText("You pick up the crew card.");
            scripting_1.setItemVariable(crewCard2, "currentLocation", "player");
            scripting_1.setVariable(crewCardsCollected, scripting_1.getVariable(crewCardsCollected) + 1);
        })
    ]));
    var ExitBT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == "Exit", scripting_1.selector([
        scripting_1.guard(() => scripting_1.getVariable(crewCardsCollected) >= 2, scripting_1.sequence([
            scripting_1.displayDescriptionAction("You can now activate the exit and flee!"),
            scripting_1.addUserAction("Activate and get out!", () => {
                scripting_1.setVariable("endGame", "win");
                scripting_1.setVariable(playerLocation, "NA");
            })
        ])),
        scripting_1.displayDescriptionAction("You need 2 crew cards to activate the exit elevator system.")
    ]));
    scripting_1.addUserInteractionTree(crewCard1BT);
    scripting_1.addUserInteractionTree(crewCard2BT);
    scripting_1.addUserInteractionTree(ExitBT);
    var alienNearby = scripting_1.guard(() => scripting_1.areAdjacent(scripting_1.getVariable(playerLocation), scripting_1.getAgentVariable(alien, "currentLocation")), scripting_1.displayDescriptionAction("You hear a thumping sound. The alien is nearby."));
    scripting_1.addUserInteractionTree(alienNearby);
    var gameOver = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == "NA", scripting_1.selector([
        scripting_1.guard(() => scripting_1.getVariable("endGame") == "win", scripting_1.displayDescriptionAction("You have managed to escape!")),
        scripting_1.guard(() => scripting_1.getVariable("endGame") == "lose", scripting_1.displayDescriptionAction("The creature grabs you before you can react! You struggle for a bit before realising it's all over.."))
    ]));
    scripting_1.addUserInteractionTree(gameOver);
    //Initialize sigma
    var sigmaInstance = new sigma({
        graph: {
            nodes: [],
            edges: []
        },
        renderer: {
            type: 'canvas',
            container: 'graph-container'
        },
        settings: {
            nodeBorderSize: 5,
            defaultNodeBorderColor: '#fff',
            defaultNodeHoverBorderColor: '#fff',
            defaultNodeColor: '#000',
            defaultLabelColor: '#fff',
            defaultEdgeColor: '#fff',
            edgeColor: 'default',
            maxNodeSize: 20,
            sideMargin: 15
        }
    });
    var edgeID = 0;
    function clear() {
        var nodes = sigmaInstance.graph.nodes();
        for (var node of nodes) {
            sigmaInstance.graph.dropNode(node.id);
        }
    }
    function completeGraph(graph) {
        var retGraph = {};
        for (var key in graph) {
            if (util_1.isUndefined(retGraph[key])) {
                retGraph[key] = [];
            }
            retGraph[key] = retGraph[key].concat(graph[key]);
            for (var loc of graph[key]) {
                if (util_1.isUndefined(retGraph[loc])) {
                    retGraph[loc] = [];
                }
                retGraph[loc].push(key);
            }
        }
        return retGraph;
    }
    function showAround(input) {
        var graph = completeGraph(expandGraph[PrevnameList[input]]);
        var adjacent = graph[input];
        var numberLayer = adjacent.length;
        if (util_1.isUndefined(sigmaInstance.graph.nodes(input))) {
            sigmaInstance.graph.addNode({
                // Main attributes:
                id: input,
                label: idLabelPair[input],
                x: 0,
                y: 0,
                size: 15,
                borderColor: '#fff'
            });
        }
        for (var i = 0; i < numberLayer; i++) {
            if (util_1.isUndefined(sigmaInstance.graph.nodes(adjacent[i]))) {
                sigmaInstance.graph.addNode({
                    // Main attributes:
                    id: adjacent[i],
                    label: idLabelPair[adjacent[i]],
                    x: Math.cos(Math.PI * 2 * (i - 1 / 3) / numberLayer) * 40 + sigmaInstance.graph.nodes(input).x,
                    y: Math.sin(Math.PI * 2 * (i - 1 / 3) / numberLayer) * 40 + sigmaInstance.graph.nodes(input).y,
                    size: 15,
                    borderColor: '#fff'
                });
            }
            sigmaInstance.graph.addEdge({
                id: 'edge' + (edgeID++).toString(),
                source: adjacent[i],
                target: sigmaInstance.graph.nodes(input).id,
                size: 1,
                color: "#fff"
            });
        }
    }
    function show(inputid) {
        var graph = completeGraph(expandGraph[PrevnameList[inputid]]);
        var adjacent = graph[inputid];
        var numberLayer = adjacent.length;
        showAround(inputid);
        if (Object.keys(graph).length < 10) {
            for (var layer1 of adjacent) {
                showAround(layer1);
                let newAdjacent = graph[layer1];
                for (var layer2 of newAdjacent) {
                    showAround((layer2));
                }
            }
        }
    }
    var dragListener = sigma.plugins.dragNodes(sigmaInstance, sigmaInstance.renderers[0]);
    dragListener.bind('startdrag', function (event) {
        console.log(event);
    });
    dragListener.bind('drag', function (event) {
        console.log(event);
    });
    dragListener.bind('drop', function (event) {
        console.log(event);
    });
    dragListener.bind('dragend', function (event) {
        console.log(event);
    });
    //4. Run the world
    scripting_1.initialize();
    var userInteractionObject = scripting_1.getUserInteractionObject();
    //RENDERING-----
    //var displayPanel = {x: 500, y: 0};
    var textPanel = { x: 400, y: 350 };
    var actionsPanel = { x: 420, y: 375 };
    function render() {
        let alienLocation = scripting_1.getAgentVariable(alien, "currentLocation");
        let playerL = scripting_1.getVariable(playerLocation);
        if (Object.keys(scripting_1.locationGraph).includes(playerL)) {
            clear();
            show(playerL);
        }
        for (var node of sigmaInstance.graph.nodes()) {
            if (node.id == alienLocation) {
                node.image = { url: '../images/xenomorph.png' };
                ;
            }
            if (node.id == playerL) {
                node.image = { url: '../images/player2.png' };
            }
        }
        sigmaInstance.refresh();
        var config = {
            nodeMargin: 50,
            gridSize: 5,
        };
        //Configure the algorithm
        var listener = sigmaInstance.configNoverlap(config);
        //Bind all events:
        listener.bind('start stop interpolate', function (event) {
            console.log(event.type);
        });
        //Start the algorithm:
        sigmaInstance.startNoverlap();
        //sigmaInstance.startForceAtlas2();
        displayTextAndActions();
    }
    var canvas = document.getElementById('display');
    var context = canvas.getContext('2d');
    var currentSelection;
    var yOffset = actionsPanel.y + 25;
    var yOffsetIncrement = 50;
    function displayTextAndActions() {
        context.clearRect(textPanel.x, textPanel.y, 1000, 1000);
        yOffset = actionsPanel.y + 25;
        context.font = "15pt Calibri";
        context.fillStyle = 'white';
        console.log("Actions effect text: " + userInteractionObject.actionEffectsText);
        var textToDisplay = userInteractionObject.actionEffectsText.length != 0 ? userInteractionObject.actionEffectsText : userInteractionObject.text;
        context.fillText(textToDisplay, textPanel.x, textPanel.y + 20);
        context.font = "15pt Calibri";
        context.fillStyle = 'white';
        for (var i = 0; i < userInteractionObject.userActionsText.length; i++) {
            var userActionText = userInteractionObject.userActionsText[i];
            context.fillText(userActionText, actionsPanel.x + 20, yOffset);
            if (i == 0) {
                currentSelection = i;
            }
            yOffset += yOffsetIncrement;
        }
        displayArrow();
        console.log("Crew cards: " + scripting_1.getVariable(crewCardsCollected));
    }
    function displayArrow() {
        if (userInteractionObject.userActionsText.length != 0) {
            context.clearRect(actionsPanel.x, actionsPanel.y, 20, 1000);
            context.fillText("> ", 420, actionsPanel.y + 25 + (currentSelection * yOffsetIncrement));
        }
    }
    //User input
    function keyPress(e) {
        if (e.keyCode == 13) {
            var selectedAction = userInteractionObject.userActionsText[currentSelection];
            if (!util_1.isUndefined(selectedAction)) {
                scripting_1.executeUserAction(selectedAction);
                scripting_1.worldTick();
                render();
            }
        }
    }
    function keyDown(e) {
        if (e.keyCode == 40) { //down
            if (userInteractionObject.userActionsText.length != 0) {
                currentSelection++;
                currentSelection = currentSelection % userInteractionObject.userActionsText.length;
                displayArrow();
            }
        }
        else if (e.keyCode == 38) { //up
            if (userInteractionObject.userActionsText.length != 0) {
                currentSelection--;
                if (currentSelection < 0)
                    currentSelection = userInteractionObject.userActionsText.length - 1;
                displayArrow();
            }
        }
    }
    render();
    document.addEventListener("keypress", keyPress, false);
    document.addEventListener("keydown", keyDown, false);
}

},{"./scripting":14,"linkurious":1,"linkurious/plugins/sigma.layouts.noverlap/sigma.layouts.noverlap":2,"linkurious/plugins/sigma.plugins.animate/sigma.plugins.animate":3,"linkurious/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes":4,"linkurious/plugins/sigma.renderers.linkurious/canvas/sigma.canvas.nodes.def":5,"typescript-collections/dist/lib/util":13}]},{},[15])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvbGlua3VyaW91cy9kaXN0L3NpZ21hLnJlcXVpcmUuanMiLCJub2RlX21vZHVsZXMvbGlua3VyaW91cy9wbHVnaW5zL3NpZ21hLmxheW91dHMubm92ZXJsYXAvc2lnbWEubGF5b3V0cy5ub3ZlcmxhcC5qcyIsIm5vZGVfbW9kdWxlcy9saW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5hbmltYXRlL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9saW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMuanMiLCJub2RlX21vZHVsZXMvbGlua3VyaW91cy9wbHVnaW5zL3NpZ21hLnJlbmRlcmVycy5saW5rdXJpb3VzL2NhbnZhcy9zaWdtYS5jYW52YXMubm9kZXMuZGVmLmpzIiwibm9kZV9tb2R1bGVzL3NpZ21hL2J1aWxkL3NpZ21hLnJlcXVpcmUuanMiLCJub2RlX21vZHVsZXMvc2lnbWEvcGx1Z2lucy9zaWdtYS5sYXlvdXQubm92ZXJsYXAvc2lnbWEubGF5b3V0Lm5vdmVybGFwLmpzIiwibm9kZV9tb2R1bGVzL3NpZ21hL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5hbmltYXRlL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvTGlua2VkTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWNvbGxlY3Rpb25zL2Rpc3QvbGliL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvYXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvdXRpbC5qcyIsInNyYy9zY3JpcHRpbmcudHMiLCJzcmMvdW5pdmVyc2l0eUxheWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDhYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1eVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1SUEsaUVBQTBEO0FBQzFELCtEQUFpRTtBQUNqRSxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkIsTUFBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDNUIsT0FBTyxDQUFDLCtEQUErRCxDQUFDLENBQUM7QUFDekUsT0FBTyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7QUFDckUsT0FBTyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7QUFFckUsSUFBWSxNQUlYO0FBSkQsV0FBWSxNQUFNO0lBQ2QseUNBQU8sQ0FBQTtJQUNQLHlDQUFPLENBQUE7SUFDUCx5Q0FBTyxDQUFBO0FBQ1gsQ0FBQyxFQUpXLE1BQU0sR0FBTixjQUFNLEtBQU4sY0FBTSxRQUlqQjtBQUVELDRCQUE0QixFQUFVLEVBQUUsVUFBZSxFQUFFLE1BQWM7SUFDbkUsT0FBTyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdEIsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQWVELElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUVwQix1QkFBdUIsRUFBVTtJQUM3QixPQUFPLENBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRSxhQUFhLEdBQUcsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsT0FBTyxHQUFHLEVBQUU7WUFDUixJQUFJLFlBQVksRUFBRSxFQUFFO2dCQUNoQixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUNqQixVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNwQixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQztpQkFDNUM7Z0JBRUQsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRTtvQkFDOUIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO29CQUMzQixPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUM7aUJBQ3pCO3FCQUFNO29CQUNILE1BQU0sRUFBRSxDQUFDO29CQUNULE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzdEO2FBQ0o7aUJBQU07Z0JBQ0gsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDO2FBQ3pCO1FBQ0wsQ0FBQyxDQUFBO0lBQ0wsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVEO0lBQ0ksT0FBTyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxHQUFHLEtBQUssRUFBRSxFQUFFO1FBQzdDLE9BQU8sR0FBRyxFQUFFO1lBQ1IsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN4RCxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQ3ZELENBQUMsQ0FBQTtJQUNMLENBQUMsQ0FBQTtBQUNMLENBQUM7QUFFRCx5QkFBeUIsRUFBVTtJQUMvQixPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDaEIsT0FBTyxHQUFHLEVBQUU7WUFDUixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO2dCQUNqQixVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNwQixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQzthQUNuQztZQUVELE9BQU8sVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFO2dCQUNsRCxJQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUVqRSxJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsT0FBTztvQkFDN0IsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDO3FCQUNyQixJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsT0FBTztvQkFDbEMsT0FBTyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztxQkFDekQsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQ2xDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO2FBQ3hDO1lBQ0QsT0FBTyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUE7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDO0FBRUQseUJBQXlCLEVBQVU7SUFDL0IsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFO1FBQ2hCLE9BQU8sR0FBRyxFQUFFO1lBQ1IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDakIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDcEIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7YUFDbkM7WUFFRCxPQUFPLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRTtnQkFDbEQsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFFakUsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQzdCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztxQkFDckIsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQ2xDLE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQ3pELElBQUksV0FBVyxJQUFJLE1BQU0sQ0FBQyxPQUFPO29CQUNsQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQzthQUN4QztZQUNELE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFBO0lBQ0wsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVELGlCQUF3QixPQUFhO0lBQ2pDLE9BQU8sT0FBTyxFQUFFLENBQUM7QUFDckIsQ0FBQztBQUZELDBCQUVDO0FBRUQsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBRXhCLGdCQUF1QixZQUEwQixFQUFFLE1BQWMsRUFBRSxhQUFzQjtJQUNyRixPQUFPLGFBQWEsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLFlBQVksRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUE7QUFDaEYsQ0FBQztBQUZELHdCQUVDO0FBRUQsZUFBc0IsWUFBMEIsRUFBRSxPQUFhO0lBQzNELE9BQU8sWUFBWSxFQUFFLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFGRCxzQkFFQztBQUVELG1CQUEwQixZQUEwQixFQUFFLE9BQWE7SUFDL0QsT0FBTyxZQUFZLEVBQUUsQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFGRCw4QkFFQztBQUVEOzs7OztHQUtHO0FBQ0gsa0JBQXlCLFFBQWdCO0lBQ3JDLE9BQU8sZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUZELDRCQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxrQkFBeUIsUUFBZ0I7SUFDckMsT0FBTyxlQUFlLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRkQsNEJBRUM7QUFHRCx5Q0FBeUM7QUFHekMsY0FBYztBQUNkLDRCQUE0QjtBQUM1Qix1QkFBOEIsR0FBVyxFQUFFLEdBQVc7SUFDbEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDN0QsQ0FBQztBQUZELHNDQUVDO0FBRUQsbUJBQW1CO0FBRW5CLGVBQWU7QUFDSixRQUFBLGFBQWEsR0FBRyxFQUFFLENBQUM7QUFFOUIsbUJBQW1CO0FBQ25CLHFCQUE0QixZQUFvQixFQUFFLGlCQUEyQjtJQUN6RSxJQUFJLHFCQUFhLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxFQUFFO1FBQzFDLHFCQUFhLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3BDO0lBQ0QscUJBQWEsQ0FBQyxZQUFZLENBQUMsR0FBRyxxQkFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRXBGLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsSUFBSSxxQkFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxFQUFFO1lBQ2xELHFCQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDNUM7UUFDRCxxQkFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQzFEO0FBQ0wsQ0FBQztBQVpELGtDQVlDO0FBRUQscUJBQTRCLFNBQWlCLEVBQUUsU0FBaUI7SUFDNUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsSUFBSSxHQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzNELElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEVBQUM7UUFDL0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ25ELE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLHFCQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RELElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLEVBQUM7WUFDekMsT0FBTyxJQUFJLENBQUM7U0FDZjtLQUNKO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQWJELGtDQWFDO0FBRUQsd0JBQXdCO0FBQ3hCLHlCQUFnQyxLQUFhLEVBQUUsV0FBbUI7SUFDOUQsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNsQixLQUFLLElBQUksR0FBRyxJQUFJLHFCQUFhLEVBQUU7UUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztLQUN4QjtJQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7SUFFdEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxlQUFLLEVBQVUsQ0FBQztJQUNsQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXZCLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDdkIsSUFBSSxPQUFPLEdBQVcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3hDLElBQUksT0FBTyxLQUFLLFdBQVcsRUFBRTtZQUN6QixNQUFNO1NBQ1Q7UUFDRCxJQUFJLFNBQVMsR0FBRyxxQkFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXZDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3hCLE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7Z0JBQzdCLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7YUFDcEM7U0FDSjtLQUNKO0lBRUQsSUFBSSxPQUFPLEdBQVcsV0FBVyxDQUFDO0lBQ2xDLElBQUksT0FBTyxJQUFJLEtBQUs7UUFDaEIsT0FBTyxPQUFPLENBQUM7SUFDbkIsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxFQUFFO1FBQy9CLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDL0I7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBbkNELDBDQW1DQztBQUVELFlBQVk7QUFDWixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFFaEIsa0JBQXlCLFNBQWlCO0lBQ3RDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkIsT0FBTyxTQUFTLENBQUM7QUFDckIsQ0FBQztBQUhELDRCQUdDO0FBRUQsV0FBVztBQUNYLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUVmLGlCQUF3QixRQUFnQjtJQUNwQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JCLE9BQU8sUUFBUSxDQUFDO0FBQ3BCLENBQUM7QUFIRCwwQkFHQztBQUVELGVBQWU7QUFDZixJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDbkIsSUFBSSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQ3hCLElBQUksYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUV2QixxQkFBNEIsT0FBZSxFQUFFLEtBQVU7SUFDbkQsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMzQixPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBSEQsa0NBR0M7QUFFRCwwQkFBaUMsS0FBYSxFQUFFLE9BQWUsRUFBRSxLQUFVO0lBQ3ZFLElBQUksa0JBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEMsY0FBYyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUUvQixjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3ZDLE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUM7QUFORCw0Q0FNQztBQUVELHFCQUE0QixPQUFlO0lBQ3ZDLElBQUksa0JBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUNqQyxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxPQUFPLEdBQUcsV0FBVyxDQUFDLENBQUM7UUFDakQsT0FBTztLQUNWO0lBQ0QsT0FBTyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDOUIsQ0FBQztBQU5ELGtDQU1DO0FBRUQsMEJBQWlDLEtBQWEsRUFBRSxPQUFlO0lBQzNELElBQUksa0JBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxrQkFBVyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQ25GLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE9BQU8sR0FBRyxhQUFhLEdBQUcsS0FBSyxHQUFHLFdBQVcsQ0FBQyxDQUFBO1FBQ3hFLE9BQU87S0FDVjtJQUNELE9BQU8sY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFORCw0Q0FNQztBQUVELDBCQUFpQyxPQUFlO0lBQzVDLE9BQU8sa0JBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRkQsNENBRUM7QUFFRCwrQkFBc0MsS0FBYSxFQUFFLE9BQWU7SUFDaEUsT0FBTyxrQkFBVyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLGtCQUFXLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDN0YsQ0FBQztBQUZELHNEQUVDO0FBRUQseUJBQWdDLElBQVksRUFBRSxPQUFlLEVBQUUsS0FBVTtJQUNyRSxJQUFJLGtCQUFXLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFFN0IsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNyQyxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDO0FBTkQsMENBTUM7QUFFRCx5QkFBZ0MsSUFBWSxFQUFFLE9BQWU7SUFDekQsSUFBSSxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLGtCQUFXLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDL0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsT0FBTyxHQUFHLFlBQVksR0FBRyxJQUFJLEdBQUcsV0FBVyxDQUFDLENBQUE7UUFDdEUsT0FBTztLQUNWO0lBQ0QsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQU5ELDBDQU1DO0FBR0QsR0FBRztBQUNILDZCQUE2QjtBQUM3QixJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFFcEIsMkJBQWtDLEtBQWEsRUFBRSxJQUFVO0lBQ3ZELFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDN0IsQ0FBQztBQUZELDhDQUVDO0FBRUQsS0FBSztBQUNMLGNBQWM7QUFDZCx5Q0FBeUM7QUFDekMsSUFBSSxxQkFBcUIsR0FBRztJQUN4QixJQUFJLEVBQUUsRUFBRTtJQUNSLGVBQWUsRUFBRSxFQUFFO0lBQ25CLGlCQUFpQixFQUFFLEVBQUU7Q0FDeEIsQ0FBQTtBQUNELElBQUksb0JBQW9CLEdBQUcsRUFBRSxDQUFDO0FBQzlCLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUVyQjtJQUNJLHFCQUFxQixDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDaEMscUJBQXFCLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUMzQyxXQUFXLEdBQUcsRUFBRSxDQUFDLENBQUEsOEJBQThCO0lBQy9DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDbEQsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDcEM7QUFDTCxDQUFDO0FBRVUsUUFBQSx3QkFBd0IsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQ25ELE1BQU0sQ0FDRixHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQ1YsR0FBRyxFQUFFLENBQUMscUJBQXFCLENBQUMsSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUNyRCxDQUFDO0FBQ0ssUUFBQSx1QkFBdUIsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMscUJBQXFCLENBQUMsaUJBQWlCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztBQUVuRyxRQUFBLGlCQUFpQixHQUFHLENBQUMsSUFBWSxFQUFFLFVBQWdCLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FDckUsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUNWLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQ2pELENBQUM7QUFFUyxRQUFBLGFBQWEsR0FBRyxDQUFDLElBQVksRUFBRSxNQUFpQixFQUFFLEVBQUUsQ0FDM0QsTUFBTSxDQUNGLEdBQUcsRUFBRSxDQUFDLElBQUksRUFDVixHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEdBQUUsRUFBRSxDQUFBLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQ2xFLENBQUM7QUFFTiw2QkFBNkIsSUFBWSxFQUFFLElBQVU7SUFDakQsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQztJQUN6QixxQkFBcUIsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3JELENBQUM7QUFFRCxnQ0FBdUMsSUFBVTtJQUM3QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDcEMsQ0FBQztBQUZELHdEQUVDO0FBRUQsMkJBQWtDLElBQVk7SUFDMUMseUJBQXlCO0lBQ3pCLHFCQUFxQixDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztJQUM3QyxJQUFJLG9CQUFvQixHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBTEQsOENBS0M7QUFFRCxJQUFJO0FBQ0o7SUFDSSx1QkFBdUIsRUFBRSxDQUFDO0FBQzlCLENBQUM7QUFGRCxnQ0FFQztBQUVEO0lBQ0ksT0FBTyxxQkFBcUIsQ0FBQztBQUNqQyxDQUFDO0FBRkQsNERBRUM7QUFFRDtJQUNJLGlCQUFpQjtJQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNwQyxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLGtCQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEIsV0FBVyxDQUFDLGdCQUFnQixFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQjtLQUNKO0lBQ0QsdUJBQXVCLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBVkQsOEJBVUM7Ozs7Ozs7Ozs7Ozs7QUNyWUQsMENBQTBDO0FBQzFDLDJDQU1xQjtBQUNyQiwrREFBaUU7QUFFakUsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzVCLE1BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQzVCLE9BQU8sQ0FBQyxvRUFBb0UsQ0FBQyxDQUFDO0FBQzlFLE9BQU8sQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO0FBQzFFLE9BQU8sQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO0FBQzVFLE9BQU8sQ0FBQyw2RUFBNkUsQ0FBQyxDQUFDO0FBSXZGLElBQUksVUFBVSxHQUFHLHFCQUFxQixDQUFDO0FBQ3ZDLElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQTtBQUN2QixJQUFJLEtBQUssR0FBRyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQTtBQUVuQztJQU1JLFlBQVksSUFBWSxFQUFFLElBQVUsRUFBRSxNQUFnQixFQUFFLFFBQWdCO1FBQ3BFLElBQUksU0FBaUIsQ0FBQztRQUN0QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNyQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQTtRQUNqQixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7WUFDbkIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNwQixTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDL0MsSUFBSSxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUM7Z0JBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQzthQUN0QztpQkFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQzNCLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLENBQUMsR0FBRyxHQUFHLFFBQVEsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDO2dCQUN0QyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUM7YUFDdEM7aUJBQU07Z0JBQ0gsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDM0MsSUFBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLFNBQVMsQ0FBQztnQkFDN0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQTthQUNwQztZQUNELElBQUksUUFBUSxHQUFhLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUN6QyxLQUFLLElBQUksS0FBSyxJQUFJLFFBQVEsRUFBRTtnQkFDeEIsSUFBSSxTQUFTLEdBQUcsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUM1RCxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3pDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ2pDO1NBQ0o7YUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDM0IsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0MsSUFBSSxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUM7WUFDckIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO1NBQ3RDO2FBQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyxHQUFHLEdBQUcsUUFBUSxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUM7WUFDdEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO1NBQ3RDO2FBQU07WUFDSCxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUM7WUFDN0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQTtTQUNwQztJQUNMLENBQUM7SUFFRCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ3BCLENBQUM7SUFFRCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxNQUFNO1FBQ0YsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDeEIsQ0FBQztJQUVELGVBQWU7UUFDWCxJQUFJLEdBQUcsR0FBYSxFQUFFLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksRUFBRTtZQUN2QixLQUFLLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQzdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3ZCO1NBQ0o7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRCxhQUFhO1FBQ1QsSUFBSSxVQUFVLEdBQVMsRUFBRSxDQUFDO1FBQzFCLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLEVBQUU7WUFDdkIsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDOUMsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUM1QixPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO2FBQzdDO1NBQ0o7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0lBRUQsZUFBZTtRQUNYLElBQUksWUFBWSxHQUE4QixFQUFFLENBQUM7UUFDakQsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLEVBQUU7WUFDckMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7U0FDakM7UUFDRCxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFO1lBQ3ZCLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDNUIsT0FBTyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQzthQUNqRDtTQUNKO1FBQ0QsT0FBTyxZQUFZLENBQUM7SUFDeEIsQ0FBQztJQUVELGNBQWM7UUFDVixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDdEMsSUFBSSxXQUFXLEdBQTRCLEVBQUUsQ0FBQztRQUM5QyxLQUFLLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDdEMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUN0RDtRQUNELE9BQU8sV0FBVyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxpREFBaUQ7SUFDakQsWUFBWTtRQUNSLElBQUksR0FBRyxHQUFhLEVBQUUsQ0FBQztRQUN2QixHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztRQUN6QyxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFO1lBQ3ZCLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDNUIsR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUE7YUFDM0M7U0FDSjtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVELEtBQUs7UUFDRCxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzNCLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDN0IsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ2pCO1NBQ0o7SUFDTCxDQUFDO0NBRUo7QUFFRCxpQkFBaUIsS0FBNkIsRUFBRSxLQUE2QjtJQUN6RSxLQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDaEMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUMzQjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUM7QUFFRCxpQkFBaUIsSUFBVztJQUN4QixJQUFJLEtBQUssR0FBRyx5QkFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzlDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN0QixPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7QUFFRDs7UUFDSSxJQUFJLElBQUksR0FBUyxFQUFFLENBQUM7UUFFcEIsS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUU7WUFDcEIsSUFBSSxLQUFLLEdBQUcsTUFBTSxJQUFJLE9BQU8sQ0FBQyxVQUFVLE9BQU8sRUFBRSxNQUFNO2dCQUMvQyxJQUFJLEdBQUcsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO2dCQUMvQixHQUFHLENBQUMsa0JBQWtCLEdBQUc7b0JBQ3JCLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLEVBQUU7d0JBQ3RCLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUU7NEJBQ3BCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzRCQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDOzRCQUNuQixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQ2xCOzZCQUFNOzRCQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7eUJBQ2pDO3FCQUNKO2dCQUNMLENBQUMsQ0FBQTtnQkFDRCxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxVQUFVLEdBQUcsSUFBSSxHQUFHLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDdEQsR0FBRyxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUM7Z0JBQzFCLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbkIsQ0FBQyxDQUNKLENBQUM7U0FDTDtRQUVELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqQyxDQUFDO0NBQUE7QUFFRCxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLO0lBQzVCLElBQUksSUFBSSxHQUFhLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQTtBQUVGLHFCQUFxQixJQUFVO0lBQzNCLElBQUksTUFBTSxHQUFhLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN0QyxJQUFJLE9BQU8sR0FBUyxFQUFFLENBQUM7SUFDdkIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2hDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3JDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsQyxJQUFJLE1BQU0sR0FBYSxFQUFFLENBQUM7UUFDMUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDdEMsSUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0QyxJQUFJLEdBQUcsR0FBRyx5QkFBYSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUMxQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzVCO1NBQ0o7UUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO0tBQzdCO0lBQ0QsSUFBSSxPQUFPLEdBQUcsSUFBSSxRQUFRLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDL0QsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQztBQUdELHNCQUFzQixRQUFrQjtJQUNwQyxJQUFJLEtBQUssR0FBUyxFQUFFLENBQUM7SUFDckIsSUFBSSxPQUFPLEdBQStCLEVBQUUsQ0FBQztJQUM3QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN0QyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0tBQ2hDO0lBQ0QsSUFBSSxLQUFLLEdBQWEsRUFBRSxDQUFDO0lBQ3pCLElBQUksSUFBSSxHQUFhLEVBQUUsQ0FBQztJQUV4QiwyQkFBMkI7SUFDM0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsSUFBSSxrQkFBVyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2pDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUE7U0FDMUI7UUFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDMUMsSUFBSSxrQkFBVyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNqQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQzNCO1lBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUN2QyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3hDO1NBQ0o7S0FDSjtJQUNELDZCQUE2QjtJQUM3QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN0QyxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLEVBQUU7WUFDL0IsSUFBSSxJQUFJLEdBQVcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEIsT0FBTyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDckIsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUN0QixJQUFJLEdBQUcsS0FBSyxTQUFTLEVBQUU7b0JBQ25CLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssRUFBRTt3QkFDdkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQzt3QkFDcEIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFOzRCQUNyQixJQUFJLEdBQUcsR0FBRyxDQUFDO3lCQUNkO3dCQUNELEtBQUssSUFBSSxHQUFHLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFOzRCQUN4QixLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3lCQUNuQjtxQkFDSjtpQkFDSjthQUNKO1lBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNuQjtLQUNKO0lBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BDO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUdELDZCQUE2QixJQUFjO0lBQ3ZDLElBQUksV0FBVyxHQUE0QixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDakUsSUFBSSxVQUFVLEdBQVMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQzVDLElBQUksV0FBVyxHQUE4QixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDbkUsSUFBSSxZQUFZLEdBQThCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUNyRSxJQUFJLElBQUksR0FBZ0MsRUFBRSxDQUFDO0lBQzNDLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFO1FBQ2pDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7S0FDckI7SUFFRCw2QkFBNkI7SUFDN0IsMEJBQTBCLEtBQVc7UUFDakMsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7WUFDbkIsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO2dCQUN6Qix1QkFBVyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNoQztTQUNKO0lBQ0wsQ0FBQztJQUVELGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBRTdCLEtBQUssSUFBSSxHQUFHLElBQUksV0FBVyxFQUFFO1FBQ3pCLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3RDO0lBRUQsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyx5QkFBYSxDQUFDLENBQUM7SUFDL0MsU0FBUztJQUNMLElBQUksS0FBSyxHQUFHLG9CQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFbEMsUUFBUTtJQUVKLElBQUksU0FBUyxHQUFHLG1CQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDdEMsSUFBSSxTQUFTLEdBQUcsbUJBQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN0QywyQkFBZSxDQUFDLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUNsRSwyQkFBZSxDQUFDLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUV0RSxZQUFZO0lBRVosT0FBTztJQUVILDRCQUFnQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUVuRSxRQUFRO0lBQ0osSUFBSSxjQUFjLEdBQUcsdUJBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUN2RSxJQUFJLGtCQUFrQixHQUFHLHVCQUFXLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7SUFFN0MsZ0JBQWdCO0lBQ2hCLHdCQUF3QjtJQUVwQix3QkFBd0I7SUFDeEIsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxDQUFDO0lBQ3ZDLElBQUksYUFBYSxHQUFHLGtCQUFNLENBQ3RCLEdBQUcsRUFBRSxDQUFDLElBQUksRUFDVixHQUFHLEVBQUU7UUFDRCx1QkFBVyxDQUFDLFlBQVksRUFBRSx5QkFBYSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDLEVBQ0QsQ0FBQyxDQUNKLENBQUM7SUFFRixJQUFJLE1BQU0sR0FBVyxFQUFFLENBQUM7SUFDeEIsSUFBSSxFQUFFLEdBQVcsQ0FBQyxDQUFDO0lBQ25CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3ZDLDRCQUE0QjtRQUM1QixJQUFJLE9BQU8sR0FBUyxrQkFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLGFBQWEsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN4SCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3hCO0lBQ0QsSUFBSSxhQUFhLEdBQWlCLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsYUFBYSxDQUFDLElBQUksNEJBQWdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDakgsSUFBSSxxQkFBcUIsR0FBaUIsR0FBRyxFQUFFLENBQUMsNEJBQWdCLENBQUMsYUFBYSxDQUFDLElBQUksYUFBYSxFQUFFLENBQUM7SUFFdkcsd0JBQXdCO0lBQ3BCLElBQUksa0JBQWtCLEdBQUcsb0JBQVEsQ0FBQztRQUM5QixhQUFhO1FBQ2Isb0JBQVEsQ0FBQyxNQUFNLENBQUM7S0FDbkIsQ0FBQyxDQUFDO0lBRUgsSUFBSSxnQkFBZ0IsR0FBRyxrQkFBTSxDQUN6QixHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQ1YsR0FBRyxFQUFFO1FBQ0QsNEJBQWdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixFQUFFLDJCQUFlLENBQUMsNEJBQWdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLEVBQUUsdUJBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEksT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLEdBQUcsNEJBQWdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQTtJQUM3RSxDQUFDLEVBQ0QsQ0FBQyxDQUNKLENBQUM7SUFFRixJQUFJLFNBQVMsR0FBRyxrQkFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLDRCQUFnQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxJQUFJLHVCQUFXLENBQUMsY0FBYyxDQUFDLEVBQ2xHLEdBQUcsRUFBRTtRQUNELHVCQUFXLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQy9CLHVCQUFXLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RDLENBQUMsRUFBRSxDQUFDLENBQ1AsQ0FBQztJQUVGLElBQUksTUFBTSxHQUFHLG9CQUFRLENBQUM7UUFDbEIsb0JBQVEsQ0FBQztZQUNMLGlCQUFLLENBQUMscUJBQXFCLEVBQUUsa0JBQWtCLENBQUM7WUFDaEQsa0JBQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFO1lBQ3hCLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDUixDQUFDO1FBQ0YsZ0JBQWdCO0tBQ25CLENBQUMsQ0FBQztJQUVILElBQUksT0FBTyxHQUFHLG9CQUFRLENBQUM7UUFDbkIsU0FBUztRQUNULG9CQUFRLENBQUM7WUFDTCxNQUFNLEVBQUUsU0FBUztTQUNwQixDQUFDO0tBQ0wsQ0FBQyxDQUFDO0lBRVAsa0NBQWtDO0lBQzlCLDZCQUFpQixDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsQyxxQkFBcUI7SUFDckIsc0JBQXNCO0lBQ3RCLEtBQUssSUFBSSxHQUFHLElBQUkseUJBQWEsRUFBRTtRQUMzQixJQUFJLEdBQUcsR0FBVSxFQUFFLENBQUM7UUFDcEIsR0FBRyxDQUFDLElBQUksQ0FBQyxvQ0FBd0IsQ0FBQyxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM5RSxHQUFHLENBQUMsSUFBSSxDQUFDLHlCQUFhLENBQUMscUJBQXFCLEVBQUUsR0FBRyxFQUFFO1FBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDSixJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtZQUN4RCxHQUFHLENBQUMsSUFBSSxDQUFDLHlCQUFhLENBQUMsZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUU7Z0JBQ2pGLHVCQUFXLENBQUMsY0FBYyxFQUFFLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDUDtRQUNELElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdkMsR0FBRyxDQUFDLElBQUksQ0FBQyx5QkFBYSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsWUFBWSxHQUFHLFdBQVcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxjQUFjLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFLO1FBQ0QsSUFBSSxLQUFLLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3pELEtBQUssSUFBSSxHQUFHLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3hCLEdBQUcsQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDMUc7UUFDRCxJQUFJLE9BQU8sR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLElBQUksR0FBRyxFQUN4RCxvQkFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbkIsa0NBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDbkM7SUFHRCxJQUFJLFdBQVcsR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLElBQUksMkJBQWUsQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLENBQUMsRUFDdEcsb0JBQVEsQ0FBQztRQUNELG9DQUF3QixDQUFDLHNDQUFzQyxDQUFDO1FBQ2hFLDZCQUFpQixDQUFDLHVCQUF1QixFQUNyQyxvQkFBUSxDQUFDO1lBQ0wsa0JBQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFO2dCQUNwQixtQ0FBdUIsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO2dCQUN0RCwyQkFBZSxDQUFDLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDeEQsdUJBQVcsQ0FBQyxrQkFBa0IsRUFBRSx1QkFBVyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDekUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNMLGtCQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRTtnQkFDcEIsbUNBQXVCLENBQUMscUNBQXFDLENBQUMsQ0FBQTtZQUNsRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ1IsQ0FBQyxDQUNMO0tBQ0osQ0FDSixDQUFDLENBQUM7SUFFUCxJQUFJLFdBQVcsR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLElBQUksMkJBQWUsQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLENBQUMsRUFDdEcsb0JBQVEsQ0FBQztRQUNELG9DQUF3QixDQUFDLHNDQUFzQyxDQUFDO1FBQ2hFLHlCQUFhLENBQUMsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO1lBQ3hDLG1DQUF1QixDQUFDLDRCQUE0QixDQUFDLENBQUM7WUFDdEQsMkJBQWUsQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDeEQsdUJBQVcsQ0FBQyxrQkFBa0IsRUFBRSx1QkFBVyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDekUsQ0FBQyxDQUFDO0tBQ0wsQ0FDSixDQUFDLENBQUM7SUFFUCxJQUFJLE1BQU0sR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLElBQUksTUFBTSxFQUMxRCxvQkFBUSxDQUFDO1FBQ0wsaUJBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxFQUM1QyxvQkFBUSxDQUFDO1lBQ0wsb0NBQXdCLENBQUMseUNBQXlDLENBQUM7WUFDbkUseUJBQWEsQ0FBQyx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7Z0JBQ3hDLHVCQUFXLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUM5Qix1QkFBVyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQTtZQUNyQyxDQUFDLENBQUM7U0FDTCxDQUFDLENBQUM7UUFDUCxvQ0FBd0IsQ0FBQyw2REFBNkQsQ0FBQztLQUMxRixDQUFDLENBQUMsQ0FBQztJQUVSLGtDQUFzQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BDLGtDQUFzQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BDLGtDQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRS9CLElBQUksV0FBVyxHQUFHLGlCQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyx1QkFBVyxDQUFDLGNBQWMsQ0FBQyxFQUFFLDRCQUFnQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLEVBQzlHLG9DQUF3QixDQUFDLGlEQUFpRCxDQUFDLENBQUMsQ0FBQztJQUNqRixrQ0FBc0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUVwQyxJQUFJLFFBQVEsR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxFQUMxRCxvQkFBUSxDQUFDO1FBQ0QsaUJBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEtBQUssRUFDdkMsb0NBQXdCLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUM1RCxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsU0FBUyxDQUFDLElBQUksTUFBTSxFQUN4QyxvQ0FBd0IsQ0FBQyxzR0FBc0csQ0FBQyxDQUFDO0tBQ3hJLENBQ0osQ0FBQyxDQUFDO0lBQ1Asa0NBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFckMsa0JBQWtCO0lBQ2QsSUFBSSxhQUFhLEdBQUcsSUFBSSxLQUFLLENBQUM7UUFDMUIsS0FBSyxFQUFFO1lBQ0gsS0FBSyxFQUFFLEVBQUU7WUFDVCxLQUFLLEVBQUUsRUFBRTtTQUNaO1FBQ0QsUUFBUSxFQUFFO1lBQ04sSUFBSSxFQUFFLFFBQVE7WUFDZCxTQUFTLEVBQUUsaUJBQWlCO1NBQy9CO1FBQ0QsUUFBUSxFQUFFO1lBQ04sY0FBYyxFQUFFLENBQUM7WUFDakIsc0JBQXNCLEVBQUUsTUFBTTtZQUM5QiwyQkFBMkIsRUFBRSxNQUFNO1lBQ25DLGdCQUFnQixFQUFFLE1BQU07WUFDeEIsaUJBQWlCLEVBQUUsTUFBTTtZQUN6QixnQkFBZ0IsRUFBRSxNQUFNO1lBQ3hCLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLFdBQVcsRUFBRSxFQUFFO1lBQ2YsVUFBVSxFQUFFLEVBQUU7U0FDakI7S0FDSixDQUFDLENBQUM7SUFFSCxJQUFJLE1BQU0sR0FBVyxDQUFDLENBQUM7SUFFdkI7UUFDSSxJQUFJLEtBQUssR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3hDLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3BCLGFBQWEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN6QztJQUNMLENBQUM7SUFFRCx1QkFBdUIsS0FBVztRQUM5QixJQUFJLFFBQVEsR0FBUyxFQUFFLENBQUM7UUFDeEIsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7WUFDbkIsSUFBSSxrQkFBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUM1QixRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQ3RCO1lBQ0QsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakQsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3hCLElBQUksa0JBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtvQkFDNUIsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztpQkFDdEI7Z0JBQ0QsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUMzQjtTQUNKO1FBQ0QsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQztJQUVELG9CQUFvQixLQUFhO1FBQzdCLElBQUksS0FBSyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1RCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUIsSUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUNsQyxJQUFJLGtCQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUMvQyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDeEIsbUJBQW1CO2dCQUNuQixFQUFFLEVBQUUsS0FBSztnQkFDVCxLQUFLLEVBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQztnQkFDekIsQ0FBQyxFQUFFLENBQUM7Z0JBQ0osQ0FBQyxFQUFFLENBQUM7Z0JBQ0osSUFBSSxFQUFFLEVBQUU7Z0JBQ1IsV0FBVyxFQUFFLE1BQU07YUFDdEIsQ0FBQyxDQUFDO1NBQ047UUFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xDLElBQUksa0JBQVcsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNyRCxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztvQkFDeEIsbUJBQW1CO29CQUNuQixFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztvQkFDZixLQUFLLEVBQUUsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDL0IsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO29CQUM5RixDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBQzlGLElBQUksRUFBRSxFQUFFO29CQUNSLFdBQVcsRUFBRSxNQUFNO2lCQUN0QixDQUFDLENBQUE7YUFDTDtZQUNELGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO2dCQUN4QixFQUFFLEVBQUUsTUFBTSxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUU7Z0JBQ2xDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUNuQixNQUFNLEVBQUUsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtnQkFDM0MsSUFBSSxFQUFFLENBQUM7Z0JBQ1AsS0FBSyxFQUFFLE1BQU07YUFDaEIsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDO0lBRUQsY0FBYyxPQUFlO1FBQ3pCLElBQUksS0FBSyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUIsSUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUNsQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEIsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7WUFDaEMsS0FBSyxJQUFJLE1BQU0sSUFBSSxRQUFRLEVBQUU7Z0JBQ3pCLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDbkIsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNoQyxLQUFLLElBQUksTUFBTSxJQUFJLFdBQVcsRUFBRTtvQkFDNUIsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQTtpQkFDdkI7YUFDSjtTQUNKO0lBQ0wsQ0FBQztJQUVELElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUN0QyxhQUFhLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRS9DLFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFVBQVUsS0FBYTtRQUNsRCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxLQUFhO1FBQzdDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFDSCxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxVQUFVLEtBQWE7UUFDN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUNILFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsS0FBYTtRQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBR1Asa0JBQWtCO0lBQ2Qsc0JBQVUsRUFBRSxDQUFDO0lBQ2IsSUFBSSxxQkFBcUIsR0FBRyxvQ0FBd0IsRUFBRSxDQUFDO0lBRTNELGdCQUFnQjtJQUNoQixvQ0FBb0M7SUFDaEMsSUFBSSxTQUFTLEdBQUcsRUFBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUMsQ0FBQztJQUNqQyxJQUFJLFlBQVksR0FBRyxFQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBQyxDQUFDO0lBRXBDO1FBQ0ksSUFBSSxhQUFhLEdBQUcsNEJBQWdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDL0QsSUFBSSxPQUFPLEdBQUcsdUJBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUMxQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUM5QyxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNqQjtRQUNELEtBQUssSUFBSSxJQUFJLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMxQyxJQUFJLElBQUksQ0FBQyxFQUFFLElBQUksYUFBYSxFQUFFO2dCQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUMsR0FBRyxFQUFFLHlCQUF5QixFQUFDLENBQUM7Z0JBQUEsQ0FBQzthQUNsRDtZQUNELElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxPQUFPLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBQyxHQUFHLEVBQUUsdUJBQXVCLEVBQUMsQ0FBQTthQUM5QztTQUNKO1FBQ0QsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3hCLElBQUksTUFBTSxHQUFHO1lBQ1QsVUFBVSxFQUFFLEVBQUU7WUFDZCxRQUFRLEVBQUUsQ0FBQztTQUNkLENBQUM7UUFFVix5QkFBeUI7UUFDakIsSUFBSSxRQUFRLEdBQUcsYUFBYSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU1RCxrQkFBa0I7UUFDVixRQUFRLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLFVBQVUsS0FBVTtZQUN4RCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztRQUVYLHNCQUFzQjtRQUNkLGFBQWEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUM5QixtQ0FBbUM7UUFFbkMscUJBQXFCLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBRUQsSUFBSSxNQUFNLEdBQXVCLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEUsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV0QyxJQUFJLGdCQUFnQixDQUFDO0lBQ3JCLElBQUksT0FBTyxHQUFHLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2xDLElBQUksZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0lBRTFCO1FBQ0ksT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3hELE9BQU8sR0FBRyxZQUFZLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUU5QixPQUFPLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQztRQUM5QixPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQztRQUM1QixPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixHQUFHLHFCQUFxQixDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDL0UsSUFBSSxhQUFhLEdBQUcscUJBQXFCLENBQUMsaUJBQWlCLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQztRQUMvSSxPQUFPLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFFL0QsT0FBTyxDQUFDLElBQUksR0FBRyxjQUFjLENBQUM7UUFDOUIsT0FBTyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7UUFDNUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbkUsSUFBSSxjQUFjLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlELE9BQU8sQ0FBQyxRQUFRLENBQUMsY0FBYyxFQUFFLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQy9ELElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDUixnQkFBZ0IsR0FBRyxDQUFDLENBQUM7YUFDeEI7WUFDRCxPQUFPLElBQUksZ0JBQWdCLENBQUM7U0FDL0I7UUFFRCxZQUFZLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxHQUFHLHVCQUFXLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRDtRQUNJLElBQUkscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7WUFDbkQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzVELE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQztTQUM1RjtJQUNMLENBQUM7SUFFTCxZQUFZO0lBQ1Isa0JBQWtCLENBQUM7UUFDZixJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxFQUFFO1lBQ2pCLElBQUksY0FBYyxHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQzdFLElBQUksQ0FBQyxrQkFBVyxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUM5Qiw2QkFBaUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDbEMscUJBQVMsRUFBRSxDQUFDO2dCQUNaLE1BQU0sRUFBRSxDQUFDO2FBQ1o7U0FDSjtJQUNMLENBQUM7SUFFRCxpQkFBaUIsQ0FBQztRQUNkLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUUsRUFBQyxNQUFNO1lBQ3hCLElBQUkscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7Z0JBQ25ELGdCQUFnQixFQUFFLENBQUM7Z0JBQ25CLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUM7Z0JBQ25GLFlBQVksRUFBRSxDQUFDO2FBQ2xCO1NBQ0o7YUFBTSxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxFQUFFLEVBQUMsSUFBSTtZQUM3QixJQUFJLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO2dCQUNuRCxnQkFBZ0IsRUFBRSxDQUFDO2dCQUNuQixJQUFJLGdCQUFnQixHQUFHLENBQUM7b0JBQ3BCLGdCQUFnQixHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2dCQUN4RSxZQUFZLEVBQUUsQ0FBQzthQUNsQjtTQUNKO0lBQ0wsQ0FBQztJQUVELE1BQU0sRUFBRSxDQUFDO0lBRVQsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdkQsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDekQsQ0FBQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgX19pbnN0YW5jZXMgPSB7fTtcclxuXHJcbiAgLy8gRGVhbCB3aXRoIHJlc2l6ZS4gIHNraXAgdGhpcyBmb3Igbm9kZS5qcyBhcHBzXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBfX2luc3RhbmNlcykge1xyXG4gICAgICAgIGlmIChfX2luc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBfX2luc3RhbmNlc1trZXldO1xyXG4gICAgICAgICAgaW5zdGFuY2UucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgdGhlIHNpZ21hIGluc3RhbmNlcyBjb25zdHJ1Y3Rvci4gT25lIGluc3RhbmNlIG9mIHNpZ21hIHJlcHJlc2VudFxyXG4gICAqIG9uZSBncmFwaC4gSXQgaXMgcG9zc2libGUgdG8gcmVwcmVzZW50IHRoaXMgZ3JhcMSlIHdpdGggc2V2ZXJhbCByZW5kZXJlcnNcclxuICAgKiBhdCB0aGUgc2FtZSB0aW1lLiBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCByZW5kZXJlciAoV2ViR0wgKyBDYW52YXNcclxuICAgKiBwb2x5ZmlsbCkgd2lsbCBiZSB1c2VkIGFzIHRoZSBvbmx5IHJlbmRlcmVyLCB3aXRoIHRoZSBjb250YWluZXIgc3BlY2lmaWVkXHJcbiAgICogaW4gdGhlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/Kn0gICAgY29uZiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgaW5zdGFuY2UuIFRoZXJlIGFyZSBhIGxvdCBvZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGRpZmZlcmVudCByZWNvZ25pemVkIGZvcm1zIHRvIGluc3RhbnRpYXRlIHNpZ21hLCBjaGVja1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZmlsZXMsIGRvY3VtZW50YXRpb24gaW4gdGhpcyBmaWxlIGFuZCB1bml0XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgdGVzdHMgdG8ga25vdyBtb3JlLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgIFRoZSBmcmVzaCBuZXcgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBJbnN0YW5jaWF0aW5nIHNpZ21hOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqXHJcbiAgICogSWYgbm8gcGFyYW1ldGVyIGlzIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxyXG4gICAqIHdpdGhvdXQgYW55IHJlbmRlcmVyIG9yIGNhbWVyYS4gSXQgd2lsbCBqdXN0IGluc3RhbnRpYXRlIHRoZSBncmFwaCwgYW5kXHJcbiAgICogb3RoZXIgbW9kdWxlcyB3aWxsIGhhdmUgdG8gYmUgaW5zdGFudGlhdGVkIHRocm91Z2ggdGhlIHB1YmxpYyBtZXRob2RzLFxyXG4gICAqIGxpa2UgXCJhZGRSZW5kZXJlclwiIGV0YzpcclxuICAgKlxyXG4gICAqICA+IHMwID0gbmV3IHNpZ21hKCk7XHJcbiAgICogID4gczAuYWRkUmVuZGVyZXIoe1xyXG4gICAqICA+ICAgdHlwZTogJ2NhbnZhcycsXHJcbiAgICogID4gICBjb250YWluZXI6ICdteS1jb250YWluZXItaWQnXHJcbiAgICogID4gfSk7XHJcbiAgICpcclxuICAgKiBJbiBtb3N0IG9mIHRoZSBjYXNlcywgc2lnbWEgd2lsbCBzaW1wbHkgYmUgdXNlZCB3aXRoIHRoZSBkZWZhdWx0IHJlbmRlcmVyLlxyXG4gICAqIFRoZW4sIHNpbmNlIHRoZSBvbmx5IHJlcXVpcmVkIHBhcmFtZXRlciBpcyB0aGUgRE9NIGNvbnRhaW5lciwgdGhlcmUgYXJlXHJcbiAgICogc29tZSBzaW1wbGVyIHdheSB0byBjYWxsIHRoZSBjb25zdHJ1Y3Rvci4gVGhlIGZvdXIgZm9sbG93aW5nIGNhbGxzIGRvIHRoZVxyXG4gICAqIGV4YWN0IHNhbWUgdGhpbmdzOlxyXG4gICAqXHJcbiAgICogID4gczEgPSBuZXcgc2lnbWEoJ215LWNvbnRhaW5lci1pZCcpO1xyXG4gICAqICA+IHMyID0gbmV3IHNpZ21hKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1jb250YWluZXItaWQnKSk7XHJcbiAgICogID4gczMgPSBuZXcgc2lnbWEoe1xyXG4gICAqICA+ICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJylcclxuICAgKiAgPiB9KTtcclxuICAgKiAgPiBzNCA9IG5ldyBzaWdtYSh7XHJcbiAgICogID4gICByZW5kZXJlcnM6IFt7XHJcbiAgICogID4gICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpXHJcbiAgICogID4gICB9XVxyXG4gICAqICA+IH0pO1xyXG4gICAqXHJcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycywgd2hlbiBjYWxsaW5nIHRoZVxyXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggdG8gdG9wIGxldmVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChmb3VydGggY2FzZSBpbiB0aGVcclxuICAgKiBwcmV2aW91cyBleGFtcGxlcyk6XHJcbiAgICpcclxuICAgKiAgIHs/c3RyaW5nfSBpZCAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnN0YW5jZS4gSXQgd2lsbCBiZSBnZW5lcmF0ZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAqICAgez9hcnJheX0gIHJlbmRlcmVycyBBbiBhcnJheSBjb250YWluaW5nIG9iamVjdHMgZGVzY3JpYmluZyByZW5kZXJlcnMuXHJcbiAgICogICB7P29iamVjdH0gZ3JhcGggICAgIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIG5vZGVzIGFuZCBhbiBhcnJheVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBvZiBlZGdlcywgdG8gYXZvaWQgaGF2aW5nIHRvIGFkZCB0aGVtIGJ5IGhhbmQgbGF0ZXIuXHJcbiAgICogICB7P29iamVjdH0gc2V0dGluZ3MgIEFuIG9iamVjdCBjb250YWluaW5nIGluc3RhbmNlIHNwZWNpZmljIHNldHRpbmdzIHRoYXRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBvbmVzIGRlZmluZWQgaW4gdGhlIG9iamVjdFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBzaWdtYS5zZXR0aW5ncy5cclxuICAgKi9cclxuICB2YXIgc2lnbWEgPSBmdW5jdGlvbihjb25mKSB7XHJcbiAgICAvLyBMb2NhbCB2YXJpYWJsZXM6XHJcbiAgICAvLyAqKioqKioqKioqKioqKioqXHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgYyxcclxuICAgICAgICBvLFxyXG4gICAgICAgIGlkO1xyXG5cclxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XHJcblxyXG4gICAgLy8gUHJpdmF0ZSBhdHRyaWJ1dGVzOlxyXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKlxyXG4gICAgdmFyIF9jb25mID0gY29uZiB8fCB7fTtcclxuXHJcbiAgICAvLyBMaXR0bGUgc2hvcnRjdXQ6XHJcbiAgICAvLyAqKioqKioqKioqKioqKioqXHJcbiAgICAvLyBUaGUgY29uZmlndXJhdGlvbiBpcyBzdXBwb3NlZCB0byBoYXZlIGEgbGlzdCBvZiB0aGUgY29uZmlndXJhdGlvblxyXG4gICAgLy8gb2JqZWN0cyBmb3IgZWFjaCByZW5kZXJlci5cclxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyBjb25maWd1cmF0aW9uIGF0IGFsbCwgdGhlbiBub3RoaW5nIGlzIGRvbmUuXHJcbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gcmVuZGVyZXIgbGlzdCwgdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpbGwgYmVcclxuICAgIC8vICAgIGNvbnNpZGVyZWQgYXMgZGVzY3JpYmluZyB0aGUgZmlyc3QgYW5kIG9ubHkgcmVuZGVyZXIuXHJcbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gcmVuZGVyZXIgbGlzdCBub3IgXCJjb250YWluZXJcIiBvYmplY3QsIGl0IHdpbGwgYmVcclxuICAgIC8vICAgIGNvbnNpZGVyZWQgYXMgdGhlIGNvbnRhaW5lciBpdHNlbGYgKGEgRE9NIGVsZW1lbnQpLlxyXG4gICAgLy8gIC0gSWYgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzaWdtYSgpIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWRcclxuICAgIC8vICAgIGFzIHRoZSBJRCBvZiB0aGUgRE9NIGNvbnRhaW5lci5cclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIF9jb25mID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICBfY29uZiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50XHJcbiAgICApXHJcbiAgICAgIF9jb25mID0ge1xyXG4gICAgICAgIHJlbmRlcmVyczogW19jb25mXVxyXG4gICAgICB9O1xyXG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF9jb25mKSA9PT0gJ1tvYmplY3QgQXJyYXldJylcclxuICAgICAgX2NvbmYgPSB7XHJcbiAgICAgICAgcmVuZGVyZXJzOiBfY29uZlxyXG4gICAgICB9O1xyXG5cclxuICAgIC8vIEFsc28gY2hlY2sgXCJyZW5kZXJlclwiIGFuZCBcImNvbnRhaW5lclwiIGtleXM6XHJcbiAgICBvID0gX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVyIHx8IF9jb25mLmNvbnRhaW5lcjtcclxuICAgIGlmICghX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVycy5sZW5ndGggPT09IDApXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0eXBlb2YgbyA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHxcclxuICAgICAgICAodHlwZW9mIG8gPT09ICdvYmplY3QnICYmICdjb250YWluZXInIGluIG8pXHJcbiAgICAgIClcclxuICAgICAgICBfY29uZi5yZW5kZXJlcnMgPSBbb107XHJcblxyXG4gICAgLy8gUmVjZW5zZSB0aGUgaW5zdGFuY2U6XHJcbiAgICBpZiAoX2NvbmYuaWQpIHtcclxuICAgICAgaWYgKF9faW5zdGFuY2VzW19jb25mLmlkXSlcclxuICAgICAgICB0aHJvdyAnc2lnbWE6IEluc3RhbmNlIFwiJyArIF9jb25mLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XHJcbiAgICAgICAgdmFsdWU6IF9jb25mLmlkXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWQgPSAwO1xyXG4gICAgICB3aGlsZSAoX19pbnN0YW5jZXNbaWRdKVxyXG4gICAgICAgIGlkKys7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XHJcbiAgICAgICAgdmFsdWU6ICcnICsgaWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfX2luc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBzZXR0aW5ncyBmdW5jdGlvbjpcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUoXHJcbiAgICAgIHNpZ21hLnNldHRpbmdzLFxyXG4gICAgICBfY29uZi5zZXR0aW5ncyB8fCB7fVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGxvY2tlZCBhdHRyaWJ1dGVzOlxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcclxuICAgICAgdmFsdWU6IG5ldyBzaWdtYS5jbGFzc2VzLmdyYXBoKHRoaXMuc2V0dGluZ3MpLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtaWRkbGV3YXJlcycsIHtcclxuICAgICAgdmFsdWU6IFtdLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmFzJywge1xyXG4gICAgICB2YWx1ZToge30sXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlbmRlcmVycycsIHtcclxuICAgICAgdmFsdWU6IHt9LFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZW5kZXJlcnNQZXJDYW1lcmEnLCB7XHJcbiAgICAgIHZhbHVlOiB7fSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FtZXJhRnJhbWVzJywge1xyXG4gICAgICB2YWx1ZToge30sXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYScsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW1lcmFzWzBdO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZXZlbnRzJywge1xyXG4gICAgICB2YWx1ZTogW1xyXG4gICAgICAgICdjbGljaycsXHJcbiAgICAgICAgJ3JpZ2h0Q2xpY2snLFxyXG4gICAgICAgICdjbGlja1N0YWdlJyxcclxuICAgICAgICAnZG91YmxlQ2xpY2tTdGFnZScsXHJcbiAgICAgICAgJ3JpZ2h0Q2xpY2tTdGFnZScsXHJcbiAgICAgICAgJ2NsaWNrTm9kZScsXHJcbiAgICAgICAgJ2NsaWNrTm9kZXMnLFxyXG4gICAgICAgICdkb3VibGVDbGlja05vZGUnLFxyXG4gICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcclxuICAgICAgICAncmlnaHRDbGlja05vZGUnLFxyXG4gICAgICAgICdyaWdodENsaWNrTm9kZXMnLFxyXG4gICAgICAgICdob3ZlcnMnLFxyXG4gICAgICAgICdkb3duTm9kZScsXHJcbiAgICAgICAgJ2Rvd25Ob2RlcycsXHJcbiAgICAgICAgJ3VwTm9kZScsXHJcbiAgICAgICAgJ3VwTm9kZXMnXHJcbiAgICAgIF0sXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIGEgY3VzdG9tIGhhbmRsZXIsIHRvIHJlZGlzcGF0Y2ggZXZlbnRzIGZyb20gcmVuZGVyZXJzOlxyXG4gICAgdGhpcy5faGFuZGxlciA9IChmdW5jdGlvbihlKSB7XHJcbiAgICAgIHZhciBrLFxyXG4gICAgICAgICAgZGF0YSA9IHt9O1xyXG5cclxuICAgICAgZm9yIChrIGluIGUuZGF0YSlcclxuICAgICAgICBkYXRhW2tdID0gZS5kYXRhW2tdO1xyXG5cclxuICAgICAgZGF0YS5yZW5kZXJlciA9IGUudGFyZ2V0O1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZS50eXBlLCBkYXRhKTtcclxuICAgIH0pLmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSByZW5kZXJlcnM6XHJcbiAgICBhID0gX2NvbmYucmVuZGVyZXJzIHx8IFtdO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICB0aGlzLmFkZFJlbmRlcmVyKGFbaV0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgbWlkZGxld2FyZXM6XHJcbiAgICBhID0gX2NvbmYubWlkZGxld2FyZXMgfHwgW107XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIHRoaXMubWlkZGxld2FyZXMucHVzaChcclxuICAgICAgICB0eXBlb2YgYVtpXSA9PT0gJ3N0cmluZycgP1xyXG4gICAgICAgICAgc2lnbWEubWlkZGxld2FyZXNbYVtpXV0gOlxyXG4gICAgICAgICAgYVtpXVxyXG4gICAgICApO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBncmFwaCB0byBmaWxsIGluOlxyXG4gICAgaWYgKHR5cGVvZiBfY29uZi5ncmFwaCA9PT0gJ29iamVjdCcgJiYgX2NvbmYuZ3JhcGgpIHtcclxuICAgICAgdGhpcy5ncmFwaC5yZWFkKF9jb25mLmdyYXBoKTtcclxuXHJcbiAgICAgIC8vIElmIGEgZ3JhcGggaXMgZ2l2ZW4gdG8gdGhlIHRvIHRoZSBpbnN0YW5jZSwgdGhlIFwicmVmcmVzaFwiIG1ldGhvZCBpc1xyXG4gICAgICAvLyBkaXJlY3RseSBjYWxsZWQ6XHJcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IGNhbWVyYS4gSWYgbm8gaWQgaXNcclxuICAgKiBzcGVjaWZpZWQsIHRoZW4gYW4gYXV0b21hdGljIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgICAgIGlkIEV2ZW50dWFsbHkgdGhlIGNhbWVyYSBpZC5cclxuICAgKiBAcmV0dXJuIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgVGhlIGZyZXNoIG5ldyBjYW1lcmEgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEucHJvdG90eXBlLmFkZENhbWVyYSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY2FtZXJhO1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBpZCA9IDA7XHJcbiAgICAgIHdoaWxlICh0aGlzLmNhbWVyYXNbJycgKyBpZF0pXHJcbiAgICAgICAgaWQrKztcclxuICAgICAgaWQgPSAnJyArIGlkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmNhbWVyYXNbaWRdKVxyXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkQ2FtZXJhOiBUaGUgY2FtZXJhIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XHJcblxyXG4gICAgY2FtZXJhID0gbmV3IHNpZ21hLmNsYXNzZXMuY2FtZXJhKGlkLCB0aGlzLmdyYXBoLCB0aGlzLnNldHRpbmdzKTtcclxuICAgIHRoaXMuY2FtZXJhc1tpZF0gPSBjYW1lcmE7XHJcblxyXG4gICAgLy8gQWRkIGEgcXVhZHRyZWUgdG8gdGhlIGNhbWVyYTpcclxuICAgIGNhbWVyYS5xdWFkdHJlZSA9IG5ldyBzaWdtYS5jbGFzc2VzLnF1YWQoKTtcclxuXHJcbiAgICAvLyBBZGQgYW4gZWRnZXF1YWR0cmVlIHRvIHRoZSBjYW1lcmE6XHJcbiAgICBpZiAoc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNhbWVyYS5lZGdlcXVhZHRyZWUgPSBuZXcgc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbWVyYS5iaW5kKCdjb29yZGluYXRlc1VwZGF0ZWQnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY29vcmRpbmF0ZXNVcGRhdGVkJyk7XHJcbiAgICAgIHNlbGYucmVuZGVyQ2FtZXJhKGNhbWVyYSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtpZF0gPSBbXTtcclxuXHJcbiAgICByZXR1cm4gY2FtZXJhO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgY2FtZXJhLCBhbmQgZXZlcnkgcmVuZGVyZXIgYXR0YWNoZWQgdG8gaXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8Y2FtZXJhfSB2IFRoZSBjYW1lcmEgdG8ga2lsbCBvciBpdHMgSUQuXHJcbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUua2lsbENhbWVyYSA9IGZ1bmN0aW9uKHYpIHtcclxuICAgIHYgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0aGlzLmNhbWVyYXNbdl0gOiB2O1xyXG5cclxuICAgIGlmICghdilcclxuICAgICAgdGhyb3cgJ3NpZ21hLmtpbGxDYW1lcmE6IFRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkLic7XHJcblxyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5pZF07XHJcblxyXG4gICAgZm9yIChsID0gYS5sZW5ndGgsIGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgIHRoaXMua2lsbFJlbmRlcmVyKGFbaV0pO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmlkXTtcclxuICAgIGRlbGV0ZSB0aGlzLmNhbWVyYUZyYW1lc1t2LmlkXTtcclxuICAgIGRlbGV0ZSB0aGlzLmNhbWVyYXNbdi5pZF07XHJcblxyXG4gICAgaWYgKHYua2lsbClcclxuICAgICAgdi5raWxsKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2RzIHdpbGwgaW5zdGFudGlhdGUgYW5kIHJlZmVyZW5jZSBhIG5ldyByZW5kZXJlci4gVGhlIFwidHlwZVwiXHJcbiAgICogYXJndW1lbnQgY2FuIGJlIHRoZSBjb25zdHJ1Y3RvciBvciBpdHMgbmFtZSBpbiB0aGUgXCJzaWdtYS5yZW5kZXJlcnNcIlxyXG4gICAqIHBhY2thZ2UuIElmIG5vIHR5cGUgaXMgc3BlY2lmaWVkLCB0aGVuIFwic2lnbWEucmVuZGVyZXJzLmRlZlwiIHdpbGwgYmUgdXNlZC5cclxuICAgKiBJZiBubyBpZCBpcyBzcGVjaWZpZWQsIHRoZW4gYW4gYXV0b21hdGljIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbnMgRXZlbnR1YWxseSBzb21lIG9wdGlvbnMgdG8gZ2l2ZSB0byB0aGUgcmVuZGVyZXJcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5cclxuICAgKiBAcmV0dXJuIHtyZW5kZXJlcn0gICAgICAgICBUaGUgZnJlc2ggbmV3IHJlbmRlcmVyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgXCJvcHRpb25zXCJcclxuICAgKiBvYmplY3Q6XHJcbiAgICpcclxuICAgKiAgIHs/c3RyaW5nfSAgICAgICAgICAgIGlkICAgICBFdmVudHVhbGx5IHRoZSByZW5kZXJlciBpZC5cclxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IHR5cGUgICBFdmVudHVhbGx5IHRoZSByZW5kZXJlciBjb25zdHJ1Y3RvciBvciBpdHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIGluIHRoZSBcInNpZ21hLnJlbmRlcmVyc1wiIHBhY2thZ2UuXHJcbiAgICogICB7PyhjYW1lcmF8c3RyaW5nKX0gICBjYW1lcmEgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgY2FtZXJhIG9yIGl0c1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLlxyXG4gICAqL1xyXG4gIHNpZ21hLnByb3RvdHlwZS5hZGRSZW5kZXJlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHZhciBpZCxcclxuICAgICAgICBmbixcclxuICAgICAgICBjYW1lcmEsXHJcbiAgICAgICAgcmVuZGVyZXIsXHJcbiAgICAgICAgbyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLy8gUG9seW1vcnBoaXNtOlxyXG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJylcclxuICAgICAgbyA9IHtcclxuICAgICAgICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG8pXHJcbiAgICAgIH07XHJcbiAgICBlbHNlIGlmIChvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpXHJcbiAgICAgIG8gPSB7XHJcbiAgICAgICAgY29udGFpbmVyOiBvXHJcbiAgICAgIH07XHJcblxyXG4gICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzdGlsbCBpcyBhIHN0cmluZywgd2UgZ2V0IGl0IGJ5IGlkXHJcbiAgICBpZiAodHlwZW9mIG8uY29udGFpbmVyID09PSAnc3RyaW5nJylcclxuICAgICAgby5jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvLmNvbnRhaW5lcik7XHJcblxyXG4gICAgLy8gUmVmZXJlbmNlIHRoZSBuZXcgcmVuZGVyZXI6XHJcbiAgICBpZiAoISgnaWQnIGluIG8pKSB7XHJcbiAgICAgIGlkID0gMDtcclxuICAgICAgd2hpbGUgKHRoaXMucmVuZGVyZXJzWycnICsgaWRdKVxyXG4gICAgICAgIGlkKys7XHJcbiAgICAgIGlkID0gJycgKyBpZDtcclxuICAgIH0gZWxzZVxyXG4gICAgICBpZCA9IG8uaWQ7XHJcblxyXG4gICAgaWYgKHRoaXMucmVuZGVyZXJzW2lkXSlcclxuICAgICAgdGhyb3cgJ3NpZ21hLmFkZFJlbmRlcmVyOiBUaGUgcmVuZGVyZXIgXCInICsgaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBnb29kIGNvbnN0cnVjdG9yOlxyXG4gICAgZm4gPSB0eXBlb2Ygby50eXBlID09PSAnZnVuY3Rpb24nID8gby50eXBlIDogc2lnbWEucmVuZGVyZXJzW28udHlwZV07XHJcbiAgICBmbiA9IGZuIHx8IHNpZ21hLnJlbmRlcmVycy5kZWY7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgZ29vZCBjYW1lcmE6XHJcbiAgICBjYW1lcmEgPSAnY2FtZXJhJyBpbiBvID9cclxuICAgICAgKFxyXG4gICAgICAgIG8uY2FtZXJhIGluc3RhbmNlb2Ygc2lnbWEuY2xhc3Nlcy5jYW1lcmEgP1xyXG4gICAgICAgICAgby5jYW1lcmEgOlxyXG4gICAgICAgICAgdGhpcy5jYW1lcmFzW28uY2FtZXJhXSB8fCB0aGlzLmFkZENhbWVyYShvLmNhbWVyYSlcclxuICAgICAgKSA6XHJcbiAgICAgIHRoaXMuYWRkQ2FtZXJhKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuY2FtZXJhc1tjYW1lcmEuaWRdICE9PSBjYW1lcmEpXHJcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIGNhbWVyYSBpcyBub3QgcHJvcGVybHkgcmVmZXJlbmNlZC4nO1xyXG5cclxuICAgIC8vIEluc3RhbnRpYXRlOlxyXG4gICAgcmVuZGVyZXIgPSBuZXcgZm4odGhpcy5ncmFwaCwgY2FtZXJhLCB0aGlzLnNldHRpbmdzLCBvKTtcclxuICAgIHRoaXMucmVuZGVyZXJzW2lkXSA9IHJlbmRlcmVyO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlcmVyLCAnaWQnLCB7XHJcbiAgICAgIHZhbHVlOiBpZFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQmluZCBldmVudHM6XHJcbiAgICBpZiAocmVuZGVyZXIuYmluZClcclxuICAgICAgcmVuZGVyZXIuYmluZChcclxuICAgICAgICBbXHJcbiAgICAgICAgICAnY2xpY2snLFxyXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2snLFxyXG4gICAgICAgICAgJ2NsaWNrU3RhZ2UnLFxyXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxyXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tTdGFnZScsXHJcbiAgICAgICAgICAnY2xpY2tOb2RlJyxcclxuICAgICAgICAgICdjbGlja05vZGVzJyxcclxuICAgICAgICAgICdjbGlja0VkZ2UnLFxyXG4gICAgICAgICAgJ2NsaWNrRWRnZXMnLFxyXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZScsXHJcbiAgICAgICAgICAnZG91YmxlQ2xpY2tOb2RlcycsXHJcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlJyxcclxuICAgICAgICAgICdkb3VibGVDbGlja0VkZ2VzJyxcclxuICAgICAgICAgICdyaWdodENsaWNrTm9kZScsXHJcbiAgICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcclxuICAgICAgICAgICdyaWdodENsaWNrRWRnZScsXHJcbiAgICAgICAgICAncmlnaHRDbGlja0VkZ2VzJyxcclxuICAgICAgICAgICdob3ZlcnMnLFxyXG4gICAgICAgICAgJ2Rvd25Ob2RlJyxcclxuICAgICAgICAgICdkb3duTm9kZXMnLFxyXG4gICAgICAgICAgJ2Rvd25FZGdlJyxcclxuICAgICAgICAgICdkb3duRWRnZXMnLFxyXG4gICAgICAgICAgJ3VwTm9kZScsXHJcbiAgICAgICAgICAndXBOb2RlcycsXHJcbiAgICAgICAgICAndXBFZGdlJyxcclxuICAgICAgICAgICd1cEVkZ2VzJ1xyXG4gICAgICAgIF0sXHJcbiAgICAgICAgdGhpcy5faGFuZGxlclxyXG4gICAgICApO1xyXG5cclxuICAgIC8vIFJlZmVyZW5jZSB0aGUgcmVuZGVyZXIgYnkgaXRzIGNhbWVyYTpcclxuICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF0ucHVzaChyZW5kZXJlcik7XHJcblxyXG4gICAgcmV0dXJuIHJlbmRlcmVyO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgcmVuZGVyZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8cmVuZGVyZXJ9IHYgVGhlIHJlbmRlcmVyIHRvIGtpbGwgb3IgaXRzIElELlxyXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUua2lsbFJlbmRlcmVyID0gZnVuY3Rpb24odikge1xyXG4gICAgdiA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRoaXMucmVuZGVyZXJzW3ZdIDogdjtcclxuXHJcbiAgICBpZiAoIXYpXHJcbiAgICAgIHRocm93ICdzaWdtYS5raWxsUmVuZGVyZXI6IFRoZSByZW5kZXJlciBpcyB1bmRlZmluZWQuJztcclxuXHJcbiAgICB2YXIgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuY2FtZXJhLmlkXSxcclxuICAgICAgICBpID0gYS5pbmRleE9mKHYpO1xyXG5cclxuICAgIGlmIChpID49IDApXHJcbiAgICAgIGEuc3BsaWNlKGksIDEpO1xyXG5cclxuICAgIGlmICh2LmtpbGwpXHJcbiAgICAgIHYua2lsbCgpO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyc1t2LmlkXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlciwgd2l0aCB0aGUgc2FtZVxyXG4gICAqIGFyZ3VtZW50cyB0aGFuIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYnV0IHdpbGwgYWxzbyBjaGVjayBpZiB0aGUgcmVuZGVyZXJcclxuICAgKiBoYXMgYSBcInByb2Nlc3NcIiBtZXRob2QsIGFuZCBjYWxsIGl0IGlmIGl0IGV4aXN0cy5cclxuICAgKlxyXG4gICAqIEl0IGlzIHVzZWZ1bCBmb3IgcXVhZHRyZWVzIG9yIFdlYkdMIHByb2Nlc3NpbmcsIGZvciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICBvcHRpb25zIEV2ZW50dWFsbHkgc29tZSBvcHRpb25zIHRvIGdpdmUgdG8gdGhlIHJlZnJlc2hcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuXHJcbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqXHJcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgXCJvcHRpb25zXCJcclxuICAgKiBvYmplY3Q6XHJcbiAgICpcclxuICAgKiAgIHs/Ym9vbGVhbn0gc2tpcEluZGV4YXRpb24gQSBmbGFnIHNwZWNpZnlpbmcgd2V0aGVyIG9yIG5vdCB0aGUgcmVmcmVzaFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGQgcmVpbmRleCB0aGUgZ3JhcGggaW4gdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWR0cmVlcyBvciBub3QgKGRlZmF1bHQ6IGZhbHNlKS5cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgayxcclxuICAgICAgICBhLFxyXG4gICAgICAgIGMsXHJcbiAgICAgICAgYm91bmRzLFxyXG4gICAgICAgIHByZWZpeCA9IDA7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLy8gQ2FsbCBlYWNoIG1pZGRsZXdhcmU6XHJcbiAgICBhID0gdGhpcy5taWRkbGV3YXJlcyB8fCBbXTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgYVtpXS5jYWxsKFxyXG4gICAgICAgIHRoaXMsXHJcbiAgICAgICAgKGkgPT09IDApID8gJycgOiAndG1wJyArIHByZWZpeCArICc6JyxcclxuICAgICAgICAoaSA9PT0gbCAtIDEpID8gJ3JlYWR5OicgOiAoJ3RtcCcgKyAoKytwcmVmaXgpICsgJzonKVxyXG4gICAgICApO1xyXG5cclxuICAgIC8vIFRoZW4sIGZvciBlYWNoIGNhbWVyYSwgY2FsbCB0aGUgXCJyZXNjYWxlXCIgbWlkZGxld2FyZSwgdW5sZXNzIHRoZVxyXG4gICAgLy8gc2V0dGluZ3Mgc3BlY2lmeSBub3QgdG86XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5jYW1lcmFzKSB7XHJcbiAgICAgIGMgPSB0aGlzLmNhbWVyYXNba107XHJcbiAgICAgIGlmIChcclxuICAgICAgICBjLnNldHRpbmdzKCdhdXRvUmVzY2FsZScpICYmXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF0gJiZcclxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXS5sZW5ndGhcclxuICAgICAgKVxyXG4gICAgICAgIHNpZ21hLm1pZGRsZXdhcmVzLnJlc2NhbGUuY2FsbChcclxuICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICBhLmxlbmd0aCA/ICdyZWFkeTonIDogJycsXHJcbiAgICAgICAgICBjLnJlYWRQcmVmaXgsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXVswXS53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXVswXS5oZWlnaHRcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMuY29weS5jYWxsKFxyXG4gICAgICAgICAgdGhpcyxcclxuICAgICAgICAgIGEubGVuZ3RoID8gJ3JlYWR5OicgOiAnJyxcclxuICAgICAgICAgIGMucmVhZFByZWZpeFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICBpZiAoIW9wdGlvbnMuc2tpcEluZGV4YXRpb24pIHtcclxuICAgICAgICAvLyBGaW5kIGdyYXBoIGJvdW5kYXJpZXM6XHJcbiAgICAgICAgYm91bmRzID0gc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyhcclxuICAgICAgICAgIHRoaXMuZ3JhcGgsXHJcbiAgICAgICAgICBjLnJlYWRQcmVmaXhcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBSZWZyZXNoIHF1YWR0cmVlOlxyXG4gICAgICAgIGMucXVhZHRyZWUuaW5kZXgodGhpcy5ncmFwaCwge1xyXG4gICAgICAgICAgcHJlZml4OiBjLnJlYWRQcmVmaXgsXHJcbiAgICAgICAgICBtYXhMZXZlbDogYy5zZXR0aW5ncygnbm9kZVF1YWR0cmVlTWF4TGV2ZWwnKSxcclxuICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICB4OiBib3VuZHMubWluWCxcclxuICAgICAgICAgICAgeTogYm91bmRzLm1pblksXHJcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pbllcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUmVmcmVzaCBlZGdlcXVhZHRyZWU6XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgYy5zZXR0aW5ncygnZHJhd0VkZ2VzJykgJiZcclxuICAgICAgICAgIChjLnNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSB8fFxyXG4gICAgICAgICAgICBjLnNldHRpbmdzKCdlZGdlc0NsaXBwaW5nV2l0aE5vZGVzJykpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLCB7XHJcbiAgICAgICAgICAgIHByZWZpeDogYy5yZWFkUHJlZml4LFxyXG4gICAgICAgICAgICBtYXhMZXZlbDogYy5zZXR0aW5ncygnZWRnZVF1YWR0cmVlTWF4TGV2ZWwnKSxcclxuICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgeDogYm91bmRzLm1pblgsXHJcbiAgICAgICAgICAgICAgeTogYm91bmRzLm1pblksXHJcbiAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgsXHJcbiAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMubWF4WSAtIGJvdW5kcy5taW5ZXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcclxuICAgIGEgPSBPYmplY3Qua2V5cyh0aGlzLnJlbmRlcmVycyk7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldICsgJ1wiIGNyYXNoZWQgb24gXCIucHJvY2VzcygpXCInXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucHJvY2VzcygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3NpZ21hfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGwsXHJcbiAgICAgICAgaSxcclxuICAgICAgICBwcmVmaXggPSAwO1xyXG5cclxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcclxuICAgIGZvciAoaSBpbiB0aGlzLnJlbmRlcmVycylcclxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5yZW5kZXJlcnNbaV0ucmVuZGVyKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyB0aGlzLnJlbmRlcmVyc1tpXSArXHJcbiAgICAgICAgICAgICAgJ1wiIGNyYXNoZWQgb24gXCIucmVuZGVyKClcIidcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnJlbmRlcmVyc1tpXS5yZW5kZXIoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlciB0aGF0IGlzIGJvdW5kIHRvXHJcbiAgICogdGhlIHNwZWNpZmllZCBjYW1lcmEuIFRvIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlcywgaWYgdGhpcyBtZXRob2QgaXNcclxuICAgKiBjYWxsZWQgdG9vIG9mdGVuLCB0aGUgbnVtYmVyIG9mIGVmZmVjdGl2ZSByZW5kZXJpbmdzIGlzIGxpbWl0YXRlZCB0byBvbmVcclxuICAgKiBwZXIgZnJhbWUsIHVubGVzcyB5b3UgYXJlIHVzaW5nIHRoZSBcImZvcmNlXCIgZmxhZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSBjYW1lcmEgVGhlIGNhbWVyYSB0byByZW5kZXIuXHJcbiAgICogQHBhcmFtICB7P2Jvb2xlYW59ICAgICAgICAgICAgIGZvcmNlICBJZiB0cnVlLCB3aWxsIHJlbmRlciB0aGUgY2FtZXJhXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RseS5cclxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUucmVuZGVyQ2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhLCBmb3JjZSkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBhLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGlmIChmb3JjZSkge1xyXG4gICAgICBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbY2FtZXJhLmlkXTtcclxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygndmVyYm9zZScpKVxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicrIGFbaV0uaWQgKyAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgYVtpXS5yZW5kZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICghdGhpcy5jYW1lcmFGcmFtZXNbY2FtZXJhLmlkXSkge1xyXG4gICAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicrYVtpXS5pZCArJ1wiIGNyYXNoZWQgb24gXCIucmVuZGVyKClcIidcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmFGcmFtZXNbY2FtZXJhLmlkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGRlbGV0ZSBzZWxmLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwia2lsbFwiIG1ldGhvZCBvZiBlYWNoIG1vZHVsZSBhbmQgZGVzdHJveXMgYW55XHJcbiAgICogcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaztcclxuXHJcbiAgICAvLyBEaXNwYXRjaGluZyBldmVudFxyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdraWxsJyk7XHJcblxyXG4gICAgLy8gS2lsbCBncmFwaDpcclxuICAgIHRoaXMuZ3JhcGgua2lsbCgpO1xyXG5cclxuICAgIC8vIEtpbGwgbWlkZGxld2FyZXM6XHJcbiAgICBkZWxldGUgdGhpcy5taWRkbGV3YXJlcztcclxuXHJcbiAgICAvLyBLaWxsIGVhY2ggcmVuZGVyZXI6XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5yZW5kZXJlcnMpXHJcbiAgICAgIHRoaXMua2lsbFJlbmRlcmVyKHRoaXMucmVuZGVyZXJzW2tdKTtcclxuXHJcbiAgICAvLyBLaWxsIGVhY2ggY2FtZXJhOlxyXG4gICAgZm9yIChrIGluIHRoaXMuY2FtZXJhcylcclxuICAgICAgdGhpcy5raWxsQ2FtZXJhKHRoaXMuY2FtZXJhc1trXSk7XHJcblxyXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzO1xyXG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhcztcclxuXHJcbiAgICAvLyBLaWxsIGV2ZXJ5dGhpbmcgZWxzZTpcclxuICAgIGZvciAoayBpbiB0aGlzKVxyXG4gICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrKSlcclxuICAgICAgICBkZWxldGUgdGhpc1trXTtcclxuXHJcbiAgICBkZWxldGUgX19pbnN0YW5jZXNbdGhpcy5pZF07XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBpbnN0YW5jZXMgb2JqZWN0IG9yIGEgc3BlY2lmaWMgcnVubmluZyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IGlkIEV2ZW50dWFsbHkgYW4gaW5zdGFuY2UgSUQuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIHJlbGF0ZWQgaW5zdGFuY2Ugb3IgYSBjbG9uZSBvZiB0aGUgaW5zdGFuY2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlxyXG4gICAqL1xyXG4gIHNpZ21hLmluc3RhbmNlcyA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/XHJcbiAgICAgIF9faW5zdGFuY2VzW2lkXSA6XHJcbiAgICAgIHNpZ21hLnV0aWxzLmV4dGVuZCh7fSwgX19pbnN0YW5jZXMpO1xyXG4gIH07XHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBzaWdtYTpcclxuICAgKi9cclxuICBzaWdtYS52ZXJzaW9uID0gJzEuNS4yJztcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2FibGUgRVM2IGZlYXR1cmVzIGlmIHRydWU6XHJcbiAgICovXHJcbiAgc2lnbWEuZm9yY2VFUzUgPSBmYWxzZTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEVYUE9SVDpcclxuICAgKiAqKioqKioqXHJcbiAgICovXHJcbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdBbiBvYmplY3QgY2FsbGVkIHNpZ21hIGlzIGFscmVhZHkgaW4gdGhlIGdsb2JhbCBzY29wZS4nO1xyXG5cclxuICB0aGlzLnNpZ21hID0gc2lnbWE7XHJcblxyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuLyoqXHJcbiAqIGNvbnJhZC5qcyBpcyBhIHRpbnkgSmF2YVNjcmlwdCBqb2JzIHNjaGVkdWxlcixcclxuICpcclxuICogVmVyc2lvbjogMC4xLjBcclxuICogU291cmNlczogaHR0cDovL2dpdGh1Yi5jb20vamFjb215YWwvY29ucmFkLmpzXHJcbiAqIERvYzogICAgIGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qcyNyZWFkbWVcclxuICpcclxuICogTGljZW5zZTpcclxuICogLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IMKpIDIwMTMgQWxleGlzIEphY29teSwgU2NpZW5jZXMtUG8gbcOpZGlhbGFiXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cclxuICogZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcclxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXHJcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUaGUgU29mdHdhcmUgaXMgcHJvdmlkZWQgXCJhcyBpc1wiLCB3aXRob3V0IHdhcnJhbnR5IG9mIGFueSBraW5kLCBleHByZXNzIG9yXHJcbiAqIGltcGxpZWQsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gdGhlIHdhcnJhbnRpZXMgb2YgbWVyY2hhbnRhYmlsaXR5LFxyXG4gKiBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZSBhbmQgbm9uaW5mcmluZ2VtZW50LiBJbiBubyBldmVudCBzaGFsbCB0aGVcclxuICogYXV0aG9ycyBvciBjb3B5cmlnaHQgaG9sZGVycyBiZSBsaWFibGUgZm9yIGFueSBjbGFpbSwgZGFtYWdlcyBvciBvdGhlclxyXG4gKiBsaWFiaWxpdHksIHdoZXRoZXIgaW4gYW4gYWN0aW9uIG9mIGNvbnRyYWN0LCB0b3J0IG9yIG90aGVyd2lzZSwgYXJpc2luZ1xyXG4gKiBmcm9tLCBvdXQgb2Ygb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBzb2Z0d2FyZSBvciB0aGUgdXNlIG9yIG90aGVyIGRlYWxpbmdzXHJcbiAqIGluIHRoZSBTb2Z0d2FyZS5cclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8vIENoZWNrIHRoYXQgY29ucmFkLmpzIGhhcyBub3QgYmVlbiBsb2FkZWQgeWV0OlxyXG4gIGlmIChnbG9iYWwuY29ucmFkKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb25yYWQgYWxyZWFkeSBleGlzdHMnKTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFBSSVZBVEUgVkFSSUFCTEVTOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbnJhZCBpcyBydW5uaW5nIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICovXHJcbiAgdmFyIF9sYXN0RnJhbWVUaW1lO1xyXG5cclxuICAvKipcclxuICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbnJhZCBpcyBydW5uaW5nIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIHZhciBfaXNSdW5uaW5nID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBoYXNoIG9mIHJlZ2lzdGVyZWQgam9icy4gRWFjaCBqb2IgbXVzdCBhdCBsZWFzdCBoYXZlIGEgdW5pcXVlIElEXHJcbiAgICogdW5kZXIgdGhlIGtleSBcImlkXCIgYW5kIGEgZnVuY3Rpb24gdW5kZXIgdGhlIGtleSBcImpvYlwiLiBUaGlzIGhhc2hcclxuICAgKiBjb250YWlucyBlYWNoIHJ1bm5pbmcgam9iIGFuZCBlYWNoIHdhaXRpbmcgam9iLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICB2YXIgX2pvYnMgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGhhc2ggb2YgY3VycmVudGx5IHJ1bm5pbmcgam9icy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdmFyIF9ydW5uaW5nSm9icyA9IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgYXJyYXkgb2YgY3VycmVudGx5IHJ1bm5pbmcgam9icywgc29ydGVkIGJ5IHByaW9yaXR5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0FycmF5fVxyXG4gICAqL1xyXG4gIHZhciBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSB3YWl0aW5nIGpvYnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIHZhciBfd2FpdGluZ0pvYnMgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFycmF5IG9mIGZpbmlzaGVkIGpvYnMuIFRoZXkgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSwgc2luY2UgdHdvIGpvYnNcclxuICAgKiB3aXRoIHRoZSBzYW1lIFwiaWRcIiBjYW4gaGFwcGVuIGF0IHR3byBkaWZmZXJlbnQgdGltZXMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICovXHJcbiAgdmFyIF9kb25lSm9icyA9IFtdO1xyXG5cclxuICAvKipcclxuICAgKiBBIGRpcnR5IGZsYWcgdG8ga2VlcCBjb25yYWQgZnJvbSBzdGFydGluZzogSW5kZWVkLCB3aGVuIGFkZEpvYigpIGlzIGNhbGxlZFxyXG4gICAqIHdpdGggc2V2ZXJhbCBqb2JzLCBjb25yYWQgbXVzdCBiZSBzdGFydGVkIG9ubHkgYXQgdGhlIGVuZC4gVGhpcyBmbGFnIGtlZXBzXHJcbiAgICogbWUgZnJvbSBkdXBsaWNhdGluZyB0aGUgY29kZSB0aGF0IGVmZmVjdGl2ZWx5IGFkZHMgYSBqb2IuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICB2YXIgX25vU3RhcnQgPSBmYWxzZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQW4gaGFzaCBjb250YWluaW5nIHNvbWUgZ2xvYmFsIHNldHRpbmdzIGFib3V0IGhvdyBjb25yYWQuanMgc2hvdWxkXHJcbiAgICogYmVoYXZlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICB2YXIgX3BhcmFtZXRlcnMgPSB7XHJcbiAgICBmcmFtZUR1cmF0aW9uOiAyMCxcclxuICAgIGhpc3Rvcnk6IHRydWVcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBldmVyeSBoYW5kbGVycyBib3VuZCB0byBjb25yYWQgZXZlbnRzLiBJdCBkb2VzIG5vdFxyXG4gICAqIHJlcXVpcmVhIGFueSBET00gaW1wbGVtZW50YXRpb24sIHNpbmNlIHRoZSBldmVudHMgYXJlIGFsbCBKYXZhU2NyaXB0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICB2YXIgX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFBSSVZBVEUgRlVOQ1RJT05TOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBXaWxsIGV4ZWN1dGUgdGhlIGhhbmRsZXIgZXZlcnl0aW1lIHRoYXQgdGhlIGluZGljYXRlZCBldmVudCAob3IgdGhlXHJcbiAgICogaW5kaWNhdGVkIGV2ZW50cykgd2lsbCBiZSB0cmlnZ2VyZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl8b2JqZWN0fSBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gICAgaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyBjb25yYWQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2JpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBpX2VuZCxcclxuICAgICAgICBldmVudCxcclxuICAgICAgICBlQXJyYXk7XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBlbHNlIGlmIChcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICBPYmplY3QoYXJndW1lbnRzWzBdKSA9PT0gYXJndW1lbnRzWzBdXHJcbiAgICApXHJcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcclxuICAgICAgICBfYmluZChldmVudHMsIGFyZ3VtZW50c1swXVtldmVudHNdKTtcclxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGVBcnJheSA9XHJcbiAgICAgICAgQXJyYXkuaXNBcnJheShldmVudHMpID9cclxuICAgICAgICAgIGV2ZW50cyA6XHJcbiAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSkge1xyXG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xyXG5cclxuICAgICAgICBpZiAoIV9oYW5kbGVyc1tldmVudF0pXHJcbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gW107XHJcblxyXG4gICAgICAgIC8vIFVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHRoZSBoYW5kbGVyIHdpbGwgbWFrZSBwb3NzaWJsZVxyXG4gICAgICAgIC8vIGxhdGVyIHRvIGFkZCBmbGFnc1xyXG4gICAgICAgIF9oYW5kbGVyc1tldmVudF0ucHVzaCh7XHJcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgICAgICAgZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGhhbmRsZXJzIGFyZSByZW1vdmVkLlxyXG4gICAqIEBwYXJhbSAgez9mdW5jdGlvbihPYmplY3QpfSBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIHVuYmluZC4gSWYgdW5kZWZpbmVkLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgUmV0dXJucyBjb25yYWQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3VuYmluZChldmVudHMsIGhhbmRsZXIpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGlfZW5kLFxyXG4gICAgICAgIGosXHJcbiAgICAgICAgal9lbmQsXHJcbiAgICAgICAgYSxcclxuICAgICAgICBldmVudCxcclxuICAgICAgICBlQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xyXG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcclxuICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpdCgvIC8pO1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGVsc2UgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XHJcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XHJcbiAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF0pIHtcclxuICAgICAgICAgIGEgPSBbXTtcclxuICAgICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7IGogIT09IGpfZW5kOyBqICs9IDEpXHJcbiAgICAgICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdW2pdLmhhbmRsZXIgIT09IGhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgYS5wdXNoKF9oYW5kbGVyc1tldmVudF1bal0pO1xyXG5cclxuICAgICAgICAgIF9oYW5kbGVyc1tldmVudF0gPSBhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF0gJiYgX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2V2ZW50XTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlXHJcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSlcclxuICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2VBcnJheVtpXV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlcyBlYWNoIGhhbmRsZXIgYm91bmQgdG8gdGhlIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgc3BhY2VzKS5cclxuICAgKiBAcGFyYW0gIHs/T2JqZWN0fSBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFJldHVybnMgY29ucmFkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9kaXNwYXRjaChldmVudHMsIGRhdGEpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGosXHJcbiAgICAgICAgaV9lbmQsXHJcbiAgICAgICAgal9lbmQsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgZXZlbnROYW1lLFxyXG4gICAgICAgIGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XHJcbiAgICAgICAgICAgICAgICAgICBldmVudHMgOlxyXG4gICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XHJcblxyXG4gICAgZGF0YSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHt9IDogZGF0YTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcclxuICAgICAgZXZlbnROYW1lID0gZUFycmF5W2ldO1xyXG5cclxuICAgICAgaWYgKF9oYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgZXZlbnQgPSB7XHJcbiAgICAgICAgICB0eXBlOiBldmVudE5hbWUsXHJcbiAgICAgICAgICBkYXRhOiBkYXRhIHx8IHt9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMCwgal9lbmQgPSBfaGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7IGogIT09IGpfZW5kOyBqICs9IDEpXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBfaGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVzIHRoZSBtb3N0IHByaW9yaXRhcnkgam9iIG9uY2UsIGFuZCBkZWFscyB3aXRoIGZpbGxpbmcgdGhlIHN0YXRzXHJcbiAgICogKGRvbmUsIHRpbWUsIGF2ZXJhZ2VUaW1lLCBjdXJyZW50VGltZSwgZXRjLi4uKS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgaGFzIHRvIGJlIGtpbGxlZCwgbnVsbCBlbHNlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9leGVjdXRlRmlyc3RKb2IoKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIHRlc3QsXHJcbiAgICAgICAga2lsbCxcclxuICAgICAgICBwdXNoZWQgPSBmYWxzZSxcclxuICAgICAgICB0aW1lID0gX19kYXRlTm93KCksXHJcbiAgICAgICAgam9iID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNoaWZ0KCk7XHJcblxyXG4gICAgLy8gRXhlY3V0ZSB0aGUgam9iIGFuZCBsb29rIGF0IHRoZSByZXN1bHQ6XHJcbiAgICB0ZXN0ID0gam9iLmpvYigpO1xyXG5cclxuICAgIC8vIERlYWwgd2l0aCBzdGF0czpcclxuICAgIHRpbWUgPSBfX2RhdGVOb3coKSAtIHRpbWU7XHJcbiAgICBqb2IuZG9uZSsrO1xyXG4gICAgam9iLnRpbWUgKz0gdGltZTtcclxuICAgIGpvYi5jdXJyZW50VGltZSArPSB0aW1lO1xyXG4gICAgam9iLndlaWdodFRpbWUgPSBqb2IuY3VycmVudFRpbWUgLyAoam9iLndlaWdodCB8fCAxKTtcclxuICAgIGpvYi5hdmVyYWdlVGltZSA9IGpvYi50aW1lIC8gam9iLmRvbmU7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGpvYiBoYXMgdG8gYmUga2lsbGVkOlxyXG4gICAga2lsbCA9IGpvYi5jb3VudCA/IChqb2IuY291bnQgPD0gam9iLmRvbmUpIDogIXRlc3Q7XHJcblxyXG4gICAgLy8gUmVzZXQgcHJpb3JpdGllczpcclxuICAgIGlmICgha2lsbCkge1xyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICBpZiAoX3NvcnRlZEJ5UHJpb3JpdHlKb2JzW2ldLndlaWdodFRpbWUgPiBqb2Iud2VpZ2h0VGltZSkge1xyXG4gICAgICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNwbGljZShpLCAwLCBqb2IpO1xyXG4gICAgICAgICAgcHVzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcHVzaGVkKVxyXG4gICAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGtpbGwgPyBqb2IgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWN0aXZhdGVzIGEgam9iLCBieSBhZGRpbmcgaXQgdG8gdGhlIF9ydW5uaW5nSm9icyBvYmplY3QgYW5kIHRoZVxyXG4gICAqIF9zb3J0ZWRCeVByaW9yaXR5Sm9icyBhcnJheS4gSXQgYWxzbyBpbml0aWFsaXplcyBpdHMgY3VycmVudFRpbWUgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGpvYiBUaGUgam9iIHRvIGFjdGl2YXRlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9hY3RpdmF0ZUpvYihqb2IpIHtcclxuICAgIHZhciBsID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcnVubmluZyBqb2JzOlxyXG4gICAgX3J1bm5pbmdKb2JzW2pvYi5pZF0gPSBqb2I7XHJcbiAgICBqb2Iuc3RhdHVzID0gJ3J1bm5pbmcnO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgam9iIHRvIHRoZSBwcmlvcml0aWVzOlxyXG4gICAgaWYgKGwpIHtcclxuICAgICAgam9iLndlaWdodFRpbWUgPSBfc29ydGVkQnlQcmlvcml0eUpvYnNbbCAtIDFdLndlaWdodFRpbWU7XHJcbiAgICAgIGpvYi5jdXJyZW50VGltZSA9IGpvYi53ZWlnaHRUaW1lICogKGpvYi53ZWlnaHQgfHwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgam9iIGFuZCBkaXNwYXRjaDpcclxuICAgIGpvYi5zdGFydFRpbWUgPSBfX2RhdGVOb3coKTtcclxuICAgIF9kaXNwYXRjaCgnam9iU3RhcnRlZCcsIF9fY2xvbmUoam9iKSk7XHJcblxyXG4gICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnB1c2goam9iKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBtYWluIGxvb3Agb2YgY29ucmFkLmpzOlxyXG4gICAqICAuIEl0IGV4ZWN1dGVzIGpvYiBzdWNoIHRoYXQgdGhleSBhbGwgb2NjdXBhdGUgdGhlIHNhbWUgcHJvY2Vzc2luZyB0aW1lLlxyXG4gICAqICAuIEl0IHN0b3BzIGpvYnMgdGhhdCBkbyBub3QgbmVlZCB0byBiZSBleGVjdXRlZCBhbnltb3JlLlxyXG4gICAqICAuIEl0IHRyaWdnZXJzIGNhbGxiYWNrcyB3aGVuIGl0IGlzIHJlbGV2YW50LlxyXG4gICAqICAuIEl0IHN0YXJ0cyB3YWl0aW5nIGpvYnMgd2hlbiB0aGV5IG5lZWQgdG8gYmUgc3RhcnRlZC5cclxuICAgKiAgLiBJdCBpbmplY3RzIGZyYW1lcyB0byBrZWVwIGEgY29uc3RhbnQgZnJhcGVzIHBlciBzZWNvbmQgcmF0aW8uXHJcbiAgICogIC4gSXQgc3RvcHMgaXRzZWxmIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgam9icyB0byBleGVjdXRlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9sb29wKCkge1xyXG4gICAgdmFyIGssXHJcbiAgICAgICAgbyxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGpvYixcclxuICAgICAgICB0aW1lLFxyXG4gICAgICAgIGRlYWRKb2I7XHJcblxyXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBuZXdseSBhZGRlZCBqb2JzICh0aGUgX2pvYnMgb2JqZWN0KTpcclxuICAgIGZvciAoayBpbiBfam9icykge1xyXG4gICAgICBqb2IgPSBfam9ic1trXTtcclxuXHJcbiAgICAgIGlmIChqb2IuYWZ0ZXIpXHJcbiAgICAgICAgX3dhaXRpbmdKb2JzW2tdID0gam9iO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgX2FjdGl2YXRlSm9iKGpvYik7XHJcblxyXG4gICAgICBkZWxldGUgX2pvYnNba107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IHRoZSBfaXNSdW5uaW5nIGZsYWcgdG8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIHJ1bm5pbmcgam9iOlxyXG4gICAgX2lzUnVubmluZyA9ICEhX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBEZWFsIHdpdGggdGhlIHJ1bm5pbmcgam9icyAodGhlIF9ydW5uaW5nSm9icyBvYmplY3QpOlxyXG4gICAgd2hpbGUgKFxyXG4gICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoICYmXHJcbiAgICAgIF9fZGF0ZU5vdygpIC0gX2xhc3RGcmFtZVRpbWUgPCBfcGFyYW1ldGVycy5mcmFtZUR1cmF0aW9uXHJcbiAgICApIHtcclxuICAgICAgZGVhZEpvYiA9IF9leGVjdXRlRmlyc3RKb2IoKTtcclxuXHJcbiAgICAgIC8vIERlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSB0aGUgam9iIGhhcyBlbmRlZDpcclxuICAgICAgaWYgKGRlYWRKb2IpIHtcclxuICAgICAgICBfa2lsbEpvYihkZWFkSm9iLmlkKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHdhaXRpbmcgam9iczpcclxuICAgICAgICBmb3IgKGsgaW4gX3dhaXRpbmdKb2JzKVxyXG4gICAgICAgICAgaWYgKF93YWl0aW5nSm9ic1trXS5hZnRlciA9PT0gZGVhZEpvYi5pZCkge1xyXG4gICAgICAgICAgICBfYWN0aXZhdGVKb2IoX3dhaXRpbmdKb2JzW2tdKTtcclxuICAgICAgICAgICAgZGVsZXRlIF93YWl0aW5nSm9ic1trXTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIGNvbnJhZCBzdGlsbCBoYXMgam9icyB0byBkZWFsIHdpdGgsIGFuZCBraWxsIGl0IGlmIG5vdDpcclxuICAgIGlmIChfaXNSdW5uaW5nKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XHJcbiAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XHJcblxyXG4gICAgICBfZGlzcGF0Y2goJ2VudGVyRnJhbWUnKTtcclxuICAgICAgc2V0VGltZW91dChfbG9vcCwgMCk7XHJcbiAgICB9IGVsc2VcclxuICAgICAgX2Rpc3BhdGNoKCdzdG9wJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIG9uZSBvciBtb3JlIGpvYnMsIGFuZCBzdGFydHMgdGhlIGxvb3AgaWYgbm8gam9iIHdhcyBydW5uaW5nIGJlZm9yZS4gQVxyXG4gICAqIGpvYiBpcyBhdCBsZWFzdCBhIHVuaXF1ZSBzdHJpbmcgXCJpZFwiIGFuZCBhIGZ1bmN0aW9uLCBhbmQgdGhlcmUgYXJlIHNvbWVcclxuICAgKiBwYXJhbWV0ZXJzIHRoYXQgeW91IGNhbiBzcGVjaWZ5IGZvciBlYWNoIGpvYiB0byBtb2RpZnkgdGhlIHdheSBjb25yYWQgd2lsbFxyXG4gICAqIGV4ZWN1dGUgaXQuIElmIGEgam9iIGlzIGFkZGVkIHdpdGggdGhlIFwiaWRcIiBvZiBhbm90aGVyIGpvYiB0aGF0IGlzIHdhaXRpbmdcclxuICAgKiBvciBzdGlsbCBydW5uaW5nLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cclxuICAgKlxyXG4gICAqIFdoZW4gYSBqb2IgaXMgYWRkZWQsIGl0IGlzIHJlZmVyZW5jZWQgaW4gdGhlIF9qb2JzIG9iamVjdCwgYnkgaXRzIGlkLlxyXG4gICAqIFRoZW4sIGlmIGl0IGhhcyB0byBiZSBleGVjdXRlZCByaWdodCBub3csIGl0IHdpbGwgYmUgYWxzbyByZWZlcmVuY2VkIGluXHJcbiAgICogdGhlIF9ydW5uaW5nSm9icyBvYmplY3QuIElmIGl0IGhhcyB0byB3YWl0LCB0aGVuIGl0IHdpbGwgYmUgYWRkZWQgaW50byB0aGVcclxuICAgKiBfd2FpdGluZ0pvYnMgb2JqZWN0LCB1bnRpbCBpdCBjYW4gc3RhcnQuXHJcbiAgICpcclxuICAgKiBLZWVwIHJlYWRpbmcgdGhpcyBkb2N1bWVudGF0aW9uIHRvIHNlZSBob3cgdG8gY2FsbCB0aGlzIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXHJcbiAgICpcclxuICAgKiBBZGRpbmcgb25lIGpvYjpcclxuICAgKiAqKioqKioqKioqKioqKipcclxuICAgKiBCYXNpY2FsbHksIGEgam9iIGlzIGRlZmluZWQgYnkgaXRzIHN0cmluZyBpZCBhbmQgYSBmdW5jdGlvbiAodGhlIGpvYikuIEl0XHJcbiAgICogaXMgYWxzbyBwb3NzaWJsZSB0byBhZGQgc29tZSBwYXJhbWV0ZXJzOlxyXG4gICAqXHJcbiAgICogID4gY29ucmFkLmFkZEpvYignbXlKb2JJZCcsIG15Sm9iRnVuY3Rpb24pO1xyXG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCB7XHJcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXHJcbiAgICogID4gICBzb21lUGFyYW1ldGVyOiBzb21lVmFsdWVcclxuICAgKiAgPiB9KTtcclxuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcclxuICAgKiAgPiAgIGlkOiAnbXlKb2JJZCcsXHJcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXHJcbiAgICogID4gICBzb21lUGFyYW1ldGVyOiBzb21lVmFsdWVcclxuICAgKiAgPiB9KTtcclxuICAgKlxyXG4gICAqIEFkZGluZyBzZXZlcmFsIGpvYnM6XHJcbiAgICogKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBXaGVuIGFkZGluZyBzZXZlcmFsIGpvYnMgYXQgdGhlIHNhbWUgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeVxyXG4gICAqIHBhcmFtZXRlcnMgZm9yIGVhY2ggb25lIGluZGl2aWR1YWxseSBvciBmb3IgYWxsOlxyXG4gICAqXHJcbiAgICogID4gY29ucmFkLmFkZEpvYihbXHJcbiAgICogID4gICB7XHJcbiAgICogID4gICAgIGlkOiAnbXlKb2JJZDEnLFxyXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24xLFxyXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMTogc29tZVZhbHVlMVxyXG4gICAqICA+ICAgfSxcclxuICAgKiAgPiAgIHtcclxuICAgKiAgPiAgICAgaWQ6ICdteUpvYklkMicsXHJcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjIsXHJcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIyOiBzb21lVmFsdWUyXHJcbiAgICogID4gICB9XHJcbiAgICogID4gXSwge1xyXG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXHJcbiAgICogID4gfSk7XHJcbiAgICogID4gY29ucmFkLmFkZEpvYih7XHJcbiAgICogID4gICBteUpvYklkMTogeyxcclxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMSxcclxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjE6IHNvbWVWYWx1ZTFcclxuICAgKiAgPiAgIH0sXHJcbiAgICogID4gICBteUpvYklkMjogeyxcclxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMixcclxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjI6IHNvbWVWYWx1ZTJcclxuICAgKiAgPiAgIH1cclxuICAgKiAgPiB9LCB7XHJcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcclxuICAgKiAgPiB9KTtcclxuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcclxuICAgKiAgPiAgIG15Sm9iSWQxOiBteUpvYkZ1bmN0aW9uMSxcclxuICAgKiAgPiAgIG15Sm9iSWQyOiBteUpvYkZ1bmN0aW9uMlxyXG4gICAqICA+IH0sIHtcclxuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxyXG4gICAqICA+IH0pO1xyXG4gICAqXHJcbiAgICogIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcclxuICAgKiAgKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAqICBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVyczpcclxuICAgKlxyXG4gICAqICAgIHs/RnVuY3Rpb259IGVuZCAgICAgIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBqb2IgaXMgZW5kZWQuIEl0IGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgbm90IGV4ZWN1dGVkIGlmIHRoZSBqb2IgaXMga2lsbGVkIGluc3RlYWQgb2YgZW5kZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hdHVyYWxseVwiLlxyXG4gICAqICAgIHs/SW50ZWdlcn0gIGNvdW50ICAgIFRoZSBudW1iZXIgb2YgdGltZSB0aGUgam9iIGhhcyB0byBiZSBleGVjdXRlZC5cclxuICAgKiAgICB7P051bWJlcn0gICB3ZWlnaHQgICBJZiBzcGVjaWZpZWQsIHRoZSBqb2Igd2lsbCBiZSBleGVjdXRlZCBhcyBpdCB3YXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCBcIndlaWdodFwiIHRpbWVzLlxyXG4gICAqICAgIHs/U3RyaW5nfSAgIGFmdGVyICAgIFRoZSBpZCBvZiBhbm90aGVyIGpvYiAoZXZlbnR1YWxseSBub3QgYWRkZWQgeWV0KS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBzcGVjaWZpZWQsIHRoaXMgam9iIHdpbGwgc3RhcnQgb25seSB3aGVuIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCBcImFmdGVyXCIgam9iIGlzIGVuZGVkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9hZGRKb2IodjEsIHYyKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIG87XHJcblxyXG4gICAgLy8gQXJyYXkgb2Ygam9iczpcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSkge1xyXG4gICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XHJcbiAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgX2FkZEpvYih2MVtpXS5pZCwgX19leHRlbmQodjFbaV0sIHYyKSk7XHJcblxyXG4gICAgICBfbm9TdGFydCA9IGZhbHNlO1xyXG4gICAgICBpZiAoIV9pc1J1bm5pbmcpIHtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxyXG4gICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XHJcblxyXG4gICAgICAgIF9kaXNwYXRjaCgnc3RhcnQnKTtcclxuICAgICAgICBfbG9vcCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgLy8gT25lIGpvYiAob2JqZWN0KTpcclxuICAgICAgaWYgKHR5cGVvZiB2MS5pZCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgX2FkZEpvYih2MS5pZCwgdjEpO1xyXG5cclxuICAgICAgLy8gSGFzaCBvZiBqb2JzOlxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XHJcbiAgICAgICAgX25vU3RhcnQgPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKGkgaW4gdjEpXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHYxW2ldID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICBfYWRkSm9iKGksIF9fZXh0ZW5kKHtcclxuICAgICAgICAgICAgICBqb2I6IHYxW2ldXHJcbiAgICAgICAgICAgIH0sIHYyKSk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQodjFbaV0sIHYyKSk7XHJcblxyXG4gICAgICAgIF9ub1N0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxyXG4gICAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcclxuXHJcbiAgICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XHJcbiAgICAgICAgICBfbG9vcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIC8vIE9uZSBqb2IgKHN0cmluZywgKik6XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKF9oYXNKb2IodjEpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICdbY29ucmFkLmFkZEpvYl0gSm9iIHdpdGggaWQgXCInICsgdjEgKyAnXCIgYWxyZWFkeSBleGlzdHMuJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAvLyBPbmUgam9iIChzdHJpbmcsIGZ1bmN0aW9uKTpcclxuICAgICAgaWYgKHR5cGVvZiB2MiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG8gPSB7XHJcbiAgICAgICAgICBpZDogdjEsXHJcbiAgICAgICAgICBkb25lOiAwLFxyXG4gICAgICAgICAgdGltZTogMCxcclxuICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxyXG4gICAgICAgICAgY3VycmVudFRpbWU6IDAsXHJcbiAgICAgICAgICBhdmVyYWdlVGltZTogMCxcclxuICAgICAgICAgIHdlaWdodFRpbWU6IDAsXHJcbiAgICAgICAgICBqb2I6IHYyXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgIC8vIE9uZSBqb2IgKHN0cmluZywgb2JqZWN0KTpcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdjIgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgbyA9IF9fZXh0ZW5kKFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogdjEsXHJcbiAgICAgICAgICAgIGRvbmU6IDAsXHJcbiAgICAgICAgICAgIHRpbWU6IDAsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxyXG4gICAgICAgICAgICBjdXJyZW50VGltZTogMCxcclxuICAgICAgICAgICAgYXZlcmFnZVRpbWU6IDAsXHJcbiAgICAgICAgICAgIHdlaWdodFRpbWU6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB2MlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcclxuICAgICAgfSBlbHNlXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmFkZEpvYl0gV3JvbmcgYXJndW1lbnRzLicpO1xyXG5cclxuICAgICAgLy8gRWZmZWN0aXZlbHkgYWRkIHRoZSBqb2I6XHJcbiAgICAgIF9qb2JzW3YxXSA9IG87XHJcbiAgICAgIF9kaXNwYXRjaCgnam9iQWRkZWQnLCBfX2Nsb25lKG8pKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBsb29wIGhhcyB0byBiZSBzdGFydGVkOlxyXG4gICAgICBpZiAoIV9pc1J1bm5pbmcgJiYgIV9ub1N0YXJ0KSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcclxuICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xyXG5cclxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XHJcbiAgICAgICAgX2xvb3AoKTtcclxuICAgICAgfVxyXG5cclxuICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxyXG4gICAgfSBlbHNlXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEtpbGxzIG9uZSBvciBtb3JlIGpvYnMsIGluZGljYXRlZCBieSB0aGVpciBpZHMuIEl0IGlzIG9ubHkgcG9zc2libGUgdG9cclxuICAgKiBraWxsIHJ1bm5pbmcgam9icyBvciB3YWl0aW5nIGpvYnMuIElmIHlvdSB0cnkgdG8ga2lsbCBhIGpvYiB0aGF0IGRvZXMgbm90XHJcbiAgICogZXhpc3RzIG9yIHRoYXQgaXMgYWxyZWFkeSBraWxsZWQsIGEgd2FybmluZyB3aWxsIGJlIHRocm93bi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0FycmF5fFN0cmluZ30gdjEgQSBzdHJpbmcgam9iIGlkIG9yIGFuIGFycmF5IG9mIGpvYiBpZHMuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBSZXR1cm5zIGNvbnJhZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfa2lsbEpvYih2MSkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBrLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgam9iLFxyXG4gICAgICAgIGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgLy8gQXJyYXkgb2Ygam9iIGlkczpcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSlcclxuICAgICAgZm9yIChpID0gMCwgbCA9IHYxLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICBfa2lsbEpvYih2MVtpXSk7XHJcblxyXG4gICAgLy8gT25lIGpvYidzIGlkOlxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHYxID09PSAnc3RyaW5nJykge1xyXG4gICAgICBhID0gW19ydW5uaW5nSm9icywgX3dhaXRpbmdKb2JzLCBfam9ic107XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdGhlIGpvYiBmcm9tIHRoZSBoYXNoZXM6XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICBpZiAodjEgaW4gYVtpXSkge1xyXG4gICAgICAgICAgam9iID0gYVtpXVt2MV07XHJcblxyXG4gICAgICAgICAgaWYgKF9wYXJhbWV0ZXJzLmhpc3RvcnkpIHtcclxuICAgICAgICAgICAgam9iLnN0YXR1cyA9ICdkb25lJztcclxuICAgICAgICAgICAgX2RvbmVKb2JzLnB1c2goam9iKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBfZGlzcGF0Y2goJ2pvYkVuZGVkJywgX19jbG9uZShqb2IpKTtcclxuICAgICAgICAgIGRlbGV0ZSBhW2ldW3YxXTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGpvYi5lbmQgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIGpvYi5lbmQoKTtcclxuXHJcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRoZSBwcmlvcml0aWVzIGFycmF5OlxyXG4gICAgICBhID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzO1xyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKGFbaV0uaWQgPT09IHYxKSB7XHJcbiAgICAgICAgICBhLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZm91bmQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIEpvYiBcIicgKyB2MSArICdcIiBub3QgZm91bmQuJyk7XHJcblxyXG4gICAgLy8gSWYgbm9uZSBvZiB0aG9zZSBjYXNlcywgdGhyb3cgYW4gZXJyb3I6XHJcbiAgICB9IGVsc2VcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEtpbGxzIGV2ZXJ5IHJ1bm5pbmcsIHdhaXRpbmcsIGFuZCBqdXN0IGFkZGVkIGpvYnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9raWxsQWxsKCkge1xyXG4gICAgdmFyIGssXHJcbiAgICAgICAgam9icyA9IF9fZXh0ZW5kKF9qb2JzLCBfcnVubmluZ0pvYnMsIF93YWl0aW5nSm9icyk7XHJcblxyXG4gICAgLy8gVGFrZSBldmVyeSBqb2JzIGFuZCBwdXNoIHRoZW0gaW50byB0aGUgX2RvbmVKb2JzIG9iamVjdDpcclxuICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KVxyXG4gICAgICBmb3IgKGsgaW4gam9icykge1xyXG4gICAgICAgIGpvYnNba10uc3RhdHVzID0gJ2RvbmUnO1xyXG4gICAgICAgIF9kb25lSm9icy5wdXNoKGpvYnNba10pO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGpvYnNba10uZW5kID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgam9ic1trXS5lbmQoKTtcclxuICAgICAgfVxyXG5cclxuICAgIC8vIFJlaW5pdGlhbGl6ZSB0aGUgZGlmZmVyZW50IGpvYnMgbGlzdHM6XHJcbiAgICBfam9icyA9IHt9O1xyXG4gICAgX3dhaXRpbmdKb2JzID0ge307XHJcbiAgICBfcnVubmluZ0pvYnMgPSB7fTtcclxuICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icyA9IFtdO1xyXG5cclxuICAgIC8vIEluIGNhc2Ugc29tZSBqb2JzIGFyZSBhZGRlZCByaWdodCBhZnRlciB0aGUga2lsbDpcclxuICAgIF9pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGpvYiB3aXRoIHRoZSBzcGVjaWZpZWQgaWQgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3JcclxuICAgKiB3YWl0aW5nLCBhbmQgZmFsc2UgZWxzZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIGlkIFRoZSBpZCBvZiB0aGUgam9iLlxyXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgZXhpc3RzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9oYXNKb2IoaWQpIHtcclxuICAgIHZhciBqb2IgPSBfam9ic1tpZF0gfHwgX3J1bm5pbmdKb2JzW2lkXSB8fCBfd2FpdGluZ0pvYnNbaWRdO1xyXG4gICAgcmV0dXJuIGpvYiA/IF9fZXh0ZW5kKGpvYikgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBzZXQgdGhlIHNldHRpbmcgc3BlY2lmaWVkIGJ5IFwidjFcIiB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXHJcbiAgICogYnkgXCJ2MlwiIGlmIGJvdGggYXJlIGdpdmVuLCBhbmQgZWxzZSByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlXHJcbiAgICogc2V0dGluZ3MgXCJ2MVwiLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIHYxIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cclxuICAgKiBAcGFyYW0gIHs/Kn0gICAgICAgdjIgRXZlbnR1YWxseSwgYSB2YWx1ZSB0byBzZXQgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R8Kn0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIHZhbHVlIGlmIFwidjJcIiBpcyBub3RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgZ2l2ZW4sIGFuZCBjb25yYWQgZWxzZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfc2V0dGluZ3ModjEsIHYyKSB7XHJcbiAgICB2YXIgbztcclxuXHJcbiAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKVxyXG4gICAgICByZXR1cm4gX3BhcmFtZXRlcnNbYTFdO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIG8gPSAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSA/XHJcbiAgICAgICAgYTEgfHwge30gOlxyXG4gICAgICAgIHt9O1xyXG4gICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcclxuICAgICAgICBvW2ExXSA9IGEyO1xyXG5cclxuICAgICAgZm9yICh2YXIgayBpbiBvKVxyXG4gICAgICAgIGlmIChvW2tdICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBfcGFyYW1ldGVyc1trXSA9IG9ba107XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgZGVsZXRlIF9wYXJhbWV0ZXJzW2tdO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29ucmFkIGlzIGN1cnJlbnRseSBydW5uaW5nLCBhbmQgZmFsc2UgZWxzZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgX2lzUnVubmluZy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfZ2V0SXNSdW5uaW5nKCkge1xyXG4gICAgcmV0dXJuIF9pc1J1bm5pbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbnJlZmVyZW5jZSBldmVyeSBqb2JzIHRoYXQgYXJlIHN0b3JlZCBpbiB0aGUgX2RvbmVKb2JzIG9iamVjdC4gSXQgd2lsbFxyXG4gICAqIG5vdCBiZSBwb3NzaWJsZSBhbnltb3JlIHRvIGdldCBzdGF0cyBhYm91dCB0aGVzZSBqb2JzLCBidXQgaXQgd2lsbCByZWxlYXNlXHJcbiAgICogdGhlIG1lbW9yeS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2NsZWFySGlzdG9yeSgpIHtcclxuICAgIF9kb25lSm9icyA9IFtdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgZXZlcnkgZGF0YSBhYm91dCBqb2JzIHRoYXQgd2FpdCB0byBiZSBzdGFydGVkLCBhcmVcclxuICAgKiBjdXJyZW50bHkgcnVubmluZyBvciBhcmUgZG9uZS5cclxuICAgKlxyXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIGdldCBvbmx5IHJ1bm5pbmcsIHdhaXRpbmcgb3IgZG9uZSBqb2JzIGJ5IGdpdmluZ1xyXG4gICAqIFwicnVubmluZ1wiLCBcIndhaXRpbmdcIiBvciBcImRvbmVcIiBhcyBmaXN0IGFyZ3VtZW50LlxyXG4gICAqXHJcbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBnZXQgZXZlcnkgam9iIHdpdGggYSBzcGVjaWZpZWQgaWQgYnkgZ2l2aW5nIGl0IGFzXHJcbiAgICogZmlyc3QgYXJndW1lbnQuIEFsc28sIHVzaW5nIGEgUmVnRXhwIGluc3RlYWQgb2YgYW4gaWQgd2lsbCByZXR1cm4gZXZlcnlcclxuICAgKiBqb2JzIHdob3NlIGlkcyBtYXRjaCB0aGUgUmVnRXhwLiBBbmQgdGhlc2UgdHdvIGxhc3QgdXNlIGNhc2VzIHdvcmsgYXMgd2VsbFxyXG4gICAqIGJ5IGdpdmluZyBiZWZvcmUgXCJydW5uaW5nXCIsIFwid2FpdGluZ1wiIG9yIFwiZG9uZVwiLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBhcnJheSBvZiB0aGUgbWF0Y2hpbmcgam9icy5cclxuICAgKlxyXG4gICAqIFNvbWUgY2FsbCBleGFtcGxlczpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqXHJcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJylcclxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3dhaXRpbmcnKVxyXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygnZG9uZScpXHJcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdteUpvYicpXHJcbiAgICogID4gY29ucmFkLmdldFN0YXRzKC90ZXN0LylcclxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnLCAnbXlSdW5uaW5nSm9iJylcclxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnLCAvdGVzdC8pXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2dldFN0YXRzKHYxLCB2Mikge1xyXG4gICAgdmFyIGEsXHJcbiAgICAgICAgayxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgc3RhdHMsXHJcbiAgICAgICAgcGF0dGVybixcclxuICAgICAgICBpc1BhdHRlcm5TdHJpbmc7XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHN0YXRzID0gW107XHJcblxyXG4gICAgICBmb3IgKGsgaW4gX2pvYnMpXHJcbiAgICAgICAgc3RhdHMucHVzaChfam9ic1trXSk7XHJcblxyXG4gICAgICBmb3IgKGsgaW4gX3dhaXRpbmdKb2JzKVxyXG4gICAgICAgIHN0YXRzLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcclxuXHJcbiAgICAgIGZvciAoayBpbiBfcnVubmluZ0pvYnMpXHJcbiAgICAgICAgc3RhdHMucHVzaChfcnVubmluZ0pvYnNba10pO1xyXG5cclxuICAgICAgc3RhdHMgPSBzdGF0cy5jb25jYXQoX2RvbmVKb2JzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHYxID09PSAnc3RyaW5nJylcclxuICAgICAgc3dpdGNoICh2MSkge1xyXG4gICAgICAgIGNhc2UgJ3dhaXRpbmcnOlxyXG4gICAgICAgICAgc3RhdHMgPSBfX29iamVjdFZhbHVlcyhfd2FpdGluZ0pvYnMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncnVubmluZyc6XHJcbiAgICAgICAgICBzdGF0cyA9IF9fb2JqZWN0VmFsdWVzKF9ydW5uaW5nSm9icyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkb25lJzpcclxuICAgICAgICAgIHN0YXRzID0gX2RvbmVKb2JzO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHBhdHRlcm4gPSB2MTtcclxuICAgICAgfVxyXG5cclxuICAgIGlmICh2MSBpbnN0YW5jZW9mIFJlZ0V4cClcclxuICAgICAgcGF0dGVybiA9IHYxO1xyXG5cclxuICAgIGlmICghcGF0dGVybiAmJiAodHlwZW9mIHYyID09PSAnc3RyaW5nJyB8fCB2MiBpbnN0YW5jZW9mIFJlZ0V4cCkpXHJcbiAgICAgIHBhdHRlcm4gPSB2MjtcclxuXHJcbiAgICAvLyBGaWx0ZXIgam9icyBpZiBhIHBhdHRlcm4gaXMgZ2l2ZW46XHJcbiAgICBpZiAocGF0dGVybikge1xyXG4gICAgICBpc1BhdHRlcm5TdHJpbmcgPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZyc7XHJcblxyXG4gICAgICBpZiAoc3RhdHMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIGEgPSBzdGF0cztcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgYSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGsgaW4gc3RhdHMpXHJcbiAgICAgICAgICBhID0gYS5jb25jYXQoc3RhdHNba10pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGEgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChrIGluIF9qb2JzKVxyXG4gICAgICAgICAgYS5wdXNoKF9qb2JzW2tdKTtcclxuXHJcbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcclxuICAgICAgICAgIGEucHVzaChfd2FpdGluZ0pvYnNba10pO1xyXG5cclxuICAgICAgICBmb3IgKGsgaW4gX3J1bm5pbmdKb2JzKVxyXG4gICAgICAgICAgYS5wdXNoKF9ydW5uaW5nSm9ic1trXSk7XHJcblxyXG4gICAgICAgIGEgPSBhLmNvbmNhdChfZG9uZUpvYnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdGF0cyA9IFtdO1xyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKGlzUGF0dGVyblN0cmluZyA/IGFbaV0uaWQgPT09IHBhdHRlcm4gOiBhW2ldLmlkLm1hdGNoKHBhdHRlcm4pKVxyXG4gICAgICAgICAgc3RhdHMucHVzaChhW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX19jbG9uZShzdGF0cyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVE9PTFMgRlVOQ1RJT05TOlxyXG4gICAqICoqKioqKioqKioqKioqKipcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbnkgbnVtYmVyIG9mIG9iamVjdHMgYXMgYXJndW1lbnRzLCBjb3BpZXMgZnJvbSBlYWNoXHJcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxyXG4gICAqIHJldHVybnMgdGhpcyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XHJcbiAgICogd2hlbiB0d28gb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxyXG4gICAqXHJcbiAgICogRXhhbXBsZTpcclxuICAgKiAqKioqKioqKlxyXG4gICAqICA+IHZhciBvMSA9IHtcclxuICAgKiAgPiAgICAgICBhOiAxLFxyXG4gICAqICA+ICAgICAgIGI6IDIsXHJcbiAgICogID4gICAgICAgYzogJzMnXHJcbiAgICogID4gICAgIH0sXHJcbiAgICogID4gICAgIG8yID0ge1xyXG4gICAqICA+ICAgICAgIGM6ICc0JyxcclxuICAgKiAgPiAgICAgICBkOiBbIDUgXVxyXG4gICAqICA+ICAgICB9O1xyXG4gICAqICA+IF9fZXh0ZW5kKG8xLCBvMik7XHJcbiAgICogID4gLy8gUmV0dXJuczoge1xyXG4gICAqICA+IC8vICAgYTogMSxcclxuICAgKiAgPiAvLyAgIGI6IDIsXHJcbiAgICogID4gLy8gICBjOiAnMycsXHJcbiAgICogID4gLy8gICBkOiBbIDUgXVxyXG4gICAqICA+IC8vIH07XHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtPYmplY3QrfSBBbnkgbnVtYmVyIG9mIG9iamVjdHMuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAgVGhlIG1lcmdlZCBvYmplY3QuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX19leHRlbmQoKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBrLFxyXG4gICAgICAgIHJlcyA9IHt9LFxyXG4gICAgICAgIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAoaSA9IGwgLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgZm9yIChrIGluIGFyZ3VtZW50c1tpXSlcclxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGNsb25lcyBhbiBvYmplY3QuIFRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBvbmx5XHJcbiAgICogb2JqZWN0cywgYXJyYXlzIGFuZCBpbW11dGFibGUgdmFsdWVzLiBTaW5jZSBpdCBpcyBub3QgcHVibGljLCBpdCBkb2VzIG5vdFxyXG4gICAqIGRlYWwgd2l0aCBjeWNsaWMgcmVmZXJlbmNlcywgRE9NIGVsZW1lbnRzIGFuZCBpbnN0YW50aWF0ZWQgb2JqZWN0cyAtIHNvXHJcbiAgICogdXNlIGl0IGNhcmVmdWxseS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gVGhlIG9iamVjdCB0byBjbG9uZS5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfX2Nsb25lKGl0ZW0pIHtcclxuICAgIHZhciByZXN1bHQsIGksIGssIGw7XHJcblxyXG4gICAgaWYgKCFpdGVtKVxyXG4gICAgICByZXR1cm4gaXRlbTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xyXG4gICAgICByZXN1bHQgPSBbXTtcclxuICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZW0ubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKF9fY2xvbmUoaXRlbVtpXSkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgIGZvciAoaSBpbiBpdGVtKVxyXG4gICAgICAgIHJlc3VsdFtpXSA9IF9fY2xvbmUoaXRlbVtpXSk7XHJcbiAgICB9IGVsc2VcclxuICAgICAgcmVzdWx0ID0gaXRlbTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBUaGUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge0FycmF5fSAgVGhlIGFycmF5IG9mIHZhbHVlcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfX29iamVjdFZhbHVlcyhvKSB7XHJcbiAgICB2YXIgayxcclxuICAgICAgICBhID0gW107XHJcblxyXG4gICAgZm9yIChrIGluIG8pXHJcbiAgICAgIGEucHVzaChvW2tdKTtcclxuXHJcbiAgICByZXR1cm4gYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgKGluIG1zKS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfX2RhdGVOb3coKSB7XHJcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQb2x5ZmlsbCBmb3IgdGhlIEFycmF5LmlzQXJyYXkgZnVuY3Rpb246XHJcbiAgICovXHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KVxyXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFWFBPUlQgUFVCTElDIEFQSTpcclxuICAgKiAqKioqKioqKioqKioqKioqKipcclxuICAgKi9cclxuICB2YXIgY29ucmFkID0ge1xyXG4gICAgaGFzSm9iOiBfaGFzSm9iLFxyXG4gICAgYWRkSm9iOiBfYWRkSm9iLFxyXG4gICAga2lsbEpvYjogX2tpbGxKb2IsXHJcbiAgICBraWxsQWxsOiBfa2lsbEFsbCxcclxuICAgIHNldHRpbmdzOiBfc2V0dGluZ3MsXHJcbiAgICBnZXRTdGF0czogX2dldFN0YXRzLFxyXG4gICAgaXNSdW5uaW5nOiBfZ2V0SXNSdW5uaW5nLFxyXG4gICAgY2xlYXJIaXN0b3J5OiBfY2xlYXJIaXN0b3J5LFxyXG5cclxuICAgIC8vIEV2ZW50cyBtYW5hZ2VtZW50OlxyXG4gICAgYmluZDogX2JpbmQsXHJcbiAgICB1bmJpbmQ6IF91bmJpbmQsXHJcblxyXG4gICAgLy8gVmVyc2lvbjpcclxuICAgIHZlcnNpb246ICcwLjEuMCdcclxuICB9O1xyXG5cclxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbnJhZDtcclxuICAgIGV4cG9ydHMuY29ucmFkID0gY29ucmFkO1xyXG4gIH1cclxuICBnbG9iYWwuY29ucmFkID0gY29ucmFkO1xyXG59KSh0aGlzKTtcclxuXHJcbi8vIEhhcmRjb2RlZCBleHBvcnQgZm9yIHRoZSBub2RlLmpzIHZlcnNpb246XHJcbnZhciBzaWdtYSA9IHRoaXMuc2lnbWEsXHJcbiAgICBjb25yYWQgPSB0aGlzLmNvbnJhZDtcclxuXHJcbnNpZ21hLmNvbnJhZCA9IGNvbnJhZDtcclxuXHJcbi8vIERpcnR5IHBvbHlmaWxscyB0byBwZXJtaXQgc2lnbWEgdXNhZ2UgaW4gbm9kZVxyXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJylcclxuICBIVE1MRWxlbWVudCA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgd2luZG93ID0ge1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fVxyXG4gIH07XHJcblxyXG5pZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxyXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc2lnbWE7XHJcbiAgZXhwb3J0cy5zaWdtYSA9IHNpZ21hO1xyXG59XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgdmFyIF9yb290ID0gdGhpcztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscyA9IHNpZ21hLnV0aWxzIHx8IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBNSVNDIFVUSUxTOlxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogU2lnbWFNYXAgd3JhcHMgYW4gRVM2IE9iamVjdC4gTWV0aG9kcyBzZXQsIGdldCwgaGFzLCBmb3JFYWNoLCBkZWxldGUsIGFuZCBjbGVhclxyXG4gICAqIGhhdmUgdGhlIHNhbWUgc2lnbmF0dXJlIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgTWFwIG1ldGhvZHMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gU2lnbWFNYXAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgX3N0b3JlO1xyXG5cclxuICAgIGlmICghc2lnbWEuZm9yY2VFUzUgJiZcclxuICAgICAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgTWFwLnByb3RvdHlwZS5rZXlzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoICE9PSB1bmRlZmluZWRcclxuICAgICAgJiYgQXJyYXkuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICBfc3RvcmUgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NpemUnLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIF9zdG9yZS5zaXplOyB9LFxyXG4gICAgICAgIHNldDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgX3N0b3JlLnNldCgnJyArIGtleSwgdmFsdWUpOyB9O1xyXG4gICAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gX3N0b3JlLmdldCgnJyArIGtleSk7IH07XHJcbiAgICAgIHRoaXMuaGFzID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBfc3RvcmUuaGFzKCcnICsga2V5KTsgfTtcclxuICAgICAgdGhpcy5mb3JFYWNoID0gZnVuY3Rpb24oZnVuYykgeyByZXR1cm4gX3N0b3JlLmZvckVhY2goZnVuYyk7IH07XHJcbiAgICAgIHRoaXMuZGVsZXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBfc3RvcmUuZGVsZXRlKCcnICsga2V5KTsgfTtcclxuICAgICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uKCkgeyBfc3RvcmUuY2xlYXIoKTsgfTtcclxuXHJcbiAgICAgIHRoaXMua2V5TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShfc3RvcmUua2V5cygpKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMudmFsdWVMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBfc3RvcmUuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBfc3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICB0aGlzLnNpemUgPSAwO1xyXG5cclxuICAgICAgdGhpcy5rZXlMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhfc3RvcmUpLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgIHJldHVybiBfc3RvcmVba2V5XSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy52YWx1ZUxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfc3RvcmUpO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgdmFsID0gX3N0b3JlW2tleXNbaV1dO1xyXG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKF9zdG9yZVtrZXldID09PSB1bmRlZmluZWQpIHNlbGYuc2l6ZSsrO1xyXG5cclxuICAgICAgICBfc3RvcmVba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdG9yZVtrZXldO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdG9yZVtrZXldICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmZvckVhY2ggPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoX3N0b3JlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLFxyXG4gICAgICAgICAgICAgIG9iaiA9IF9zdG9yZVtrZXldO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBmdW5jKG9iaiwga2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBfc3RvcmVba2V5XTtcclxuICAgICAgICBfc3RvcmVba2V5XSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHNlbGYuc2l6ZS0tO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGsgaW4gX3N0b3JlKVxyXG4gICAgICAgICAgaWYgKCEoJ2hhc093blByb3BlcnR5JyBpbiBfc3RvcmUpIHx8IF9zdG9yZS5oYXNPd25Qcm9wZXJ0eShrKSlcclxuICAgICAgICAgICAgZGVsZXRlIF9zdG9yZVtrXTtcclxuXHJcbiAgICAgICAgX3N0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBzZWxmLnNpemUgPSAwO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2lnbWEudXRpbHMubWFwID0gU2lnbWFNYXA7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFueSBudW1iZXIgb2Ygb2JqZWN0cyBhcyBhcmd1bWVudHMsIGNvcGllcyBmcm9tIGVhY2hcclxuICAgKiBvZiB0aGVzZSBvYmplY3RzIGVhY2ggcGFpciBrZXkvdmFsdWUgaW50byBhIG5ldyBvYmplY3QsIGFuZCBmaW5hbGx5XHJcbiAgICogcmV0dXJucyB0aGlzIG9iamVjdC5cclxuICAgKlxyXG4gICAqIFRoZSBhcmd1bWVudHMgYXJlIHBhcnNlZCBmcm9tIHRoZSBsYXN0IG9uZSB0byB0aGUgZmlyc3Qgb25lLCBzdWNoIHRoYXRcclxuICAgKiB3aGVuIHNldmVyYWwgb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxyXG4gICAqXHJcbiAgICogRXhhbXBsZTpcclxuICAgKiAqKioqKioqKlxyXG4gICAqICA+IHZhciBvMSA9IHtcclxuICAgKiAgPiAgICAgICBhOiAxLFxyXG4gICAqICA+ICAgICAgIGI6IDIsXHJcbiAgICogID4gICAgICAgYzogJzMnXHJcbiAgICogID4gICAgIH0sXHJcbiAgICogID4gICAgIG8yID0ge1xyXG4gICAqICA+ICAgICAgIGM6ICc0JyxcclxuICAgKiAgPiAgICAgICBkOiBbIDUgXVxyXG4gICAqICA+ICAgICB9O1xyXG4gICAqICA+IHNpZ21hLnV0aWxzLmV4dGVuZChvMSwgbzIpO1xyXG4gICAqICA+IC8vIFJldHVybnM6IHtcclxuICAgKiAgPiAvLyAgIGE6IDEsXHJcbiAgICogID4gLy8gICBiOiAyLFxyXG4gICAqICA+IC8vICAgYzogJzMnLFxyXG4gICAqICA+IC8vICAgZDogWyA1IF1cclxuICAgKiAgPiAvLyB9O1xyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gIFRoZSBtZXJnZWQgb2JqZWN0LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgayxcclxuICAgICAgICByZXMgPSB7fSxcclxuICAgICAgICBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgIGZvciAoayBpbiBhcmd1bWVudHNbaV0pXHJcbiAgICAgICAgcmVzW2tdID0gYXJndW1lbnRzW2ldW2tdO1xyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBzaG9ydCBcIkRhdGUubm93KClcIiBwb2x5ZmlsbC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZSAoaW4gbXMpLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmRhdGVOb3cgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUYWtlcyBhIHBhY2thZ2UgbmFtZSBhcyBwYXJhbWV0ZXIgYW5kIGNoZWNrcyBhdCBlYWNoIGxlYmVsIGlmIGl0IGV4aXN0cyxcclxuICAgKiBhbmQgaWYgaXQgZG9lcyBub3QsIGNyZWF0ZXMgaXQuXHJcbiAgICpcclxuICAgKiBFeGFtcGxlOlxyXG4gICAqICoqKioqKioqXHJcbiAgICogID4gc2lnbWEudXRpbHMucGtnKCdhLmIuYycpO1xyXG4gICAqICA+IGEuYi5jO1xyXG4gICAqICA+IC8vIE9iamVjdCB7fTtcclxuICAgKiAgPlxyXG4gICAqICA+IHNpZ21hLnV0aWxzLnBrZygnYS5iLmQnKTtcclxuICAgKiAgPiBhLmI7XHJcbiAgICogID4gLy8gT2JqZWN0IHsgYzoge30sIGQ6IHt9IH07XHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBrZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY3JlYXRlL2ZpbmQuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSByZWxhdGVkIHBhY2thZ2UuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMucGtnID0gZnVuY3Rpb24ocGtnTmFtZSkge1xyXG4gICAgcmV0dXJuIChwa2dOYW1lIHx8ICcnKS5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbihjb250ZXh0LCBvYmpOYW1lKSB7XHJcbiAgICAgIHJldHVybiAob2JqTmFtZSBpbiBjb250ZXh0KSA/XHJcbiAgICAgICAgY29udGV4dFtvYmpOYW1lXSA6XHJcbiAgICAgICAgKGNvbnRleHRbb2JqTmFtZV0gPSB7fSk7XHJcbiAgICB9LCBfcm9vdCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBpbmNyZW1lbnRhbCBudW1iZXIgSUQuXHJcbiAgICpcclxuICAgKiBFeGFtcGxlOlxyXG4gICAqICoqKioqKioqXHJcbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcclxuICAgKiAgPiAvLyAxO1xyXG4gICAqICA+XHJcbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcclxuICAgKiAgPiAvLyAyO1xyXG4gICAqICA+XHJcbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcclxuICAgKiAgPiAvLyAzO1xyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwa2dOYW1lIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGNyZWF0ZS9maW5kLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcmVsYXRlZCBwYWNrYWdlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmlkID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gKytpO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGhleGEgY29sb3IgKGZvciBpbnN0YW5jZSBcIiNmZmNjMDBcIiBvciBcIiNmYzBcIikgb3IgYVxyXG4gICAqIHJnYiAvIHJnYmEgY29sb3IgKGxpa2UgXCJyZ2IoMjU1LDI1NSwxMilcIiBvciBcInJnYmEoMjU1LDI1NSwxMiwxKVwiKSBhbmRcclxuICAgKiByZXR1cm5zIGFuIGludGVnZXIgZXF1YWwgdG8gXCJyICogMjU1ICogMjU1ICsgZyAqIDI1NSArIGJcIiwgdG8gZ2FpbiBzb21lXHJcbiAgICogbWVtb3J5IGluIHRoZSBkYXRhIGdpdmVuIHRvIFdlYkdMIHNoYWRlcnMuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhlIGZ1bmN0aW9uIGFjdHVhbGx5IGNhY2hlcyBpdHMgcmVzdWx0cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWwgVGhlIGhleGEgb3IgcmdiYSBjb2xvci5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICBUaGUgbnVtYmVyIHZhbHVlLlxyXG4gICAqL1xyXG4gIHZhciBmbG9hdENvbG9yQ2FjaGUgPSB7fTtcclxuXHJcbiAgc2lnbWEudXRpbHMuZmxvYXRDb2xvciA9IGZ1bmN0aW9uKHZhbCkge1xyXG5cclxuICAgIC8vIElzIHRoZSBjb2xvciBhbHJlYWR5IGNvbXB1dGVkP1xyXG4gICAgaWYgKGZsb2F0Q29sb3JDYWNoZVt2YWxdKVxyXG4gICAgICByZXR1cm4gZmxvYXRDb2xvckNhY2hlW3ZhbF07XHJcblxyXG4gICAgdmFyIG9yaWdpbmFsID0gdmFsLFxyXG4gICAgICAgIHIgPSAwLFxyXG4gICAgICAgIGcgPSAwLFxyXG4gICAgICAgIGIgPSAwO1xyXG5cclxuICAgIGlmICh2YWxbMF0gPT09ICcjJykge1xyXG4gICAgICB2YWwgPSB2YWwuc2xpY2UoMSk7XHJcblxyXG4gICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpO1xyXG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xyXG4gICAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgyKSwgMTYpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xyXG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpO1xyXG4gICAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDQpICsgdmFsLmNoYXJBdCg1KSwgMTYpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XHJcbiAgICAgIHZhbCA9IHZhbC5tYXRjaChcclxuICAgICAgICAvXiAqcmdiYT8gKlxcKCAqKFswLTldKikgKiwgKihbMC05XSopICosICooWzAtOV0qKSAqKCwuKik/XFwpICokL1xyXG4gICAgICApO1xyXG4gICAgICByID0gK3ZhbFsxXTtcclxuICAgICAgZyA9ICt2YWxbMl07XHJcbiAgICAgIGIgPSArdmFsWzNdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb2xvciA9IChcclxuICAgICAgciAqIDI1NiAqIDI1NiArXHJcbiAgICAgIGcgKiAyNTYgK1xyXG4gICAgICBiXHJcbiAgICApO1xyXG5cclxuICAgIC8vIENhY2hpbmcgdGhlIGNvbG9yXHJcbiAgICBmbG9hdENvbG9yQ2FjaGVbb3JpZ2luYWxdID0gY29sb3I7XHJcblxyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG4gIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICogUGVyZm9ybSBhIHpvb20gaW50byBhIGNhbWVyYSwgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiwgdG8gdGhlXHJcbiAgICogY29vcmRpbmF0ZXMgaW5kaWNhdGVkIHVzaW5nIGEgc3BlY2lmaWVkIHJhdGlvLlxyXG4gICAqXHJcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICogb2JqZWN0OlxyXG4gICAqXHJcbiAgICogICB7P251bWJlcn0gZHVyYXRpb24gICAgIEFuIGFtb3VudCBvZiB0aW1lIHRoYXQgbWVhbnMgdGhlIGR1cmF0aW9uIG9mIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uIElmIHRoaXMgcGFyYW1ldGVyIGRvZXNuJ3QgZXhpc3QgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHpvb20gd2lsbCBiZSBwZXJmb3JtZWQgd2l0aG91dCBhbmltYXRpb24uXHJcbiAgICogICB7P2Z1bmN0aW9ufSBvbkNvbXBsZXRlIEEgZnVuY3Rpb24gdG8gcGVyZm9ybSBpdCBhZnRlciB0aGUgYW5pbWF0aW9uLiBJdFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHBlcmZvcm1lZCBldmVuIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtjYW1lcmF9ICAgICBUaGUgY2FtZXJhIHdoZXJlIHBlcmZvcm0gdGhlIHpvb20uXHJcbiAgICogQHBhcmFtIHt4fSAgICAgICAgICBUaGUgWCBjb29yZGlhbnRpb24gd2hlcmUgdGhlIHpvb20gZ29lcy5cclxuICAgKiBAcGFyYW0ge3l9ICAgICAgICAgIFRoZSBZIGNvb3JkaWFudGlvbiB3aGVyZSB0aGUgem9vbSBnb2VzLlxyXG4gICAqIEBwYXJhbSB7cmF0aW99ICAgICAgVGhlIHJhdGlvIHRvIGFwcGx5IGl0IHRvIHRoZSBjdXJyZW50IGNhbWVyYSByYXRpby5cclxuICAgKiBAcGFyYW0gez9hbmltYXRpb259IEEgZGljdGlvbmFyeSB3aXRoIG9wdGlvbnMgZm9yIGEgcG9zc2libGUgYW5pbWF0aW9uLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLnpvb21UbyA9IGZ1bmN0aW9uKGNhbWVyYSwgeCwgeSwgcmF0aW8sIGFuaW1hdGlvbikge1xyXG4gICAgdmFyIHNldHRpbmdzID0gY2FtZXJhLnNldHRpbmdzLFxyXG4gICAgICAgIGNvdW50LFxyXG4gICAgICAgIG5ld1JhdGlvLFxyXG4gICAgICAgIGFuaW1hdGlvblNldHRpbmdzLFxyXG4gICAgICAgIGNvb3JkaW5hdGVzO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgbmV3UmF0aW8gZGVhbGluZyB3aXRoIG1pbiAvIG1heDpcclxuICAgIG5ld1JhdGlvID0gTWF0aC5tYXgoXHJcbiAgICAgIHNldHRpbmdzKCd6b29tTWluJyksXHJcbiAgICAgIE1hdGgubWluKFxyXG4gICAgICAgIHNldHRpbmdzKCd6b29tTWF4JyksXHJcbiAgICAgICAgY2FtZXJhLnJhdGlvICogcmF0aW9cclxuICAgICAgKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBuZXcgcmF0aW8gaXMgZGlmZmVyZW50IGZyb20gdGhlIGluaXRpYWwgb25lOlxyXG4gICAgaWYgKG5ld1JhdGlvICE9PSBjYW1lcmEucmF0aW8pIHtcclxuICAgICAgLy8gQ3JlYXRlIHRoZSBjb29yZGluYXRlcyB2YXJpYWJsZTpcclxuICAgICAgcmF0aW8gPSBuZXdSYXRpbyAvIGNhbWVyYS5yYXRpbztcclxuICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgeDogeCAqICgxIC0gcmF0aW8pICsgY2FtZXJhLngsXHJcbiAgICAgICAgeTogeSAqICgxIC0gcmF0aW8pICsgY2FtZXJhLnksXHJcbiAgICAgICAgcmF0aW86IG5ld1JhdGlvXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5kdXJhdGlvbikge1xyXG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSBhbmltYXRpb24gc2V0aW5nczpcclxuICAgICAgICBjb3VudCA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwoY2FtZXJhKTtcclxuICAgICAgICBhbmltYXRpb24gPSBzaWdtYS51dGlscy5leHRlbmQoXHJcbiAgICAgICAgICBhbmltYXRpb24sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGVhc2luZzogY291bnQgPyAncXVhZHJhdGljT3V0JyA6ICdxdWFkcmF0aWNJbk91dCdcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoY2FtZXJhLCBjb29yZGluYXRlcywgYW5pbWF0aW9uKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYW1lcmEuZ29Ubyhjb29yZGluYXRlcyk7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24ub25Db21wbGV0ZSlcclxuICAgICAgICAgIGFuaW1hdGlvbi5vbkNvbXBsZXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGNvbnRyb2wgcG9pbnQgY29vcmRpbmF0ZXMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gIHgxICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb2ludC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgcG9pbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgeDIgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MiAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxyXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9IGNjICBUaGUgY3VydmF0dXJlIGNvZWZmaWNpZW50cy5cclxuICAgKiBAcmV0dXJuIHt4LHl9ICAgICAgICAgVGhlIGNvbnRyb2wgcG9pbnQgY29vcmRpbmF0ZXMuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIGNjKSB7XHJcbiAgICBjYyA9IHRoaXMuZXh0ZW5kKGNjLCB7IHg6IDIsIHk6IDQgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiAoeDEgKyB4MikgLyBjYy54ICsgKHkyIC0geTEpIC8gY2MueSxcclxuICAgICAgeTogKHkxICsgeTIpIC8gY2MueCArICh4MSAtIHgyKSAvIGNjLnlcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXHJcbiAgICAqIGF0IGxlbmd0aCB0IGluIHRoZSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQgIEluIFswLDFdIHRoZSBzdGVwIHBlcmNlbnRhZ2UgdG8gcmVhY2hcclxuICAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9pbnQgaW4gdGhlIGN1cnZlIGZyb20gdGhlIGNvbnRleHQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZGluZyBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geGkgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5aSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxyXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9LlxyXG4gICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlID0gZnVuY3Rpb24odCwgeDEsIHkxLCB4MiwgeTIsIHhpLCB5aSkge1xyXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTYzNDUyOFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogKDEgLSB0KSAqICgxIC0gdCkgKiB4MSArIDIgKiAoMSAtIHQpICogdCAqIHhpICsgdCAqIHQgKiB4MixcclxuICAgICAgeTogKDEgLSB0KSAqICgxIC0gdCkgKiB5MSArIDIgKiAoMSAtIHQpICogdCAqIHlpICsgdCAqIHQgKiB5MlxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgICogQ29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IHBvc2l0aW9uZWRcclxuICAgICogYXQgbGVuZ3RoIHQgaW4gdGhlIGN1YmljIGJlemllciBjdXJ2ZS5cclxuICAgICpcclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHBvaW50IGluIHRoZSBjdXJ2ZSBmcm9tIHRoZSBjb250ZXh0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3kgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cclxuICAgICogQHJldHVybiB7b2JqZWN0fSAgICB7eCx5fSBUaGUgcG9pbnQgYXQgdC5cclxuICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldFBvaW50T25CZXppZXJDdXJ2ZSA9XHJcbiAgICBmdW5jdGlvbih0LCB4MSwgeTEsIHgyLCB5MiwgY3gsIGN5LCBkeCwgZHkpIHtcclxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1Mzk3NTk2XHJcbiAgICAvLyBCbGVuZGluZyBmdW5jdGlvbnM6XHJcbiAgICB2YXIgQjBfdCA9ICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KSxcclxuICAgICAgICBCMV90ID0gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KSxcclxuICAgICAgICBCMl90ID0gMyAqIHQgKiB0ICogKDEgLSB0KSxcclxuICAgICAgICBCM190ID0gdCAqIHQgKiB0O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IChCMF90ICogeDEpICsgKEIxX3QgKiBjeCkgKyAoQjJfdCAqIGR4KSArIChCM190ICogeDIpLFxyXG4gICAgICB5OiAoQjBfdCAqIHkxKSArIChCMV90ICogY3kpICsgKEIyX3QgKiBkeSkgKyAoQjNfdCAqIHkyKVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0d28gY29udHJvbCBwb2ludHMgZm9yIGEgc2VsZiBsb29wIChpLmUuXHJcbiAgICogd2hlcmUgdGhlIHN0YXJ0IHBvaW50IGlzIGFsc28gdGhlIGVuZCBwb2ludCkgY29tcHV0ZWQgYXMgYSBjdWJpYyBiZXppZXJcclxuICAgKiBjdXJ2ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geCAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geSAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gc2l6ZSBUaGUgbm9kZSBzaXplLlxyXG4gICAqIEByZXR1cm4ge3gxLHkxLHgyLHkyfSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cy5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbih4ICwgeSwgc2l6ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDE6IHggLSBzaXplICogNyxcclxuICAgICAgeTE6IHksXHJcbiAgICAgIHgyOiB4LFxyXG4gICAgICB5MjogeSArIHNpemUgKiA3XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiBhIHBsYW5lXHJcbiAgICogd2l0aCBhbiBvcnRob25vcm1hbCBiYXNpcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDIgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIGV1Y2xpZGlhbiBkaXN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MSAtIHgwKSAqICh4MSAtIHgwKSArICh5MSAtIHkwKSAqICh5MSAtIHkwKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiB0d28gY2lyY2xlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBmaXJzdFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkwICBUaGUgWSBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgZmlyc3RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSByMCAgVGhlIHJhZGl1cyBvZiB0aGUgZmlyc3QgY2lyY2xlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBzZWNvbmRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIHNlY29uZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHIxICBUaGUgcmFkaXVzIG9mIHRoZSBzZWNvbmQgY2lyY2xlLlxyXG4gICAqIEByZXR1cm4ge3hpLHlpfSAgICAgIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cy5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRDaXJjbGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbih4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XHJcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjIxOTgwMlxyXG4gICAgdmFyIGEsIGR4LCBkeSwgZCwgaCwgcngsIHJ5LCB4MiwgeTI7XHJcblxyXG4gICAgLy8gZHggYW5kIGR5IGFyZSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgZGlzdGFuY2VzIGJldHdlZW4gdGhlIGNpcmNsZVxyXG4gICAgLy8gY2VudGVyczpcclxuICAgIGR4ID0geDEgLSB4MDtcclxuICAgIGR5ID0geTEgLSB5MDtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY2VudGVyczpcclxuICAgIGQgPSBNYXRoLnNxcnQoKGR5ICogZHkpICsgKGR4ICogZHgpKTtcclxuXHJcbiAgICAvLyBDaGVjayBmb3Igc29sdmFiaWxpdHk6XHJcbiAgICBpZiAoZCA+IChyMCArIHIxKSkge1xyXG4gICAgICAgIC8vIE5vIHNvbHV0aW9uLiBjaXJjbGVzIGRvIG5vdCBpbnRlcnNlY3QuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGQgPCBNYXRoLmFicyhyMCAtIHIxKSkge1xyXG4gICAgICAgIC8vIE5vIHNvbHV0aW9uLiBvbmUgY2lyY2xlIGlzIGNvbnRhaW5lZCBpbiB0aGUgb3RoZXIuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vJ3BvaW50IDInIGlzIHRoZSBwb2ludCB3aGVyZSB0aGUgbGluZSB0aHJvdWdoIHRoZSBjaXJjbGUgaW50ZXJzZWN0aW9uXHJcbiAgICAvLyBwb2ludHMgY3Jvc3NlcyB0aGUgbGluZSBiZXR3ZWVuIHRoZSBjaXJjbGUgY2VudGVycy5cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMCB0byBwb2ludCAyOlxyXG4gICAgYSA9ICgocjAgKiByMCkgLSAocjEgKiByMSkgKyAoZCAqIGQpKSAvICgyLjAgKiBkKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIGNvb3JkaW5hdGVzIG9mIHBvaW50IDI6XHJcbiAgICB4MiA9IHgwICsgKGR4ICogYSAvIGQpO1xyXG4gICAgeTIgPSB5MCArIChkeSAqIGEgLyBkKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMiB0byBlaXRoZXIgb2YgdGhlIGludGVyc2VjdGlvblxyXG4gICAgLy8gcG9pbnRzOlxyXG4gICAgaCA9IE1hdGguc3FydCgocjAgKiByMCkgLSAoYSAqIGEpKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIG9mZnNldHMgb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludHMgZnJvbSBwb2ludCAyOlxyXG4gICAgcnggPSAtZHkgKiAoaCAvIGQpO1xyXG4gICAgcnkgPSBkeCAqIChoIC8gZCk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhYnNvbHV0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzOlxyXG4gICAgdmFyIHhpID0geDIgKyByeDtcclxuICAgIHZhciB4aV9wcmltZSA9IHgyIC0gcng7XHJcbiAgICB2YXIgeWkgPSB5MiArIHJ5O1xyXG4gICAgdmFyIHlpX3ByaW1lID0geTIgLSByeTtcclxuXHJcbiAgICByZXR1cm4ge3hpOiB4aSwgeGlfcHJpbWU6IHhpX3ByaW1lLCB5aTogeWksIHlpX3ByaW1lOiB5aV9wcmltZX07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBsaW5lIHNlZ21lbnQuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBzdGFydCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgZW5kIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cclxuICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIFRydWUgaWYgcG9pbnQgaXMgXCJjbG9zZSB0b1wiIHRoZSBsaW5lXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgKi9cclxuICBzaWdtYS51dGlscy5pc1BvaW50T25TZWdtZW50ID0gZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGVwc2lsb24pIHtcclxuICAgIHJldHVybiBzaWdtYS51dGlscy5kaXN0YW5jZVBvaW50VG9TZWdtZW50KHgsIHksIHgxLCB5MSwgeDIsIHkyKSA8IGVwc2lsb247XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICAqIENvbXB1dGUgdGhlIGRpc3RhbmNlIG9mIGEgcG9pbnQgdG8gYSBsaW5lIHNlZ21lbnQuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBzdGFydCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgZW5kIHBvaW50LlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgRGlzdGFuY2UgdG8gdGhlIHNlZ21lbnRcclxuICAqL1xyXG4gIHNpZ21hLnV0aWxzLmRpc3RhbmNlUG9pbnRUb1NlZ21lbnQgPSBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjg1MzkyNi8xMDc1MTk1XHJcbiAgICB2YXIgQSA9IHggLSB4MSxcclxuICAgICAgICBCID0geSAtIHkxLFxyXG4gICAgICAgIEMgPSB4MiAtIHgxLFxyXG4gICAgICAgIEQgPSB5MiAtIHkxLFxyXG4gICAgICAgIGRvdCA9IEEgKiBDICsgQiAqIEQsXHJcbiAgICAgICAgbGVuX3NxID0gQyAqIEMgKyBEICogRCxcclxuICAgICAgICBwYXJhbSA9IC0xLFxyXG4gICAgICAgIHh4LCB5eTtcclxuXHJcbiAgICBpZiAobGVuX3NxICE9PSAwKSAvL2luIGNhc2Ugb2YgMCBsZW5ndGggbGluZVxyXG4gICAgICAgIHBhcmFtID0gZG90IC8gbGVuX3NxO1xyXG5cclxuICAgIGlmIChwYXJhbSA8IDApIHtcclxuICAgICAgeHggPSB4MTtcclxuICAgICAgeXkgPSB5MTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmFtID4gMSkge1xyXG4gICAgICB4eCA9IHgyO1xyXG4gICAgICB5eSA9IHkyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHh4ID0geDEgKyBwYXJhbSAqIEM7XHJcbiAgICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGR4ID0geCAtIHh4O1xyXG4gICAgdmFyIGR5ID0geSAtIHl5O1xyXG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIHNlZ21lbnQgd2l0aCBhIHRoaWNrbmVzcy5cclxuICAgICpcclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweCAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY29udHJvbCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gZXBzaWxvbiBUaGUgcHJlY2lzaW9uIChjb25zaWRlciB0aGUgbGluZSB0aGlja25lc3MpLlxyXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIG90aGVyd2lzZS5cclxuICAqL1xyXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlID1cclxuICAgIGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSwgZXBzaWxvbikge1xyXG4gICAgLy8gRmFpbHMgaWYgdGhlIHBvaW50IGlzIHRvbyBmYXIgZnJvbSB0aGUgZXh0cmVtaXRpZXMgb2YgdGhlIHNlZ21lbnQsXHJcbiAgICAvLyBwcmV2ZW50aW5nIGZvciBtb3JlIGNvc3RseSBjb21wdXRhdGlvbjpcclxuICAgIHZhciBkUDFQMiA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKTtcclxuICAgIGlmIChNYXRoLmFicyh4IC0geDEpID4gZFAxUDIgfHwgTWF0aC5hYnMoeSAtIHkxKSA+IGRQMVAyKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcclxuICAgICAgICBkUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MiwgeTIpLFxyXG4gICAgICAgIHQgPSAwLjUsXHJcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxyXG4gICAgICAgIHJUaHJlc2hvbGQgPSAwLjAwMSxcclxuICAgICAgICBpID0gMTAwLFxyXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSksXHJcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcclxuICAgICAgICBvbGRfZHQ7XHJcblxyXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XHJcbiAgICAvLyBmaW5kIHRoZSBvcHRpbWFsIHQgdmFsdWUgd2hlcmUgdD0wIGlzIHRoZSBzdGFydCBwb2ludCBhbmQgdD0xIGlzIHRoZSBlbmRcclxuICAgIC8vIHBvaW50IG9mIHRoZSBjdXJ2ZSwgc3RhcnRpbmcgZnJvbSB0PTAuNS5cclxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxyXG4gICAgd2hpbGUgKGktLSA+IDAgJiZcclxuICAgICAgdCA+PSAwICYmIHQgPD0gMSAmJlxyXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxyXG4gICAgICAociA+IHJUaHJlc2hvbGQgfHwgciA8IC1yVGhyZXNob2xkKSkge1xyXG4gICAgICBvbGRfZHQgPSBkdDtcclxuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUodCwgeDEsIHkxLCB4MiwgeTIsIGNweCwgY3B5KTtcclxuICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KTtcclxuXHJcbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xyXG4gICAgICAgIC8vIG5vdCB0aGUgcmlnaHQgZGlyZWN0aW9uOlxyXG4gICAgICAgIC8vIGhhbGZzdGVwIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cclxuICAgICAgICByID0gLXIgLyAyO1xyXG4gICAgICAgIHQgKz0gcjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XHJcbiAgICAgICAgLy8gb29wcywgd2UndmUgZ29uZSB0b28gZmFyOlxyXG4gICAgICAgIC8vIHJldmVydCB3aXRoIGEgaGFsZnN0ZXBcclxuICAgICAgICByID0gciAvIDI7XHJcbiAgICAgICAgZHQgPSBvbGRfZHQ7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcHJvZ3Jlc3M6XHJcbiAgICAgICAgdCArPSByO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBjdWJpYyBiZXppZXIgY3VydmUgc2VnbWVudCB3aXRoIGEgdGhpY2tuZXNzLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B4MSAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSAxc3QgY3VydmUgY29udHJvbCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkxICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweDIgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgMm5kIGN1cnZlIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5MiAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSAybmQgY3VydmUgY29udHJvbCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXHJcbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmICh4LHkpIGlzIG9uIHRoZSBjdXJ2ZSBzZWdtZW50LFxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICovXHJcbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uQmV6aWVyQ3VydmUgPVxyXG4gICAgZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGVwc2lsb24pIHtcclxuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxyXG4gICAgLy8gcHJldmVudGluZyBmb3IgbW9yZSBjb3N0bHkgY29tcHV0YXRpb246XHJcbiAgICB2YXIgZFAxQ1AxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCBjcHgxLCBjcHkxKTtcclxuICAgIGlmIChNYXRoLmFicyh4IC0geDEpID4gZFAxQ1AxIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFDUDEpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MSwgeTEpLFxyXG4gICAgICAgIGRQMiA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHgyLCB5MiksXHJcbiAgICAgICAgdCA9IDAuNSxcclxuICAgICAgICByID0gKGRQMSA8IGRQMikgPyAtMC4wMSA6IDAuMDEsXHJcbiAgICAgICAgclRocmVzaG9sZCA9IDAuMDAxLFxyXG4gICAgICAgIGkgPSAxMDAsXHJcbiAgICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXHJcbiAgICAgICAgICB0LCB4MSwgeTEsIHgyLCB5MiwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiksXHJcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcclxuICAgICAgICBvbGRfZHQ7XHJcblxyXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XHJcbiAgICAvLyBmaW5kIHRoZSBvcHRpbWFsIHQgdmFsdWUgd2hlcmUgdD0wIGlzIHRoZSBzdGFydCBwb2ludCBhbmQgdD0xIGlzIHRoZSBlbmRcclxuICAgIC8vIHBvaW50IG9mIHRoZSBjdXJ2ZSwgc3RhcnRpbmcgZnJvbSB0PTAuNS5cclxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxyXG4gICAgd2hpbGUgKGktLSA+IDAgJiZcclxuICAgICAgdCA+PSAwICYmIHQgPD0gMSAmJlxyXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxyXG4gICAgICAociA+IHJUaHJlc2hvbGQgfHwgciA8IC1yVGhyZXNob2xkKSkge1xyXG4gICAgICBvbGRfZHQgPSBkdDtcclxuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXHJcbiAgICAgICAgdCwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIpO1xyXG4gICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpO1xyXG5cclxuICAgICAgaWYgKGR0ID4gb2xkX2R0KSB7XHJcbiAgICAgICAgLy8gbm90IHRoZSByaWdodCBkaXJlY3Rpb246XHJcbiAgICAgICAgLy8gaGFsZnN0ZXAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxyXG4gICAgICAgIHIgPSAtciAvIDI7XHJcbiAgICAgICAgdCArPSByO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHQgKyByIDwgMCB8fCB0ICsgciA+IDEpIHtcclxuICAgICAgICAvLyBvb3BzLCB3ZSd2ZSBnb25lIHRvbyBmYXI6XHJcbiAgICAgICAgLy8gcmV2ZXJ0IHdpdGggYSBoYWxmc3RlcFxyXG4gICAgICAgIHIgPSByIC8gMjtcclxuICAgICAgICBkdCA9IG9sZF9kdDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBwcm9ncmVzczpcclxuICAgICAgICB0ICs9IHI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZHQgPCBlcHNpbG9uO1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiAqKioqKioqKioqKipcclxuICAgKiBFVkVOVFMgVVRJTFM6XHJcbiAgICogKioqKioqKioqKioqXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogSGVyZSBhcmUgc29tZSB1c2VmdWwgZnVuY3Rpb25zIHRvIHVuaWZ5IGV4dHJhY3Rpb24gb2YgdGhlIGluZm9ybWF0aW9uIHdlXHJcbiAgICogbmVlZCB3aXRoIG1vdXNlIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLCBmcm9tIGRpZmZlcmVudCBicm93c2VyczpcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWCBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFggdmFsdWUgb2YgdGhlIG1vdXNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldFggPSBmdW5jdGlvbihlKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAoZS5vZmZzZXRYICE9PSB1bmRlZmluZWQgJiYgZS5vZmZzZXRYKSB8fFxyXG4gICAgICAoZS5sYXllclggIT09IHVuZGVmaW5lZCAmJiBlLmxheWVyWCkgfHxcclxuICAgICAgKGUuY2xpZW50WCAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WClcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWSBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFkgdmFsdWUgb2YgdGhlIG1vdXNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldFkgPSBmdW5jdGlvbihlKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAoZS5vZmZzZXRZICE9PSB1bmRlZmluZWQgJiYgZS5vZmZzZXRZKSB8fFxyXG4gICAgICAoZS5sYXllclkgIT09IHVuZGVmaW5lZCAmJiBlLmxheWVyWSkgfHxcclxuICAgICAgKGUuY2xpZW50WSAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WSlcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBzY3JlZW4uIFRha2luZyB6b29tIGludG8gYWNjb3VudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgUGl4ZWwgcmF0aW8gb2YgdGhlIHNjcmVlblxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByYXRpbyA9IDE7XHJcbiAgICBpZiAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgIHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSA+IHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpIHtcclxuICAgICAgICByYXRpbyA9IHdpbmRvdy5zY3JlZW4uc3lzdGVtWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIHJldHVybiByYXRpbztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0IHRoZSB3aWR0aCBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIHdpZHRoIG9mIHRoZSBldmVudCdzIHRhcmdldC5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRXaWR0aCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIHZhciB3ID0gKCFlLnRhcmdldC5vd25lclNWR0VsZW1lbnQpID9cclxuICAgICAgICAgICAgICBlLnRhcmdldC53aWR0aCA6XHJcbiAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJTVkdFbGVtZW50LndpZHRoO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICh0eXBlb2YgdyA9PT0gJ251bWJlcicgJiYgdykgfHxcclxuICAgICAgKHcgIT09IHVuZGVmaW5lZCAmJiB3LmJhc2VWYWwgIT09IHVuZGVmaW5lZCAmJiB3LmJhc2VWYWwudmFsdWUpXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3QgdGhlIGNlbnRlciBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGNlbnRlciBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyID0gZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIHJhdGlvID0gZS50YXJnZXQubmFtZXNwYWNlVVJJLmluZGV4T2YoJ3N2ZycpICE9PSAtMSA/IDEgOlxyXG4gICAgICAgIHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8oKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHNpZ21hLnV0aWxzLmdldFdpZHRoKGUpIC8gKDIgKiByYXRpbyksXHJcbiAgICAgIHk6IHNpZ21hLnV0aWxzLmdldEhlaWdodChlKSAvICgyICogcmF0aW8pLFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IG1vdXNlIGNvb3JkcyB0byBzaWdtYSBjb29yZHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB4IGNvb3JkIHRvIGNvbnZlcnRcclxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB5IGNvb3JkIHRvIGNvbnZlcnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIHN0YW5kYXJkaXplZCBldmVudFxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzID0gZnVuY3Rpb24oZSwgeCwgeSkge1xyXG4gICAgeCA9IHggfHwgc2lnbWEudXRpbHMuZ2V0WChlKTtcclxuICAgIHkgPSB5IHx8IHNpZ21hLnV0aWxzLmdldFkoZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcclxuICAgICAgICB5OiB5IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXHJcbiAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxyXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcclxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXHJcbiAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxyXG4gICAgICAgIGFsdEtleTogZS5hbHRLZXksXHJcbiAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdCB0aGUgaGVpZ2h0IGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgaGVpZ2h0IG9mIHRoZSBldmVudCdzIHRhcmdldC5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRIZWlnaHQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgaCA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XHJcbiAgICAgICAgICAgICAgZS50YXJnZXQuaGVpZ2h0IDpcclxuICAgICAgICAgICAgICBlLnRhcmdldC5vd25lclNWR0VsZW1lbnQuaGVpZ2h0O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICh0eXBlb2YgaCA9PT0gJ251bWJlcicgJiYgaCkgfHxcclxuICAgICAgKGggIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwgIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwudmFsdWUpXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3QgdGhlIHdoZWVsIGRlbHRhIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgd2hlZWwgZGVsdGEgb2YgdGhlIG1vdXNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldERlbHRhID0gZnVuY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgKGUud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICYmIGUud2hlZWxEZWx0YSkgfHxcclxuICAgICAgKGUuZGV0YWlsICE9PSB1bmRlZmluZWQgJiYgLWUuZGV0YWlsKVxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgYSBET00gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbSBUaGUgZWxlbWVudCB0byByZXRyaWV2ZSB0aGUgcG9zaXRpb24uXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBvZmZzZXQgb2YgdGhlIERPTSBlbGVtZW50ICh0b3AsIGxlZnQpLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldE9mZnNldCA9IGZ1bmN0aW9uKGRvbSkge1xyXG4gICAgdmFyIGxlZnQgPSAwLFxyXG4gICAgICAgIHRvcCA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGRvbSkge1xyXG4gICAgICB0b3AgPSB0b3AgKyBwYXJzZUludChkb20ub2Zmc2V0VG9wKTtcclxuICAgICAgbGVmdCA9IGxlZnQgKyBwYXJzZUludChkb20ub2Zmc2V0TGVmdCk7XHJcbiAgICAgIGRvbSA9IGRvbS5vZmZzZXRQYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiB0b3AsXHJcbiAgICAgIGxlZnQ6IGxlZnRcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2ltdWxhdGVzIGEgXCJkb3VibGUgY2xpY2tcIiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICBUaGUgZXZlbnQgdGFyZ2V0LlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cclxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgY2xpY2tzID0gMCxcclxuICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICBoYW5kbGVycztcclxuXHJcbiAgICB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9O1xyXG4gICAgdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXSB8fCBbXTtcclxuICAgIGhhbmRsZXJzID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV07XHJcblxyXG4gICAgaGFuZGxlcnMucHVzaChmdW5jdGlvbihlKSB7XHJcbiAgICAgIGNsaWNrcysrO1xyXG5cclxuICAgICAgaWYgKGNsaWNrcyA9PT0gMikge1xyXG4gICAgICAgIGNsaWNrcyA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNsaWNrcyA9PT0gMSkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBjbGlja3MgPSAwO1xyXG4gICAgICAgIH0sIHNpZ21hLnNldHRpbmdzLmRvdWJsZUNsaWNrVGltZW91dCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXJzW2hhbmRsZXJzLmxlbmd0aCAtIDFdLCBmYWxzZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVW5iaW5kIHNpbXVsYXRlZCBcImRvdWJsZSBjbGlja1wiIGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICBUaGUgZXZlbnQgdGFyZ2V0LlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSkge1xyXG4gICAgdmFyIGhhbmRsZXIsXHJcbiAgICAgICAgaGFuZGxlcnMgPSAodGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgfHwge30pW3R5cGVdIHx8IFtdO1xyXG5cclxuICAgIHdoaWxlICgoaGFuZGxlciA9IGhhbmRsZXJzLnBvcCgpKSkge1xyXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGUgKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXTtcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBIZXJlIGFyZSBqdXN0IHNvbWUgb2YgdGhlIG1vc3QgYmFzaWMgZWFzaW5nIGZ1bmN0aW9ucywgdXNlZCBmb3IgdGhlXHJcbiAgICogYW5pbWF0ZWQgY2FtZXJhIFwiZ29Ub1wiIGNhbGxzLlxyXG4gICAqXHJcbiAgICogSWYgeW91IG5lZWQgc29tZSBtb3JlIGVhc2luZ3MgZnVuY3Rpb25zLCBkb24ndCBoZXNpdGF0ZSB0byBhZGQgdGhlbSB0b1xyXG4gICAqIHNpZ21hLnV0aWxzLmVhc2luZ3MuIEJ1dCBJIHdpbGwgbm90IGFkZCBzb21lIG1vcmUgaGVyZSBvciBtZXJnZSBQUnNcclxuICAgKiBjb250YWluaW5nLCBiZWNhdXNlIEkgZG8gbm90IHdhbnQgc2lnbWEgc291cmNlcyBmdWxsIG9mIG92ZXJraWxsIGFuZCBuZXZlclxyXG4gICAqIHVzZWQgc3R1ZmYuLi5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5lYXNpbmdzID0gc2lnbWEudXRpbHMuZWFzaW5ncyB8fCB7fTtcclxuICBzaWdtYS51dGlscy5lYXNpbmdzLmxpbmVhck5vbmUgPSBmdW5jdGlvbihrKSB7XHJcbiAgICByZXR1cm4gaztcclxuICB9O1xyXG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljSW4gPSBmdW5jdGlvbihrKSB7XHJcbiAgICByZXR1cm4gayAqIGs7XHJcbiAgfTtcclxuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY091dCA9IGZ1bmN0aW9uKGspIHtcclxuICAgIHJldHVybiBrICogKDIgLSBrKTtcclxuICB9O1xyXG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljSW5PdXQgPSBmdW5jdGlvbihrKSB7XHJcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxyXG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XHJcbiAgICByZXR1cm4gLSAwLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xyXG4gIH07XHJcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5jdWJpY0luID0gZnVuY3Rpb24oaykge1xyXG4gICAgcmV0dXJuIGsgKiBrICogaztcclxuICB9O1xyXG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNPdXQgPSBmdW5jdGlvbihrKSB7XHJcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xyXG4gIH07XHJcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5jdWJpY0luT3V0ID0gZnVuY3Rpb24oaykge1xyXG4gICAgaWYgKChrICo9IDIpIDwgMSlcclxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcclxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqICoqKioqKioqKioqKlxyXG4gICAqIFdFQkdMIFVUSUxTOlxyXG4gICAqICoqKioqKioqKioqKlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0IHdlYmdsXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmlzV2ViR0xTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjYW52YXMsXHJcbiAgICAgICAgd2ViZ2wgPSAhIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBpZiAod2ViZ2wpIHtcclxuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuICEhKFxyXG4gICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcclxuICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYSBXZWJHTCBzaGFkZXIgYW5kIHJldHVybnMgaXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtXZWJHTENvbnRleHR9ICAgICAgICAgICBnbCAgICAgICAgICAgVGhlIFdlYkdMQ29udGV4dCB0byB1c2UuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgc2hhZGVyU291cmNlIFRoZSBzaGFkZXIgc291cmNlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgIHNoYWRlclR5cGUgICBUaGUgdHlwZSBvZiBzaGFkZXIuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oc3RyaW5nKTogdm9pZH0gZXJyb3IgICAgICAgIENhbGxiYWNrIGZvciBlcnJvcnMuXHJcbiAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHNoYWRlci5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5sb2FkU2hhZGVyID0gZnVuY3Rpb24oZ2wsIHNoYWRlclNvdXJjZSwgc2hhZGVyVHlwZSwgZXJyb3IpIHtcclxuICAgIHZhciBjb21waWxlZCxcclxuICAgICAgICBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XHJcblxyXG4gICAgLy8gTG9hZCB0aGUgc2hhZGVyIHNvdXJjZVxyXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcclxuXHJcbiAgICAvLyBDb21waWxlIHRoZSBzaGFkZXJcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAvLyBDaGVjayB0aGUgY29tcGlsZSBzdGF0dXNcclxuICAgIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xyXG5cclxuICAgIC8vIElmIHNvbWV0aGluZyB3ZW50IHdyb25nOlxyXG4gICAgaWYgKCFjb21waWxlZCkge1xyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBlcnJvcihcclxuICAgICAgICAgICdFcnJvciBjb21waWxpbmcgc2hhZGVyIFwiJyArIHNoYWRlciArICdcIjonICtcclxuICAgICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2hhZGVyO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBwcm9ncmFtLCBhdHRhY2hlcyBzaGFkZXJzLCBiaW5kcyBhdHRyaWIgbG9jYXRpb25zLCBsaW5rcyB0aGVcclxuICAgKiBwcm9ncmFtIGFuZCBjYWxscyB1c2VQcm9ncmFtLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7QXJyYXkuPFdlYkdMU2hhZGVyPn0gICAgc2hhZGVycyAgIFRoZSBzaGFkZXJzIHRvIGF0dGFjaC5cclxuICAgKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPn0gICAgICAgICBhdHRyaWJzICAgVGhlIGF0dHJpYnMgbmFtZXMuXHJcbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59ICAgICAgICAgbG9jYXRpb25zIFRoZSBsb2NhdGlvbnMgZm9yIHRoZSBhdHRyaWJzLlxyXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxyXG4gICAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9ncmFtLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtID0gZnVuY3Rpb24oZ2wsIHNoYWRlcnMsIGF0dHJpYnMsIGxvYywgZXJyb3IpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGxpbmtlZCxcclxuICAgICAgICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBzaGFkZXJzLmxlbmd0aDsgKytpKVxyXG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XHJcblxyXG4gICAgaWYgKGF0dHJpYnMpXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihcclxuICAgICAgICAgIHByb2dyYW0sXHJcbiAgICAgICAgICBsb2NhdGlvbnMgPyBsb2NhdGlvbnNbaV0gOiBpLFxyXG4gICAgICAgICAgb3B0X2F0dHJpYnNbaV1cclxuICAgICAgICApO1xyXG5cclxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG5cclxuICAgIC8vIENoZWNrIHRoZSBsaW5rIHN0YXR1c1xyXG4gICAgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XHJcbiAgICBpZiAoIWxpbmtlZCkge1xyXG4gICAgICBpZiAoZXJyb3IpXHJcbiAgICAgICAgZXJyb3IoJ0Vycm9yIGluIHByb2dyYW0gbGlua2luZzogJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcclxuXHJcbiAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcm9ncmFtO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICoqKioqKioqKlxyXG4gICAqIE1BVFJJQ0VTOlxyXG4gICAqICoqKioqKioqKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgdXRpbHMgYXJlIGp1c3QgaGVyZSB0byBoZWxwIGdlbmVyYXRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uXHJcbiAgICogbWF0cmljZXMgZm9yIHRoZSBXZWJHTCByZW5kZXJlcnMuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscy5tYXRyaWNlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyB0cmFuc2xhdGlvbiBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IFRoZSBYIHRyYW5zbGF0aW9uLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgdHJhbnNsYXRpb24uXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24gPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIDEsIDAsIDAsXHJcbiAgICAgIDAsIDEsIDAsXHJcbiAgICAgIGR4LCBkeSwgMVxyXG4gICAgXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgcm90YXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgYW5nbGUgVGhlIHJvdGF0aW9uIGFuZ2xlLlxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIDJ4MiBtYXRyaXguXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uID0gZnVuY3Rpb24oYW5nbGUsIG0yKSB7XHJcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxyXG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICByZXR1cm4gbTIgPyBbXHJcbiAgICAgIGNvcywgLXNpbixcclxuICAgICAgc2luLCBjb3NcclxuICAgIF0gOiBbXHJcbiAgICAgIGNvcywgLXNpbiwgMCxcclxuICAgICAgc2luLCBjb3MsIDAsXHJcbiAgICAgIDAsIDAsIDFcclxuICAgIF07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgcmF0aW8gVGhlIHNjYWxpbmcgcmF0aW8uXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgMngyIG1hdHJpeC5cclxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUgPSBmdW5jdGlvbihyYXRpbywgbTIpIHtcclxuICAgIHJldHVybiBtMiA/IFtcclxuICAgICAgcmF0aW8sIDAsXHJcbiAgICAgIDAsIHJhdGlvXHJcbiAgICBdIDogW1xyXG4gICAgICByYXRpbywgMCwgMCxcclxuICAgICAgMCwgcmF0aW8sIDAsXHJcbiAgICAgIDAsIDAsIDFcclxuICAgIF07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7YXJyYXl9ICAgYSAgVGhlIGZpcnN0IG1hdHJpeC5cclxuICAgKiBAcGFyYW0gIHthcnJheX0gICBiICBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBtMiBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCBhc3N1bWUgYm90aCBtYXRyaWNlcyBhcmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAyeDIuXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5ID0gZnVuY3Rpb24oYSwgYiwgbTIpIHtcclxuICAgIHZhciBsID0gbTIgPyAyIDogMyxcclxuICAgICAgICBhMDAgPSBhWzAgKiBsICsgMF0sXHJcbiAgICAgICAgYTAxID0gYVswICogbCArIDFdLFxyXG4gICAgICAgIGEwMiA9IGFbMCAqIGwgKyAyXSxcclxuICAgICAgICBhMTAgPSBhWzEgKiBsICsgMF0sXHJcbiAgICAgICAgYTExID0gYVsxICogbCArIDFdLFxyXG4gICAgICAgIGExMiA9IGFbMSAqIGwgKyAyXSxcclxuICAgICAgICBhMjAgPSBhWzIgKiBsICsgMF0sXHJcbiAgICAgICAgYTIxID0gYVsyICogbCArIDFdLFxyXG4gICAgICAgIGEyMiA9IGFbMiAqIGwgKyAyXSxcclxuICAgICAgICBiMDAgPSBiWzAgKiBsICsgMF0sXHJcbiAgICAgICAgYjAxID0gYlswICogbCArIDFdLFxyXG4gICAgICAgIGIwMiA9IGJbMCAqIGwgKyAyXSxcclxuICAgICAgICBiMTAgPSBiWzEgKiBsICsgMF0sXHJcbiAgICAgICAgYjExID0gYlsxICogbCArIDFdLFxyXG4gICAgICAgIGIxMiA9IGJbMSAqIGwgKyAyXSxcclxuICAgICAgICBiMjAgPSBiWzIgKiBsICsgMF0sXHJcbiAgICAgICAgYjIxID0gYlsyICogbCArIDFdLFxyXG4gICAgICAgIGIyMiA9IGJbMiAqIGwgKyAyXTtcclxuXHJcbiAgICByZXR1cm4gbTIgPyBbXHJcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCxcclxuICAgICAgYTAwICogYjAxICsgYTAxICogYjExLFxyXG4gICAgICBhMTAgKiBiMDAgKyBhMTEgKiBiMTAsXHJcbiAgICAgIGExMCAqIGIwMSArIGExMSAqIGIxMVxyXG4gICAgXSA6IFtcclxuICAgICAgYTAwICogYjAwICsgYTAxICogYjEwICsgYTAyICogYjIwLFxyXG4gICAgICBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjEsXHJcbiAgICAgIGEwMCAqIGIwMiArIGEwMSAqIGIxMiArIGEwMiAqIGIyMixcclxuICAgICAgYTEwICogYjAwICsgYTExICogYjEwICsgYTEyICogYjIwLFxyXG4gICAgICBhMTAgKiBiMDEgKyBhMTEgKiBiMTEgKyBhMTIgKiBiMjEsXHJcbiAgICAgIGExMCAqIGIwMiArIGExMSAqIGIxMiArIGExMiAqIGIyMixcclxuICAgICAgYTIwICogYjAwICsgYTIxICogYjEwICsgYTIyICogYjIwLFxyXG4gICAgICBhMjAgKiBiMDEgKyBhMjEgKiBiMTEgKyBhMjIgKiBiMjEsXHJcbiAgICAgIGEyMCAqIGIwMiArIGEyMSAqIGIxMiArIGEyMiAqIGIyMlxyXG4gICAgXTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogKioqKioqKioqKioqXHJcbiAgICogQ0FOVkFTIFVUSUxTOlxyXG4gICAqICoqKioqKioqKioqKlxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIHRleHQgZWl0aGVyIGFwcHJveGltYXRlZCB2aWEgdGhlIGZvbnQgc2l6ZSBvclxyXG4gICAqIHZpYSB0aGUgbW9yZSBleHBlbnNpdmUgYnV0IGFjY3VyYXRlIGNvbnRleHQubWVhc3VyZVRleHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgYXBwcm94aW1hdGUgICBBcHByb3hpbWF0ZSBvciBub3QuXHJcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gICAgIGZvbnRTaXplICAgICAgRm9udCBzaXplIG9mIHRoZSB0ZXh0LlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0ZXh0ICAgICAgICAgIFRoZSB0ZXh0IHRvIHVzZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Zsb2F0fSAgICAgICBSZXR1cm5zIHRoZSB3aWR0aC5cclxuICAgKi9cclxuICAgc2lnbWEudXRpbHMuY2FudmFzID0ge307XHJcbiAgIHNpZ21hLnV0aWxzLmNhbnZhcy5nZXRUZXh0V2lkdGggPVxyXG4gICAgICAgIGZ1bmN0aW9uKGNvbnRleHQsIGFwcHJveGltYXRlLCBmb250U2l6ZSwgdGV4dCkge1xyXG5cclxuICAgIGlmICghdGV4dCkgcmV0dXJuIDA7XHJcblxyXG4gICAgcmV0dXJuIGFwcHJveGltYXRlID8gMC42ICogdGV4dC5sZW5ndGggKiBmb250U2l6ZSA6XHJcbiAgICAgIGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzaGFkb3cgdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgY29udGV4dCBhY2NvcmRpbmcgdG8gdGhlIGxldmVsXHJcbiAgICogdG8gY3JlYXRlIHZpc3VhbCBkZXB0aC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgIGxldmVsICAgICBUaGUgbGV2ZWwgKGZyb20gMSB0byA1KS5cclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5jYW52YXMuc2V0TGV2ZWwgPSBmdW5jdGlvbihsZXZlbCwgY29udGV4dCkge1xyXG4gICAgaWYgKGxldmVsKSB7XHJcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgIC8vIGluc3BpcmVkIGJ5IE1hdGVyaWFsIERlc2lnbiBzaGFkb3dzLCBsZXZlbCBmcm9tIDEgdG8gNTpcclxuICAgICAgc3dpdGNoKGxldmVsKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMS41O1xyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gNDtcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwLjM2KSc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAzO1xyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMTI7XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMC4zOSknO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gNjtcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDEyO1xyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDAuNDIpJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDEwO1xyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMjA7XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMC40NyknO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMTU7XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAyNDtcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwLjUyKSc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBzaGFkb3cgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuY2FudmFzLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xyXG4gICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcclxuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAnIzAwMDAwMCc7XHJcbiAgfTtcclxuXHJcbiAgLy8gaW5jcmVtZW50YWxseSBzY2FsZWQsIG5vdCBhdXRvbWF0aWNhbGx5IHJlc2l6ZWQgZm9yIG5vd1xyXG4gIC8vIChpZS4gcG9zc2libGUgbWVtb3J5IGxlYWsgaWYgdGhlcmUgYXJlIG1hbnkgZ3JhcGggbG9hZCAvIHVubG9hZClcclxuICB2YXIgaW1nQ2FjaGUgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhdyBhbiBpbWFnZSBpbnNpZGUgdGhlIHNwZWNpZmllZCBub2RlIG9uIHRoZSBjYW52YXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIHggICAgICAgIFRoZSBub2RlIHggY29vcmRpbmF0ZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIHkgICAgICAgIFRoZSBub2RlIHkgY29vcmRpbmF0ZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIHNpemUgICAgIFRoZSBub2RlIHNpemUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBpbWdDcm9zc09yaWdpbiBDcm9zcy1vcmlnaW4gVVJMIG9yICcqJy5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgdGhyZXNob2xkIERpc3BsYXkgaWYgbm9kZSBzaXplIGlzIGxhcmdlclxyXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICAgICAgICAgICAgICAgY2xpcEZuICAgIFRoZSBjbGlwcGluZyBzaGFwZSBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5jYW52YXMuZHJhd0ltYWdlID1cclxuICAgIGZ1bmN0aW9uKG5vZGUsIHgsIHksIHNpemUsIGNvbnRleHQsIGltZ0Nyb3NzT3JpZ2luLCB0aHJlc2hvbGQsIGNsaXBGbikge1xyXG5cclxuICAgIGlmKCFub2RlLmltYWdlIHx8ICFub2RlLmltYWdlLnVybCB8fCBzaXplIDwgdGhyZXNob2xkKSByZXR1cm47XHJcblxyXG4gICAgdmFyIHVybCA9IG5vZGUuaW1hZ2UudXJsO1xyXG4gICAgdmFyIGloID0gbm9kZS5pbWFnZS5oIHx8IDE7IC8vIDEgaXMgYXJiaXRyYXJ5LCBhbnl3YXkgb25seSB0aGUgcmF0aW8gY291bnRzXHJcbiAgICB2YXIgaXcgPSBub2RlLmltYWdlLncgfHwgMTtcclxuICAgIHZhciBzY2FsZSA9IG5vZGUuaW1hZ2Uuc2NhbGUgfHwgMTtcclxuICAgIHZhciBjbGlwID0gbm9kZS5pbWFnZS5jbGlwIHx8IDE7XHJcblxyXG4gICAgLy8gY3JlYXRlIG5ldyBJTUcgb3IgZ2V0IGZyb20gaW1nQ2FjaGVcclxuICAgIHZhciBpbWFnZSA9IGltZ0NhY2hlW3VybF07XHJcbiAgICBpZighaW1hZ2UpIHtcclxuICAgICAgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTUcnKTtcclxuICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdjcm9zc09yaWdpbicsIGltZ0Nyb3NzT3JpZ2luKTtcclxuICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xyXG4gICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3Jlc2l6ZScpKTtcclxuICAgICAgfTtcclxuICAgICAgaW1nQ2FjaGVbdXJsXSA9IGltYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBhbmQgZHJhd1xyXG4gICAgdmFyIHhyYXRpbyA9IChpdyA8IGloKSA/IChpdyAvIGloKSA6IDE7XHJcbiAgICB2YXIgeXJhdGlvID0gKGloIDwgaXcpID8gKGloIC8gaXcpIDogMTtcclxuICAgIHZhciByID0gc2l6ZSAqIHNjYWxlO1xyXG5cclxuICAgIGNvbnRleHQuc2F2ZSgpOyAvLyBlbnRlciBjbGlwcGluZyBtb2RlXHJcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBpZiAodHlwZW9mIGNsaXBGbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjbGlwRm4obm9kZSwgeCwgeSwgc2l6ZSwgY29udGV4dCwgY2xpcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gRHJhdyB0aGUgY2xpcHBpbmcgZGlzYzpcclxuICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSAqIGNsaXAsIDAsIE1hdGguIFBJICogMiwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgY29udGV4dC5jbGlwKCk7XHJcblxyXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIGltYWdlXHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgaW1hZ2UsXHJcbiAgICAgIHggKyBNYXRoLnNpbigtMy4xNDIgLyA0KSAqIHIgKiB4cmF0aW8sXHJcbiAgICAgIHkgLSBNYXRoLmNvcygtMy4xNDIgLyA0KSAqIHIgKiB5cmF0aW8sXHJcbiAgICAgIHIgKiB4cmF0aW8gKiAyICogTWF0aC5zaW4oLTMuMTQyIC8gNCkgKiAoLTEpLFxyXG4gICAgICByICogeXJhdGlvICogMiAqIE1hdGguY29zKC0zLjE0MiAvIDQpXHJcbiAgICApO1xyXG4gICAgY29udGV4dC5yZXN0b3JlKCk7IC8vIGV4aXQgY2xpcHBpbmcgbW9kZVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXcgYW4gaWNvbiBpbnNpZGUgdGhlIHNwZWNpZmllZCBub2RlIG9uIHRoZSBjYW52YXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIHggICAgICAgIFRoZSBub2RlIHggY29vcmRpbmF0ZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIHkgICAgICAgIFRoZSBub2RlIHkgY29vcmRpbmF0ZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIHNpemUgICAgIFRoZSBub2RlIHNpemUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCBEaXNwbGF5IGlmIG5vZGUgc2l6ZSBpcyBsYXJnZXJcclxuICAgKi9cclxuICBzaWdtYS51dGlscy5jYW52YXMuZHJhd0ljb24gPSBmdW5jdGlvbihub2RlLCB4LCB5LCBzaXplLCBjb250ZXh0LCB0aHJlc2hvbGQpe1xyXG4gICAgaWYoIW5vZGUuaWNvbiB8fCBzaXplIDwgdGhyZXNob2xkKSByZXR1cm47XHJcblxyXG4gICAgdmFyIGZvbnQgPSBub2RlLmljb24uZm9udCB8fCAnQXJpYWwnLFxyXG4gICAgICAgIGZnQ29sb3IgPSBub2RlLmljb24uY29sb3IgfHwgJyNGMDAnLFxyXG4gICAgICAgIHRleHQgPSBub2RlLmljb24uY29udGVudCB8fCAnPycsXHJcbiAgICAgICAgcHggPSBub2RlLmljb24ueCB8fCAwLjUsXHJcbiAgICAgICAgcHkgPSBub2RlLmljb24ueSB8fCAwLjUsXHJcbiAgICAgICAgaGVpZ2h0ID0gc2l6ZSxcclxuICAgICAgICB3aWR0aCA9IHNpemU7XHJcblxyXG4gICAgdmFyIGZvbnRTaXplUmF0aW8gPSAwLjcwO1xyXG4gICAgaWYgKHR5cGVvZiBub2RlLmljb24uc2NhbGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgZm9udFNpemVSYXRpbyA9IE1hdGguYWJzKE1hdGgubWF4KDAuMDEsIG5vZGUuaWNvbi5zY2FsZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmb250U2l6ZSA9IE1hdGgucm91bmQoZm9udFNpemVSYXRpbyAqIGhlaWdodCk7XHJcblxyXG4gICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZnQ29sb3I7XHJcblxyXG4gICAgY29udGV4dC5mb250ID0gJycgKyBmb250U2l6ZSArICdweCAnICsgZm9udDtcclxuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcclxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gIH07XHJcblxyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbihnbG9iYWwpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKlxyXG4gICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcbiAgICogaHR0cDovL215Lm9wZXJhLmNvbS9lbW9sbGVyL2Jsb2cvMjAxMS8xMi8yMC9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWVyLWFuaW1hdGluZ1xyXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuXHJcbiAgICogZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxyXG4gICAqIE1JVCBsaWNlbnNlXHJcbiAgICovXHJcbiAgdmFyIHgsXHJcbiAgICAgIGxhc3RUaW1lID0gMCxcclxuICAgICAgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XHJcblxyXG4gIGZvciAoeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgeCsrKSB7XHJcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPVxyXG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XHJcbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxyXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XHJcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKSxcclxuICAgICAgICAgIGlkID0gZ2xvYmFsLnNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRpbWVUb0NhbGxcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcclxuICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfTtcclxuXHJcbiAgaWYgKCFnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUpXHJcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgcG9seWZpbGwgZm91bmQgb24gTUROLlxyXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQjQ29tcGF0aWJpbGl0eVxyXG4gICAqIFB1YmxpYyBkb21haW5cclxuICAgKi9cclxuICBpZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKVxyXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xyXG4gICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgLy8gQ2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1IGludGVybmFsIElzQ2FsbGFibGVcclxuICAgICAgICAvLyBmdW5jdGlvbjpcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gICAgICAgICAgZlRvQmluZCA9IHRoaXMsXHJcbiAgICAgICAgICBmTk9QLFxyXG4gICAgICAgICAgZkJvdW5kO1xyXG5cclxuICAgICAgZk5PUCA9IGZ1bmN0aW9uKCkge307XHJcbiAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KFxyXG4gICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgP1xyXG4gICAgICAgICAgICB0aGlzIDpcclxuICAgICAgICAgICAgb1RoaXMsXHJcbiAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuICAgICAgICApO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcclxuICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XHJcblxyXG4gICAgICByZXR1cm4gZkJvdW5kO1xyXG4gICAgfTtcclxufSkodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gUGFja2FnZXMgaW5pdGlhbGl6YXRpb246XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zZXR0aW5ncycpO1xyXG5cclxuICB2YXIgc2V0dGluZ3MgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEdSQVBIIFNFVFRJTkdTOlxyXG4gICAgICogKioqKioqKioqKioqKioqXHJcbiAgICAgKi9cclxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGRhdGEgaGF2ZSB0byBiZSBjbG9uZWQgaW4gbWV0aG9kcyB0byBhZGRcclxuICAgIC8vICAgICAgICAgICBub2RlcyBvciBlZGdlcy5cclxuICAgIGNsb25lOiBmYWxzZSxcclxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLCBcInNvdXJjZVwiIGFuZFxyXG4gICAgLy8gICAgICAgICAgIFwidGFyZ2V0XCIgdmFsdWVzIG11c3QgYmUgc2V0IGFzIGltbXV0YWJsZS5cclxuICAgIGltbXV0YWJsZTogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgc2lnbWEgY2FuIGxvZyBpdHMgZXJyb3JzIGFuZCB3YXJuaW5ncy5cclxuICAgIHZlcmJvc2U6IGZhbHNlLFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJFTkRFUkVSUyBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKioqKipcclxuICAgICAqL1xyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGNsYXNzUHJlZml4OiAnc2lnbWEnLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGRlZmF1bHROb2RlVHlwZTogJ2RlZicsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgZGVmYXVsdEVkZ2VUeXBlOiAnZGVmJyxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBkZWZhdWx0TGFiZWxDb2xvcjogJyMwMDAnLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGRlZmF1bHRFZGdlQ29sb3I6ICcjMDAwJyxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBkZWZhdWx0Tm9kZUNvbG9yOiAnIzAwMCcsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgZGVmYXVsdExhYmVsU2l6ZTogMTQsXHJcbiAgICAvLyB7c3RyaW5nfSBMYWJlbCBwb3NpdGlvbiByZWxhdGl2ZSB0byBpdHMgbm9kZS4gQXZhaWxhYmxlIHZhbHVlczpcclxuICAgIC8vICAgICAgICAgIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwiY2VudGVyXCIsIFwiaW5zaWRlXCJcclxuICAgIGxhYmVsQWxpZ25tZW50OiAncmlnaHQnLFxyXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGVkZ2VzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxyXG4gICAgLy8gICAgICAgICAgXCJzb3VyY2VcIiwgXCJ0YXJnZXRcIiwgXCJkZWZhdWx0XCJcclxuICAgIGVkZ2VDb2xvcjogJ3NvdXJjZScsXHJcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIHRoZSBtaW5pbWFsIGVkZ2UncyBhcnJvdyBkaXNwbGF5IHNpemUuXHJcbiAgICBtaW5BcnJvd1NpemU6IDAsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgZm9udDogJ2FyaWFsJyxcclxuICAgIC8vIHtzdHJpbmd9IEV4YW1wbGU6ICdib2xkJ1xyXG4gICAgZm9udFN0eWxlOiAnJyxcclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBsYWJlbHMgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XHJcbiAgICAvLyAgICAgICAgICBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcclxuICAgIGxhYmVsQ29sb3I6ICdkZWZhdWx0JyxcclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBsYWJlbHMgc2l6ZS4gQXZhaWxhYmxlIHZhbHVlczpcclxuICAgIC8vICAgICAgICAgIFwiZml4ZWRcIiwgXCJwcm9wb3J0aW9uYWxcIlxyXG4gICAgbGFiZWxTaXplOiAnZml4ZWQnLFxyXG4gICAgLy8ge3N0cmluZ30gVGhlIHJhdGlvIGJldHdlZW4gdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGFiZWwgYW5kIHRoZSBub2RlIHNpemUuXHJcbiAgICBsYWJlbFNpemVSYXRpbzogMSxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHNpemUgYSBub2RlIG11c3QgaGF2ZSB0byBzZWUgaXRzIGxhYmVsIGRpc3BsYXllZC5cclxuICAgIGxhYmVsVGhyZXNob2xkOiA4LFxyXG4gICAgLy8ge251bWJlcn0gTWF4aW11bSBsZW5ndGggb2YgYSBub2RlJ3MgbGFiZWwgKGluIGNoYXJhY3RlcnMpLiBEaXNwbGF5cyB0aGUgbGFiZWwgb24gc2V2ZXJhbCBsaW5lcy4gMCBkaXNhYmxlcyBpdFxyXG4gICAgLy8gKHRoZSB3aG9sZSBsYWJlbCBpcyBkaXNwbGF5ZWQgb24gb25lIGxpbmUpXHJcbiAgICBtYXhOb2RlTGFiZWxMaW5lTGVuZ3RoOiAwLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIG92ZXJzYW1wbGluZyBmYWN0b3IgdXNlZCBpbiBXZWJHTCByZW5kZXJlci5cclxuICAgIHdlYmdsT3ZlcnNhbXBsaW5nUmF0aW86IDIsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiB0aGUgYm9yZGVyIG9mIG5vZGVzLlxyXG4gICAgbm9kZUJvcmRlclNpemU6IDAsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBub2RlIGJvcmRlcidzIGNvbG9yLlxyXG4gICAgZGVmYXVsdE5vZGVCb3JkZXJDb2xvcjogJyMwMDAnLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIGhvdmVyZWQgbm9kZSdzIGxhYmVsIGZvbnQuIElmIG5vdCBzcGVjaWZpZWQsIHdpbGwgaGVyaXRhdGVcclxuICAgIC8vICAgICAgICAgIHRoZSBcImZvbnRcIiB2YWx1ZS5cclxuICAgIGhvdmVyRm9udDogJycsXHJcbiAgICAvLyB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlbiBvbmx5IG9uZSBub2RlIGNhbiBiZSBob3ZlcmVkIGF0IGEgdGltZS5cclxuICAgIHNpbmdsZUhvdmVyOiB0cnVlLFxyXG4gICAgLy8ge3N0cmluZ30gRXhhbXBsZTogJ2JvbGQnXHJcbiAgICBob3ZlckZvbnRTdHlsZTogJycsXHJcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBzaGFkb3cgY29sb3IuXHJcbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcclxuICAgIGxhYmVsSG92ZXJTaGFkb3c6ICdkZWZhdWx0JyxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBsYWJlbEhvdmVyU2hhZG93Q29sb3I6ICcjMDAwJyxcclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIGNvbG9yLlxyXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXHJcbiAgICBub2RlSG92ZXJDb2xvcjogJ25vZGUnLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGRlZmF1bHROb2RlSG92ZXJDb2xvcjogJyMwMDAnLFxyXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgYmFja2dyb3VuZCBjb2xvci5cclxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxyXG4gICAgbGFiZWxIb3ZlckJHQ29sb3I6ICdkZWZhdWx0JyxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBkZWZhdWx0SG92ZXJMYWJlbEJHQ29sb3I6ICcjZmZmJyxcclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIGxhYmVscyBjb2xvci5cclxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxyXG4gICAgbGFiZWxIb3ZlckNvbG9yOiAnZGVmYXVsdCcsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgZGVmYXVsdExhYmVsSG92ZXJDb2xvcjogJyMwMDAnLFxyXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGVkZ2VzIGhvdmVyIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxyXG4gICAgLy8gICAgICAgICAgXCJlZGdlXCIsIFwiZGVmYXVsdFwiXHJcbiAgICBlZGdlSG92ZXJDb2xvcjogJ2VkZ2UnLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgbXVsdGlwbGljYXRvciBvZiBob3ZlcmVkIGVkZ2VzLlxyXG4gICAgZWRnZUhvdmVyU2l6ZVJhdGlvOiAxLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGRlZmF1bHRFZGdlSG92ZXJDb2xvcjogJyMwMDAnLFxyXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWRnZSBleHRyZW1pdGllcyBtdXN0IGJlIGhvdmVyZWQgd2hlbiB0aGVcclxuICAgIC8vICAgICAgICAgICBlZGdlIGlzIGhvdmVyZWQuXHJcbiAgICBlZGdlSG92ZXJFeHRyZW1pdGllczogZmFsc2UsXHJcbiAgICAvLyB7Ym9vbGVhbnN9IFRoZSBkaWZmZXJlbnQgZHJhd2luZyBtb2RlczpcclxuICAgIC8vICAgICAgICAgICBmYWxzZTogTGF5ZXJlZCBub3QgZGlzcGxheWVkLlxyXG4gICAgLy8gICAgICAgICAgIHRydWU6IExheWVyZWQgZGlzcGxheWVkLlxyXG4gICAgZHJhd0VkZ2VzOiB0cnVlLFxyXG4gICAgZHJhd05vZGVzOiB0cnVlLFxyXG4gICAgZHJhd0xhYmVsczogdHJ1ZSxcclxuICAgIGRyYXdFZGdlTGFiZWxzOiBmYWxzZSxcclxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2VzIG11c3QgYmUgZHJhd24gaW4gc2V2ZXJhbCBmcmFtZXMgb3IgaW5cclxuICAgIC8vICAgICAgICAgICBvbmUgZnJhbWUsIGFzIHRoZSBub2RlcyBhbmQgbGFiZWxzIGFyZSBkcmF3bi5cclxuICAgIGJhdGNoRWRnZXNEcmF3aW5nOiBmYWxzZSxcclxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2VzIG11c3QgYmUgaGlkZGVuIGR1cmluZyBkcmFnZ2luZyBhbmRcclxuICAgIC8vICAgICAgICAgICBhbmltYXRpb25zLlxyXG4gICAgaGlkZUVkZ2VzT25Nb3ZlOiBmYWxzZSxcclxuICAgIC8vIHtudW1iZXJzfSBUaGUgZGlmZmVyZW50IGJhdGNoIHNpemVzLCB3aGVuIGVsZW1lbnRzIGFyZSBkaXNwbGF5ZWQgaW5cclxuICAgIC8vICAgICAgICAgICBzZXZlcmFsIGZyYW1lcy5cclxuICAgIGNhbnZhc0VkZ2VzQmF0Y2hTaXplOiA1MDAsXHJcbiAgICB3ZWJnbEVkZ2VzQmF0Y2hTaXplOiAxMDAwLFxyXG4gICAgLy8ge2Jvb2xlYW59IEFwcHJveGltYXRlIGxhYmVscyB3aWR0aCBpbnN0ZWFkIG9mIHVzaW5nIGNhbnZhcy5tZWFzdXJlVGV4dFxyXG4gICAgYXBwcm94aW1hdGVMYWJlbFdpZHRoOiB0cnVlLFxyXG4gICAgLy8ge2Jvb2xlYW59IEhpZGUgZWRnZXMgZnJvbSBub2RlcyB0b28gZmFyIGF3YXlcclxuICAgIGVkZ2VzQ2xpcHBpbmdXaXRoTm9kZXM6IHRydWUsXHJcbiAgICAvLyB7bnVtYmVyfSBpZiBzaWdtYS5jYW52YXMuZWRnZXMuYXV0b0N1cnZlIGlzIGNhbGxlZCwgc2V0IHJlbGF0aXZlXHJcbiAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGN1cnZlZCBwYXJhbGxlbCBlZGdlcyAoaS5lLiBlZGdlcyB3aXRoIHNhbWVcclxuICAgIC8vIGV4dHJlbWl0aWVzKS4gU21hbGxlciB2YWx1ZSBpbmNyZWFzZXMgZGlzdGFuY2VzLlxyXG4gICAgYXV0b0N1cnZlUmF0aW86IDEsXHJcbiAgICAvLyB7Ym9vbGVhbn0gaWYgc2lnbWEuY2FudmFzLmVkZ2VzLmF1dG9DdXJ2ZSBpcyBjYWxsZWQsIHNvcnQgZWRnZXMgYnlcclxuICAgIC8vIGRpcmVjdGlvbi5cclxuICAgIGF1dG9DdXJ2ZVNvcnRCeURpcmVjdGlvbjogdHJ1ZSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSRVNDQUxFIFNFVFRJTkdTOlxyXG4gICAgICogKioqKioqKioqKioqKioqKipcclxuICAgICAqL1xyXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIG9mIHRvIHNjYWxlIHRoZSBncmFwaCByZWxhdGl2ZWx5IHRvIGl0cyBjb250YWluZXIuXHJcbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcImluc2lkZVwiLCBcIm91dHNpZGVcIlxyXG4gICAgc2NhbGluZ01vZGU6ICdpbnNpZGUnLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIG1hcmdpbiB0byBrZWVwIGFyb3VuZCB0aGUgZ3JhcGguXHJcbiAgICBzaWRlTWFyZ2luOiAwLFxyXG4gICAgLy8ge251bWJlcn0gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBzbWFsbGVzdCBhbmQgdGhlIGJpZ2dlc3Qgbm9kZSAvIGVkZ2VzXHJcbiAgICAvLyAgICAgICAgICBvbiB0aGUgc2NyZWVuLiBUaGlzIG1hcHBpbmcgbWFrZXMgZWFzaWVyIHRvIGRpc3BsYXkgdGhlIGdyYXBoLFxyXG4gICAgLy8gICAgICAgICAgYXZvaWRpbmcgdG9vIGJpZyBub2RlcyB0aGF0IHRha2UgaGFsZiBvZiB0aGUgc2NyZWVuLCBvciB0b29cclxuICAgIC8vICAgICAgICAgIHNtYWxsIG9uZXMgdGhhdCBhcmUgbm90IHJlYWRhYmxlLiBJZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlXHJcbiAgICAvLyAgICAgICAgICBlcXVhbHMsIHRoZW4gdGhlIG1pbmltYWwgZGlzcGxheSBzaXplIHdpbGwgYmUgMC4gQW5kIGlmIHRoZXlcclxuICAgIC8vICAgICAgICAgIGFyZSBib3RoIGVxdWFsIHRvIDAsIHRoZW4gdGhlcmUgaXMgbm8gbWFwcGluZywgYW5kIHRoZSByYWRpdXNcclxuICAgIC8vICAgICAgICAgIG9mIHRoZSBub2RlcyB3aWxsIGJlIHRoZWlyIHNpemUuXHJcbiAgICBtaW5FZGdlU2l6ZTogMC41LFxyXG4gICAgbWF4RWRnZVNpemU6IDEsXHJcbiAgICBtaW5Ob2RlU2l6ZTogMSxcclxuICAgIG1heE5vZGVTaXplOiA4LFxyXG5cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ0FQVE9SUyBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKioqXHJcbiAgICAgKi9cclxuICAgIC8vIHtib29sZWFufSBJZiB0cnVlLCB0aGUgdXNlciB3aWxsIG5lZWQgdG8gY2xpY2sgb24gdGhlIHZpc3VhbGl6YXRpb24gZWxlbWVudFxyXG4gICAgLy8gaW4gb3JkZXIgdG8gZm9jdXMgaXRcclxuICAgIGNsaWNrVG9Gb2N1czogZmFsc2UsXHJcbiAgICAvLyB7Ym9vbGVhbn1cclxuICAgIHRvdWNoRW5hYmxlZDogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufVxyXG4gICAgbW91c2VFbmFibGVkOiB0cnVlLFxyXG4gICAgLy8ge2Jvb2xlYW59XHJcbiAgICBtb3VzZVdoZWVsRW5hYmxlZDogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufVxyXG4gICAgZG91YmxlQ2xpY2tFbmFibGVkOiB0cnVlLFxyXG4gICAgLy8ge2Jvb2xlYW59IERlZmluZXMgd2hldGhlciB0aGUgY3VzdG9tIGV2ZW50cyBzdWNoIGFzIFwiY2xpY2tOb2RlXCIgY2FuIGJlXHJcbiAgICAvLyAgICAgICAgICAgdXNlZC5cclxuICAgIGV2ZW50c0VuYWJsZWQ6IHRydWUsXHJcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXHJcbiAgICAvLyAgICAgICAgICB1c2VyIHpvb21zIHdpdGggdGhlIG1vdXNlLXdoZWVsLlxyXG4gICAgem9vbWluZ1JhdGlvOiAxLjcsXHJcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXHJcbiAgICAvLyAgICAgICAgICB1c2VyIHpvb21zIGJ5IGRvdWJsZSBjbGlja2luZy5cclxuICAgIGRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvOiAyLjIsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWluaW11bSB6b29taW5nIGxldmVsLlxyXG4gICAgem9vbU1pbjogMC4wNjI1LFxyXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gem9vbWluZyBsZXZlbC5cclxuICAgIHpvb21NYXg6IDIsXHJcbiAgICAvLyB7Ym9vbGVhbn0gRGVmaW5lcyB3aGV0aGVyIHRoZSB6b29tIGZvY3VzZXMgb24gdGhlIG1vdXNlIGxvY2F0aW9uLlxyXG4gICAgem9vbU9uTG9jYXRpb246IHRydWUsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBzY3JvbGxpbmcuXHJcbiAgICBtb3VzZVpvb21EdXJhdGlvbjogMjAwLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZG91YmxlIGNsaWNrLlxyXG4gICAgZG91YmxlQ2xpY2tab29tRHVyYXRpb246IDIwMCxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb25zIGZvbGxvd2luZyBhIG1vdXNlIGRyb3BwaW5nLlxyXG4gICAgbW91c2VJbmVydGlhRHVyYXRpb246IDIwMCxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBpbmVydGlhIHBvd2VyIChtb3VzZSBjYXB0b3IpLlxyXG4gICAgbW91c2VJbmVydGlhUmF0aW86IDMsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSB0b3VjaCBkcm9wcGluZy5cclxuICAgIHRvdWNoSW5lcnRpYUR1cmF0aW9uOiAyMDAsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgaW5lcnRpYSBwb3dlciAodG91Y2ggY2FwdG9yKS5cclxuICAgIHRvdWNoSW5lcnRpYVJhdGlvOiAzLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byBjbGlja3MgdG8gbWFrZSBpdCBhIGRvdWJsZSBjbGljay5cclxuICAgIGRvdWJsZUNsaWNrVGltZW91dDogMzAwLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byB0YXBzIHRvIG1ha2UgaXQgYSBkb3VibGUgdGFwLlxyXG4gICAgZG91YmxlVGFwVGltZW91dDogMzAwLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBvZiBkcmFnZ2luZyB0byB0cmlnZ2VyIGludGVydGlhLlxyXG4gICAgZHJhZ1RpbWVvdXQ6IDIwMCxcclxuXHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdMT0JBTCBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKipcclxuICAgICAqL1xyXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgXCJyZXNjYWxlXCIgbWlkZGxld2FyZSBoYXMgdG8gYmUgY2FsbGVkXHJcbiAgICAvLyAgICAgICAgICAgYXV0b21hdGljYWxseSBmb3IgZWFjaCBjYW1lcmEgb24gcmVmcmVzaC5cclxuICAgIGF1dG9SZXNjYWxlOiB0cnVlLFxyXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIGNhbWVyYSBtZXRob2QgXCJnb1RvXCIgd2lsbCBiYXNpY2FsbHkgZG9cclxuICAgIC8vICAgICAgICAgICBub3RoaW5nLlxyXG4gICAgZW5hYmxlQ2FtZXJhOiB0cnVlLFxyXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIG5vZGVzIGNhbm5vdCBiZSBob3ZlcmVkLlxyXG4gICAgZW5hYmxlSG92ZXJpbmc6IHRydWUsXHJcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIHRydWUsIHRoZSBlZGdlcyBjYW4gYmUgaG92ZXJlZC5cclxuICAgIGVuYWJsZUVkZ2VIb3ZlcmluZzogZmFsc2UsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiB0aGUgYXJlYSBhcm91bmQgdGhlIGVkZ2VzIHRvIGFjdGl2YXRlIGhvdmVyaW5nLlxyXG4gICAgZWRnZUhvdmVyUHJlY2lzaW9uOiA1LFxyXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgcmVzY2FsZSBtaWRkbGV3YXJlIHdpbGwgaWdub3JlIG5vZGUgc2l6ZXNcclxuICAgIC8vICAgICAgICAgICB0byBkZXRlcm1pbmUgdGhlIGdyYXBocyBib3VuZGluZ3MuXHJcbiAgICByZXNjYWxlSWdub3JlU2l6ZTogZmFsc2UsXHJcbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyBpZiB0aGUgY29yZSBoYXMgdG8gdHJ5IHRvIGNhdGNoIGVycm9ycyBvblxyXG4gICAgLy8gICAgICAgICAgIHJlbmRlcmluZy5cclxuICAgIHNraXBFcnJvcnM6IGZhbHNlLFxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTUEFUSUFMIElOREVYSU5HIFNFVFRJTkdTOlxyXG4gICAgICogKioqKioqKioqKioqKioqKlxyXG4gICAgICovXHJcbiAgICAvLyB7bnVtYmVyfSBNYXggaGVpZ2h0IG9mIHRoZSBub2RlIHF1YWQgdHJlZS5cclxuICAgIG5vZGVRdWFkdHJlZU1heExldmVsOiA0LFxyXG4gICAgLy8ge251bWJlcn0gTWF4IGhlaWdodCBvZiB0aGUgZWRnZSBxdWFkIHRyZWUuXHJcbiAgICBlZGdlUXVhZHRyZWVNYXhMZXZlbDogNCxcclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ0FNRVJBIFNFVFRJTkdTOlxyXG4gICAgICogKioqKioqKioqKioqKioqKlxyXG4gICAgICovXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgcG93ZXIgZGVncmVlcyBhcHBsaWVkIHRvIHRoZSBub2Rlcy9lZGdlcyBzaXplIHJlbGF0aXZlbHkgdG9cclxuICAgIC8vICAgICAgICAgIHRoZSB6b29taW5nIGxldmVsLiBCYXNpY2FsbHk6XHJcbiAgICAvLyAgICAgICAgICAgPiBvblNjcmVlblIgPSBNYXRoLnBvdyh6b29tLCBub2Rlc1Bvd1JhdGlvKSAqIFJcclxuICAgIC8vICAgICAgICAgICA+IG9uU2NyZWVuVCA9IE1hdGgucG93KHpvb20sIGVkZ2VzUG93UmF0aW8pICogVFxyXG4gICAgbm9kZXNQb3dSYXRpbzogMC41LFxyXG4gICAgZWRnZXNQb3dSYXRpbzogMC41LFxyXG5cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQU5JTUFUSU9OUyBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgKi9cclxuICAgIC8vIHtudW1iZXJ9IFRoZSBkZWZhdWx0IGFuaW1hdGlvbiB0aW1lLlxyXG4gICAgYW5pbWF0aW9uc1RpbWU6IDIwMFxyXG4gIH07XHJcblxyXG4gIC8vIEV4cG9ydCB0aGUgcHJldmlvdXNseSBkZXNpZ25lZCBzZXR0aW5nczpcclxuICBzaWdtYS5zZXR0aW5ncyA9IHNpZ21hLnV0aWxzLmV4dGVuZChzaWdtYS5zZXR0aW5ncyB8fCB7fSwgc2V0dGluZ3MpO1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXIgY29uc3RydWN0b3IuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSBUaGUgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgdmFyIGRpc3BhdGNoZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2hhbmRsZXJzJywge1xyXG4gICAgICB2YWx1ZToge31cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFdpbGwgZXhlY3V0ZSB0aGUgaGFuZGxlciBldmVyeXRpbWUgdGhhdCB0aGUgaW5kaWNhdGVkIGV2ZW50IChvciB0aGVcclxuICAgKiBpbmRpY2F0ZWQgZXZlbnRzKSB3aWxsIGJlIHRyaWdnZXJlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS5cclxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihPYmplY3QpfSBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIGJpbmQuXHJcbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBldmVudCxcclxuICAgICAgICBlQXJyYXk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnXHJcbiAgICApXHJcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcclxuICAgICAgICB0aGlzLmJpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XHJcbiAgICBlbHNlIGlmIChcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJlxyXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nXHJcbiAgICApIHtcclxuICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBsOyBpICs9IDEpIHtcclxuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBldmVudCBpcyBub3QgJyc6XHJcbiAgICAgICAgaWYgKCFldmVudClcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50XSlcclxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcclxuICAgICAgICAvLyBsYXRlciB0byBhZGQgZmxhZ3NcclxuICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0ucHVzaCh7XHJcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZVxyXG4gICAgICB0aHJvdyAnYmluZDogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyB0aGUgaGFuZGxlciBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50IChvciBzcGVjaWZpZWQgZXZlbnRzKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLiBJZiB1bmRlZmluZWQsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBhbGwgaGFuZGxlcnMgYXJlIHJlbW92ZWQuXHJcbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKG9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudCBvciB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBkaXNwYXRjaGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIG4sXHJcbiAgICAgICAgaixcclxuICAgICAgICBtLFxyXG4gICAgICAgIGssXHJcbiAgICAgICAgYSxcclxuICAgICAgICBldmVudCxcclxuICAgICAgICBlQXJyYXkgPSB0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJyA/IGV2ZW50cy5zcGxpdCgnICcpIDogZXZlbnRzO1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBmb3IgKGsgaW4gdGhpcy5faGFuZGxlcnMpXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2tdO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICBmb3IgKGkgPSAwLCBuID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbjsgaSArPSAxKSB7XHJcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XHJcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XSkge1xyXG4gICAgICAgICAgYSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChqID0gMCwgbSA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7IGogIT09IG07IGogKz0gMSlcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxyXG4gICAgICAgICAgICAgIGEucHVzaCh0aGlzLl9oYW5kbGVyc1tldmVudF1bal0pO1xyXG5cclxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbZXZlbnRdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2VcclxuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSlcclxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbZUFycmF5W2ldXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlcyBlYWNoIGhhbmRsZXIgYm91bmQgdG8gdGhlIGV2ZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBldmVudHMgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzIHNlcGFyYXRlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBzcGFjZXMpLlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgIGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cclxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudHMsIGRhdGEpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIG4sXHJcbiAgICAgICAgaixcclxuICAgICAgICBtLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgZXZlbnROYW1lLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XHJcblxyXG4gICAgZGF0YSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHt9IDogZGF0YTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBuID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbjsgaSArPSAxKSB7XHJcbiAgICAgIGV2ZW50TmFtZSA9IGVBcnJheVtpXTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgZXZlbnQgPSBzZWxmLmdldEV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XHJcbiAgICAgICAgYSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwLCBtID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7IGogIT09IG07IGogKz0gMSkge1xyXG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcclxuICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5vbmUpXHJcbiAgICAgICAgICAgIGEucHVzaCh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2pdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGV2ZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gZGF0YSAgIFRoZSBjb250ZW50IG9mIHRoZSBldmVudCAob3B0aW9uYWwpLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUuZ2V0RXZlbnQgPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogZXZlbnQsXHJcbiAgICAgIGRhdGE6IGRhdGEgfHwge30sXHJcbiAgICAgIHRhcmdldDogdGhpc1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBIHVzZWZ1bCBmdW5jdGlvbiB0byBkZWFsIHdpdGggaW5oZXJpdGFuY2UuIEl0IHdpbGwgbWFrZSB0aGUgdGFyZ2V0XHJcbiAgICogaW5oZXJpdCB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzcyBkaXNwYXRjaGVyIGFzIHdlbGwgYXMgaXRzIGNvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0LlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoZXIuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0LCBhcmdzKSB7XHJcbiAgICB2YXIgaztcclxuXHJcbiAgICBmb3IgKGsgaW4gZGlzcGF0Y2hlci5wcm90b3R5cGUpXHJcbiAgICAgIGlmIChkaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShrKSlcclxuICAgICAgICB0YXJnZXRba10gPSBkaXNwYXRjaGVyLnByb3RvdHlwZVtrXTtcclxuXHJcbiAgICBkaXNwYXRjaGVyLmFwcGx5KHRhcmdldCwgYXJncyk7XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRVhQT1JUOlxyXG4gICAqICoqKioqKipcclxuICAgKi9cclxuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XHJcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcclxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGlzcGF0Y2hlcjtcclxuICAgIGV4cG9ydHMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XHJcbiAgfSBlbHNlXHJcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgdXRpbHMgYWltcyB0byBmYWNpbGl0YXRlIHRoZSBtYW5pcHVsYXRpb24gb2YgZWFjaCBpbnN0YW5jZSBzZXR0aW5nLlxyXG4gICAqIFVzaW5nIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBhbiBvYmplY3QgYnJpbmdzIHR3byBtYWluIGFkdmFudGFnZXM6IEZpcnN0LFxyXG4gICAqIGl0IHdpbGwgYmUgZWFzaWVyIGluIHRoZSBmdXR1cmUgdG8gY2F0Y2ggc2V0dGluZ3MgdXBkYXRlcyB0aHJvdWdoIGFcclxuICAgKiBmdW5jdGlvbiB0aGFuIGFuIG9iamVjdC4gU2Vjb25kLCBnaXZpbmcgaXQgYSBmdWxsIG9iamVjdCB3aWxsIFwibWVyZ2VcIiBpdFxyXG4gICAqIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgcHJvcGVybHksIGtlZXBpbmcgdXMgdG8gaGF2ZSB0byBhbHdheXMgYWRkIGEgbG9vcC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2NvbmZpZ3VyYWJsZX0gVGhlIFwic2V0dGluZ3NcIiBmdW5jdGlvbi5cclxuICAgKi9cclxuICB2YXIgY29uZmlndXJhYmxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGRhdGEgPSB7fSxcclxuICAgICAgICBkYXRhcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWV0aG9kIHRvIHVzZSB0byBzZXQgb3IgZ2V0IGFueSBwcm9wZXJ0eSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9ICAgIGExIElmIGl0IGlzIGEgc3RyaW5nIGFuZCBpZiBhMiBpcyB1bmRlZmluZWQsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGl0IHdpbGwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS4gSWYgaXQgaXMgYSBzdHJpbmcgYW5kIGlmIGEyIGlzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQsIHRoZW4gaXQgd2lsbCBzZXQgYTIgYXMgdGhlIHByb3BlcnR5XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nIHRvIGExLCBhbmQgcmV0dXJuIHRoaXMuIElmXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCBpcyBhbiBvYmplY3QsIHRoZW4gZWFjaCBwYWlyIHN0cmluZyArXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qob3IgYW55IG90aGVyIHR5cGUpIHdpbGwgYmUgc2V0IGFzIGFcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtICB7Kj99ICAgICAgICAgICAgICAgYTIgVGhlIG5ldyBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIGExIGlmIGExXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBhIHN0cmluZy5cclxuICAgICAqIEByZXR1cm4geyp8Y29uZmlndXJhYmxlfSAgICAgIFJldHVybnMgaXRzZWxmIG9yIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBQb2x5bW9ycGhpc206XHJcbiAgICAgKiAqKioqKioqKioqKioqXHJcbiAgICAgKiBIZXJlIGFyZSBzb21lIGJhc2ljIHVzZSBleGFtcGxlczpcclxuICAgICAqXHJcbiAgICAgKiAgPiBzZXR0aW5ncyA9IG5ldyBjb25maWd1cmFibGUoKTtcclxuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnLCA0Mik7XHJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDQyXHJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgMTIzKTtcclxuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogMTIzXHJcbiAgICAgKiAgPiBzZXR0aW5ncyh7bXlTZXR0aW5nOiA0NTZ9KTtcclxuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XHJcbiAgICAgKlxyXG4gICAgICogQWxzbywgaXQgaXMgcG9zc2libGUgdG8gdXNlIHRoZSBmdW5jdGlvbiBhcyBhIGZhbGxiYWNrOlxyXG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogJ2FiYyd9LCAnbXlTZXR0aW5nJyk7ICAvLyBMb2dzOiAnYWJjJ1xyXG4gICAgICogID4gc2V0dGluZ3Moe2hpc1NldHRpbmc6ICdhYmMnfSwgJ215U2V0dGluZycpOyAvLyBMb2dzOiA0NTZcclxuICAgICAqL1xyXG4gICAgdmFyIHNldHRpbmdzID0gZnVuY3Rpb24oYTEsIGEyKSB7XHJcbiAgICAgIHZhciBvLFxyXG4gICAgICAgICAgaSxcclxuICAgICAgICAgIGwsXHJcbiAgICAgICAgICBrO1xyXG5cclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGExID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChkYXRhW2ExXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgcmV0dXJuIGRhdGFbYTFdO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBkYXRhcy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICBpZiAoZGF0YXNbaV1bYTFdICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhc1tpXVthMV07XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhMiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gKGExIHx8IHt9KVthMl0gIT09IHVuZGVmaW5lZCA/IGExW2EyXSA6IHNldHRpbmdzKGEyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvID0gKHR5cGVvZiBhMSA9PT0gJ29iamVjdCcgJiYgYTIgPT09IHVuZGVmaW5lZCkgPyBhMSA6IHt9O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcclxuICAgICAgICAgIG9bYTFdID0gYTI7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDAsIGsgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGsubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgZGF0YVtrW2ldXSA9IG9ba1tpXV07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBjb25maWd1cmFibGUgZnVuY3Rpb24sIHdpdGggbmV3IG9iamVjdHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3QqfSAgQW55IG51bWJlciBvZiBvYmplY3RzIHRvIHNlYXJjaCBpbi5cclxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBmdW5jdGlvbi4gQ2hlY2sgaXRzIGRvY3VtZW50YXRpb24gdG8ga25vd1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgIG1vcmUgYWJvdXQgaG93IGl0IHdvcmtzLlxyXG4gICAgICovXHJcbiAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBkYXRhcy5jb25jYXQoXHJcbiAgICAgICAgZGF0YVxyXG4gICAgICApLmNvbmNhdChcclxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYWJsZS5hcHBseSh7fSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEluaXRpYWxpemVcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICBzZXR0aW5ncyhhcmd1bWVudHNbaV0pO1xyXG5cclxuICAgIHJldHVybiBzZXR0aW5ncztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFWFBPUlQ6XHJcbiAgICogKioqKioqKlxyXG4gICAqL1xyXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcclxuICAgIHRoaXMuc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcclxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29uZmlndXJhYmxlO1xyXG4gICAgZXhwb3J0cy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XHJcbiAgfSBlbHNlXHJcbiAgICB0aGlzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgX21ldGhvZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICBfaW5kZXhlcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgIF9pbml0QmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICBfbWV0aG9kQmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICBfZGVmYXVsdFNldHRpbmdzID0ge1xyXG4gICAgICAgIGltbXV0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjbG9uZTogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICByZXR1cm4gX2RlZmF1bHRTZXR0aW5nc1trZXldO1xyXG4gICAgICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ3JhcGggY29uc3RydWN0b3IuIEl0IGluaXRpYWxpemVzIHRoZSBkYXRhIGFuZCB0aGUgaW5kZXhlcywgYW5kIGJpbmRzXHJcbiAgICogdGhlIGN1c3RvbSBpbmRleGVzIGFuZCBtZXRob2RzIHRvIGl0cyBvd24gc2NvcGUuXHJcbiAgICpcclxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XHJcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBzZXR0aW5nc1xyXG4gICAqIG9iamVjdDpcclxuICAgKlxyXG4gICAqICAge2Jvb2xlYW59IGNsb25lICAgICBJbmRpY2F0ZXMgaWYgdGhlIGRhdGEgaGF2ZSB0byBiZSBjbG9uZWQgaW4gbWV0aG9kc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0byBhZGQgbm9kZXMgb3IgZWRnZXMuXHJcbiAgICogICB7Ym9vbGVhbn0gaW1tdXRhYmxlIEluZGljYXRlcyBpZiBub2RlcyBcImlkXCIgdmFsdWVzIGFuZCBlZGdlcyBcImlkXCIsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgIFwic291cmNlXCIgYW5kIFwidGFyZ2V0XCIgdmFsdWVzIG11c3QgYmUgc2V0IGFzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9jb25maWd1cmFibGV9IHNldHRpbmdzIEV2ZW50dWFsbHkgYSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJuIHtncmFwaH0gICAgICAgICAgICAgICAgICBUaGUgbmV3IGdyYXBoIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHZhciBncmFwaCA9IGZ1bmN0aW9uKHNldHRpbmdzKSB7XHJcbiAgICB2YXIgayxcclxuICAgICAgICBmbixcclxuICAgICAgICBkYXRhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogREFUQTpcclxuICAgICAqICoqKioqXHJcbiAgICAgKiBFdmVyeSBkYXRhIHRoYXQgaXMgY2FsbGFibGUgZnJvbSBncmFwaCBtZXRob2RzIGFyZSBzdG9yZWQgaW4gdGhpcyBcImRhdGFcIlxyXG4gICAgICogb2JqZWN0LiBUaGlzIG9iamVjdCB3aWxsIGJlIHNlcnZlZCBhcyBjb250ZXh0IGZvciBhbGwgdGhlc2UgbWV0aG9kcyxcclxuICAgICAqIGFuZCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgb3RoZXIgdHlwZSBvZiBkYXRhIGluIGl0LlxyXG4gICAgICovXHJcbiAgICBkYXRhID0ge1xyXG4gICAgICAvKipcclxuICAgICAgICogU0VUVElOR1MgRlVOQ1RJT046XHJcbiAgICAgICAqICoqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgKi9cclxuICAgICAgc2V0dGluZ3M6IHNldHRpbmdzIHx8IF9kZWZhdWx0U2V0dGluZ3NGdW5jdGlvbixcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBNQUlOIERBVEE6XHJcbiAgICAgICAqICoqKioqKioqKipcclxuICAgICAgICovXHJcbiAgICAgIG5vZGVzQXJyYXk6IFtdLFxyXG4gICAgICBlZGdlc0FycmF5OiBbXSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBHTE9CQUwgSU5ERVhFUzpcclxuICAgICAgICogKioqKioqKioqKioqKioqXHJcbiAgICAgICAqIFRoZXNlIGluZGV4ZXMganVzdCBpbmRleCBkYXRhIGJ5IGlkcy5cclxuICAgICAgICovXHJcbiAgICAgIG5vZGVzSW5kZXg6IG5ldyBzaWdtYS51dGlscy5tYXAoKSxcclxuICAgICAgZWRnZXNJbmRleDogbmV3IHNpZ21hLnV0aWxzLm1hcCgpLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIExPQ0FMIElOREVYRVM6XHJcbiAgICAgICAqICoqKioqKioqKioqKioqXHJcbiAgICAgICAqIFRoZXNlIGluZGV4ZXMgcmVmZXIgZnJvbSBub2RlIHRvIG5vZGVzLiBFYWNoIGtleSBpcyBhbiBpZCwgYW5kIGVhY2hcclxuICAgICAgICogdmFsdWUgaXMgdGhlIGFycmF5IG9mIHRoZSBpZHMgb2YgcmVsYXRlZCBub2Rlcy5cclxuICAgICAgICovXHJcbiAgICAgIGluTmVpZ2hib3JzSW5kZXg6IG5ldyBzaWdtYS51dGlscy5tYXAoKSxcclxuICAgICAgb3V0TmVpZ2hib3JzSW5kZXg6IG5ldyBzaWdtYS51dGlscy5tYXAoKSxcclxuICAgICAgYWxsTmVpZ2hib3JzSW5kZXg6IG5ldyBzaWdtYS51dGlscy5tYXAoKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeGVjdXRlIGJpbmRpbmdzOlxyXG4gICAgZm9yIChrIGluIF9pbml0QmluZGluZ3MpXHJcbiAgICAgIF9pbml0QmluZGluZ3Nba10uY2FsbChkYXRhKTtcclxuXHJcbiAgICAvLyBBZGQgbWV0aG9kcyB0byBib3RoIHRoZSBzY29wZSBhbmQgdGhlIGRhdGEgb2JqZWN0czpcclxuICAgIGZvciAoayBpbiBfbWV0aG9kcykge1xyXG4gICAgICBmbiA9IF9fYmluZEdyYXBoTWV0aG9kKGssIGRhdGEsIF9tZXRob2RzW2tdKTtcclxuICAgICAgdGhpc1trXSA9IGZuO1xyXG4gICAgICBkYXRhW2tdID0gZm47XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQSBjdXN0b20gdG9vbCB0byBiaW5kIG1ldGhvZHMgc3VjaCB0aGF0IGZ1bmN0aW9uIHRoYXQgYXJlIGJvdW5kIHRvIGl0IHdpbGxcclxuICAgKiBiZSBleGVjdXRlZCBhbnl0aW1lIHRoZSBtZXRob2QgaXMgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiaW5kLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBzY29wZSAgICAgIFRoZSBzY29wZSB3aGVyZSB0aGUgbWV0aG9kIG11c3QgYmUgZXhlY3V0ZWQuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIG1ldGhvZCBpdHNlbGYuXHJcbiAgICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICAgVGhlIG5ldyBtZXRob2QuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX19iaW5kR3JhcGhNZXRob2QobWV0aG9kTmFtZSwgc2NvcGUsIGZuKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBrLFxyXG4gICAgICAgICAgcmVzO1xyXG5cclxuICAgICAgLy8gRXhlY3V0ZSBcImJlZm9yZVwiIGJvdW5kIGZ1bmN0aW9uczpcclxuICAgICAgZm9yIChrIGluIF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXSlcclxuICAgICAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAvLyBBcHBseSB0aGUgbWV0aG9kOlxyXG4gICAgICByZXMgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgIC8vIEV4ZWN1dGUgYm91bmQgZnVuY3Rpb25zOlxyXG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdKVxyXG4gICAgICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXVtrXS5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiByZXM6XHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGN1c3RvbSB0b29sIGZ1bmN0aW9uIHJlbW92ZXMgZXZlcnkgcGFpciBrZXkvdmFsdWUgZnJvbSBhbiBoYXNoLiBUaGVcclxuICAgKiBnb2FsIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aGlsZSBzb21lIG90aGVyIHJlZmVyZW5jZXMgYXJlXHJcbiAgICogc3RpbGwgaGFuZ2luZyBpbiBzb21lIHNjb3Blcy4uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBlbXB0eS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgZW1wdHkgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9fZW1wdHlPYmplY3Qob2JqKSB7XHJcbiAgICB2YXIgaztcclxuXHJcbiAgICBmb3IgKGsgaW4gb2JqKVxyXG4gICAgICBpZiAoISgnaGFzT3duUHJvcGVydHknIGluIG9iaikgfHwgb2JqLmhhc093blByb3BlcnR5KGspKVxyXG4gICAgICAgIGRlbGV0ZSBvYmpba107XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZCBhZGRzIGEgbWV0aG9kIHRoYXQgd2lsbCBiZSBib3VuZCB0byB0aGUgZnV0dXJseSBjcmVhdGVkXHJcbiAgICogZ3JhcGggaW5zdGFuY2VzLlxyXG4gICAqXHJcbiAgICogU2luY2UgdGhlc2UgbWV0aG9kcyB3aWxsIGJlIGJvdW5kIHRvIHRoZWlyIHNjb3BlIHdoZW4gdGhlIGluc3RhbmNlcyBhcmVcclxuICAgKiBjcmVhdGVkLCBpdCBkb2VzIG5vdCB1c2UgdGhlIHByb3RvdHlwZS4gQmVjYXVzZSBvZiB0aGF0LCBtZXRob2RzIGhhdmUgdG9cclxuICAgKiBiZSBhZGRlZCBiZWZvcmUgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIHRvIG1ha2UgdGhlbSBhdmFpbGFibGUuXHJcbiAgICpcclxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGU6XHJcbiAgICpcclxuICAgKiAgPiBncmFwaC5hZGRNZXRob2QoJ2dldE5vZGVzQ291bnQnLCBmdW5jdGlvbigpIHtcclxuICAgKiAgPiAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoO1xyXG4gICAqICA+IH0pO1xyXG4gICAqICA+XHJcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcclxuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLmdldE5vZGVzQ291bnQoKSk7IC8vIG91dHB1dHMgMFxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgbWV0aG9kIGl0c2VsZi5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGZuKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiBtZXRob2ROYW1lICE9PSAnc3RyaW5nJyB8fFxyXG4gICAgICB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgfHxcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMlxyXG4gICAgKVxyXG4gICAgICB0aHJvdyAnYWRkTWV0aG9kOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICBpZiAoX21ldGhvZHNbbWV0aG9kTmFtZV0gfHwgZ3JhcGhbbWV0aG9kTmFtZV0pXHJcbiAgICAgIHRocm93ICdUaGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcclxuXHJcbiAgICBfbWV0aG9kc1ttZXRob2ROYW1lXSA9IGZuO1xyXG4gICAgX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUgbWV0aG9kIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQsIGFuZFxyXG4gICAqIGZhbHNlIGVsc2UuXHJcbiAgICpcclxuICAgKiBIZXJlIGFyZSBzb21lIGV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCdhZGROb2RlJyk7IC8vIHJldHVybnMgdHJ1ZVxyXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgnaGFzTWV0aG9kJyk7IC8vIHJldHVybnMgdHJ1ZVxyXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgndW5leGlzdGluZ01ldGhvZCcpOyAvLyByZXR1cm5zIGZhbHNlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICBUaGUgcmVzdWx0LlxyXG4gICAqL1xyXG4gIGdyYXBoLmhhc01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcclxuICAgIHJldHVybiAhIShfbWV0aG9kc1ttZXRob2ROYW1lXSB8fCBncmFwaFttZXRob2ROYW1lXSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kcyBhdHRhY2hlcyBhIGZ1bmN0aW9uIHRvIGEgbWV0aG9kLiBBbnl0aW1lIHRoZSBzcGVjaWZpZWRcclxuICAgKiBtZXRob2QgaXMgY2FsbGVkLCB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gaXMgY2FsbGVkIHJpZ2h0IGFmdGVyLCB3aXRoIHRoZVxyXG4gICAqIHNhbWUgYXJndW1lbnRzIGFuZCBpbiB0aGUgc2FtZSBzY29wZS4gVGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG4gICAqIHJpZ2h0IGJlZm9yZSBpZiB0aGUgbGFzdCBhcmd1bWVudCBpcyB0cnVlLCB1bmxlc3MgdGhlIG1ldGhvZCBpcyB0aGUgZ3JhcGhcclxuICAgKiBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIFRvIGF0dGFjaCBhIGZ1bmN0aW9uIHRvIHRoZSBncmFwaCBjb25zdHJ1Y3RvciwgdXNlICdjb25zdHJ1Y3RvcicgYXMgdGhlXHJcbiAgICogbWV0aG9kIG5hbWUgKGZpcnN0IGFyZ3VtZW50KS5cclxuICAgKlxyXG4gICAqIFRoZSBtYWluIGlkZWEgaXMgdG8gaGF2ZSBhIGNsZWFuIHdheSB0byBrZWVwIGN1c3RvbSBpbmRleGVzIHVwIHRvIGRhdGUsXHJcbiAgICogZm9yIGluc3RhbmNlOlxyXG4gICAqXHJcbiAgICogID4gdmFyIHRpbWVzQWRkTm9kZUNhbGxlZCA9IDA7XHJcbiAgICogID4gZ3JhcGguYXR0YWNoKCdhZGROb2RlJywgJ3RpbWVzQWRkTm9kZUNhbGxlZEluYycsIGZ1bmN0aW9uKCkge1xyXG4gICAqICA+ICAgdGltZXNBZGROb2RlQ2FsbGVkKys7XHJcbiAgICogID4gfSk7XHJcbiAgICogID5cclxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xyXG4gICAqICA+IGNvbnNvbGUubG9nKHRpbWVzQWRkTm9kZUNhbGxlZCk7IC8vIG91dHB1dHMgMFxyXG4gICAqICA+XHJcbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcclxuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDJcclxuICAgKlxyXG4gICAqIFRoZSBpZGVhIGZvciBjYWxsaW5nIGEgZnVuY3Rpb24gYmVmb3JlIGlzIHRvIHByb3ZpZGUgcHJlLXByb2Nlc3NvcnMsIGZvclxyXG4gICAqIGluc3RhbmNlOlxyXG4gICAqXHJcbiAgICogID4gdmFyIGNvbG9yUGFsZXR0ZSA9IHsgUGVyc29uOiAnI0MzQ0JFMScsIFBsYWNlOiAnIzlCREVCRCcgfTtcclxuICAgKiAgPiBncmFwaC5hdHRhY2goJ2FkZE5vZGUnLCAnYXBwbHlOb2RlQ29sb3JQYWxldHRlJywgZnVuY3Rpb24obikge1xyXG4gICAqICA+ICAgbi5jb2xvciA9IGNvbG9yUGFsZXR0ZVtuLmNhdGVnb3J5XTtcclxuICAgKiAgPiB9LCB0cnVlKTtcclxuICAgKiAgPlxyXG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XHJcbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICduMCcsIGNhdGVnb3J5OiAnUGVyc29uJyB9KTtcclxuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLm5vZGVzKCduMCcpLmNvbG9yKTsgLy8gb3V0cHV0cyAnI0MzQ0JFMSdcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSByZWxhdGVkIG1ldGhvZCBvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29uc3RydWN0b3JcIi5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAga2V5ICAgICAgICBUaGUga2V5IHRvIGlkZW50aWZ5IHRoZSBmdW5jdGlvbiB0byBhdHRhY2guXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGJlZm9yZSAgICAgSWYgdHJ1ZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGdyYXBoLmF0dGFjaCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGtleSwgZm4sIGJlZm9yZSkge1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgbWV0aG9kTmFtZSAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nIHx8XHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8XHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiA0XHJcbiAgICApXHJcbiAgICAgIHRocm93ICdhdHRhY2g6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIHZhciBiaW5kaW5ncztcclxuXHJcbiAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2NvbnN0cnVjdG9yJylcclxuICAgICAgYmluZGluZ3MgPSBfaW5pdEJpbmRpbmdzO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmIChiZWZvcmUpIHtcclxuICAgICAgICBpZiAoIV9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXSlcclxuICAgICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XHJcblxyXG4gICAgICAgIGJpbmRpbmdzID0gX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdKVxyXG4gICAgICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xyXG5cclxuICAgICAgICBiaW5kaW5ncyA9IF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChiaW5kaW5nc1trZXldKVxyXG4gICAgICB0aHJvdyAnQSBmdW5jdGlvbiBcIicgKyBrZXkgKyAnXCIgaXMgYWxyZWFkeSBhdHRhY2hlZCAnICtcclxuICAgICAgICAgICAgJ3RvIHRoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIi4nO1xyXG5cclxuICAgIGJpbmRpbmdzW2tleV0gPSBmbjtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBbGlhcyBvZiBhdHRhY2gobWV0aG9kTmFtZSwga2V5LCBmbiwgdHJ1ZSkuXHJcbiAgICovXHJcbiAgZ3JhcGguYXR0YWNoQmVmb3JlID0gZnVuY3Rpb24obWV0aG9kTmFtZSwga2V5LCBmbikge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kcyBpcyBqdXN0IGFuIGhlbHBlciB0byBkZWFsIHdpdGggY3VzdG9tIGluZGV4ZXMuIEl0IHRha2VzIGFzXHJcbiAgICogYXJndW1lbnRzIHRoZSBuYW1lIG9mIHRoZSBpbmRleCBhbmQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBkaWZmZXJlbnRcclxuICAgKiBmdW5jdGlvbnMgdG8gYmluZCB0byB0aGUgbWV0aG9kcy5cclxuICAgKlxyXG4gICAqIEhlcmUgaXMgYSBiYXNpYyBleGFtcGxlLCB0aGF0IGNyZWF0ZXMgYW4gaW5kZXggdG8ga2VlcCB0aGUgbnVtYmVyIG9mIG5vZGVzXHJcbiAgICogaW4gdGhlIGN1cnJlbnQgZ3JhcGguIEl0IGFsc28gYWRkcyBhIG1ldGhvZCB0byBwcm92aWRlIGEgZ2V0dGVyIG9uIHRoYXRcclxuICAgKiBuZXcgaW5kZXg6XHJcbiAgICpcclxuICAgKiAgPiBzaWdtYS5jbGFzc2VzLmdyYXBoLmFkZEluZGV4KCdub2Rlc0NvdW50Jywge1xyXG4gICAqICA+ICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQgPSAwO1xyXG4gICAqICA+ICAgfSxcclxuICAgKiAgPiAgIGFkZE5vZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQrKztcclxuICAgKiAgPiAgIH0sXHJcbiAgICogID4gICBkcm9wTm9kZTogZnVuY3Rpb24oKSB7XHJcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudC0tO1xyXG4gICAqICA+ICAgfVxyXG4gICAqICA+IH0pO1xyXG4gICAqICA+XHJcbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRNZXRob2QoJ2dldE5vZGVzQ291bnQnLCBmdW5jdGlvbigpIHtcclxuICAgKiAgPiAgIHJldHVybiB0aGlzLm5vZGVzQ291bnQ7XHJcbiAgICogID4gfSk7XHJcbiAgICogID5cclxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBzaWdtYS5jbGFzc2VzLmdyYXBoKCk7XHJcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcclxuICAgKiAgPlxyXG4gICAqICA+IG15R3JhcGguYWRkTm9kZSh7IGlkOiAnMScgfSkuYWRkTm9kZSh7IGlkOiAnMicgfSk7XHJcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDJcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICAgVGhlIG5hbWUgb2YgdGhlIGluZGV4LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gYmluZGluZ3MgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBmdW5jdGlvbnMgdG8gYmluZC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZ3JhcGguYWRkSW5kZXggPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5ncykge1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgT2JqZWN0KGJpbmRpbmdzKSAhPT0gYmluZGluZ3MgfHxcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMlxyXG4gICAgKVxyXG4gICAgICB0aHJvdyAnYWRkSW5kZXg6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIGlmIChfaW5kZXhlc1tuYW1lXSlcclxuICAgICAgdGhyb3cgJ1RoZSBpbmRleCBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XHJcblxyXG4gICAgdmFyIGs7XHJcblxyXG4gICAgLy8gU3RvcmUgdGhlIGJpbmRpbmdzOlxyXG4gICAgX2luZGV4ZXNbbmFtZV0gPSBiaW5kaW5ncztcclxuXHJcbiAgICAvLyBBdHRhY2ggdGhlIGJpbmRpbmdzOlxyXG4gICAgZm9yIChrIGluIGJpbmRpbmdzKVxyXG4gICAgICBpZiAodHlwZW9mIGJpbmRpbmdzW2tdICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHRocm93ICdUaGUgYmluZGluZ3MgbXVzdCBiZSBmdW5jdGlvbnMuJztcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGdyYXBoLmF0dGFjaChrLCBuYW1lLCBiaW5kaW5nc1trXSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIG5vZGUgdG8gdGhlIGdyYXBoLiBUaGUgbm9kZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXHJcbiAgICogc3RyaW5nIHVuZGVyIHRoZSBrZXkgXCJpZFwiLiBFeGNlcHQgZm9yIHRoaXMsIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCBhbnlcclxuICAgKiBvdGhlciBhdHRyaWJ1dGUsIHRoYXQgd2lsbCBiZSBwcmVzZXJ2ZWQgYWxsIGFsb25nIHRoZSBtYW5pcHVsYXRpb25zLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGdyYXBoIG9wdGlvbiBcImNsb25lXCIgaGFzIGEgdHJ1dGh5IHZhbHVlLCB0aGUgbm9kZSB3aWxsIGJlIGNsb25lZFxyXG4gICAqIHdoZW4gYWRkZWQgdG8gdGhlIGdyYXBoLiBBbHNvLCBpZiB0aGUgZ3JhcGggb3B0aW9uIFwiaW1tdXRhYmxlXCIgaGFzIGFcclxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCB3aWxsIGJlIGRlZmluZWQgYXMgaW1tdXRhYmxlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBub2RlIFRoZSBub2RlIHRvIGFkZC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIGdyYXBoIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCgnYWRkTm9kZScsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIC8vIENoZWNrIHRoYXQgdGhlIG5vZGUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYW4gaWQ6XHJcbiAgICBpZiAoT2JqZWN0KG5vZGUpICE9PSBub2RlIHx8IGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXHJcbiAgICAgIHRocm93ICdhZGROb2RlOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICBpZiAodHlwZW9mIG5vZGUuaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBub2RlLmlkICE9PSAnbnVtYmVyJylcclxuICAgICAgdGhyb3cgJ1RoZSBub2RlIG11c3QgaGF2ZSBhIHN0cmluZyBvciBudW1iZXIgaWQuJztcclxuXHJcbiAgICBpZiAodGhpcy5ub2Rlc0luZGV4LmdldChub2RlLmlkKSlcclxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIG5vZGUuaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcclxuXHJcbiAgICB2YXIgayxcclxuICAgICAgICBpZCA9IG5vZGUuaWQsXHJcbiAgICAgICAgdmFsaWROb2RlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcclxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdjbG9uZScpKSB7XHJcbiAgICAgIGZvciAoayBpbiBub2RlKVxyXG4gICAgICAgIGlmIChrICE9PSAnaWQnKVxyXG4gICAgICAgICAgdmFsaWROb2RlW2tdID0gbm9kZVtrXTtcclxuICAgIH0gZWxzZVxyXG4gICAgICB2YWxpZE5vZGUgPSBub2RlO1xyXG5cclxuICAgIC8vIFRyeSB0byBmaXggdGhlIG5vZGUgY29vcmRpbmF0ZXMgYW5kIHNpemVcclxuICAgIGlmICh2YWxpZE5vZGUueCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWxpZE5vZGUueCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgdmFsaWROb2RlLnggPSBwYXJzZUZsb2F0KHZhbGlkTm9kZS54KTtcclxuICAgIH1cclxuICAgIGlmICh2YWxpZE5vZGUueSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWxpZE5vZGUueSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgdmFsaWROb2RlLnkgPSBwYXJzZUZsb2F0KHZhbGlkTm9kZS55KTtcclxuICAgIH1cclxuICAgIGlmICh2YWxpZE5vZGUuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWxpZE5vZGUuc2l6ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgdmFsaWROb2RlLnNpemUgPSBwYXJzZUZsb2F0KHZhbGlkTm9kZS5zaXplKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBub2RlIHNpemVcclxuICAgIGlmICghdmFsaWROb2RlLnNpemUgfHwgdmFsaWROb2RlLnNpemUgPD0gMCkge1xyXG4gICAgICB2YWxpZE5vZGUuc2l6ZSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxyXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2ltbXV0YWJsZScpKVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWROb2RlLCAnaWQnLCB7XHJcbiAgICAgICAgdmFsdWU6IGlkLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHZhbGlkTm9kZS5pZCA9IGlkO1xyXG5cclxuICAgIC8vIEFkZCBlbXB0eSBjb250YWluZXJzIGZvciBlZGdlcyBpbmRleGVzOlxyXG4gICAgdGhpcy5pbk5laWdoYm9yc0luZGV4LnNldChpZCwgbmV3IHNpZ21hLnV0aWxzLm1hcCgpKTtcclxuICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXguc2V0KGlkLCBuZXcgc2lnbWEudXRpbHMubWFwKCkpO1xyXG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleC5zZXQoaWQsIG5ldyBzaWdtYS51dGlscy5tYXAoKSk7XHJcblxyXG4gICAgLy8gQWRkIHRoZSBub2RlIHRvIGluZGV4ZXM6XHJcbiAgICB0aGlzLm5vZGVzQXJyYXkucHVzaCh2YWxpZE5vZGUpO1xyXG4gICAgdGhpcy5ub2Rlc0luZGV4LnNldCh2YWxpZE5vZGUuaWQsIHZhbGlkTm9kZSk7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBjdXJyZW50IGluc3RhbmNlOlxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGFkZHMgYW4gZWRnZSB0byB0aGUgZ3JhcGguIFRoZSBlZGdlIG11c3QgYmUgYW4gb2JqZWN0LCB3aXRoIGFcclxuICAgKiBzdHJpbmcgdW5kZXIgdGhlIGtleSBcImlkXCIsIGFuZCBzdHJpbmdzIHVuZGVyIHRoZSBrZXlzIFwic291cmNlXCIgYW5kXHJcbiAgICogXCJ0YXJnZXRcIiB0aGF0IGRlc2lnbiBleGlzdGluZyBub2Rlcy4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0b1xyXG4gICAqIGFkZCBhbnkgb3RoZXIgYXR0cmlidXRlLCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkIGFsbCBhbG9uZyB0aGVcclxuICAgKiBtYW5pcHVsYXRpb25zLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGdyYXBoIG9wdGlvbiBcImNsb25lXCIgaGFzIGEgdHJ1dGh5IHZhbHVlLCB0aGUgZWRnZSB3aWxsIGJlIGNsb25lZFxyXG4gICAqIHdoZW4gYWRkZWQgdG8gdGhlIGdyYXBoLiBBbHNvLCBpZiB0aGUgZ3JhcGggb3B0aW9uIFwiaW1tdXRhYmxlXCIgaGFzIGFcclxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCwgc291cmNlIGFuZCB0YXJnZXQgd2lsbCBiZSBkZWZpbmVkIGFzIGltbXV0YWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gZWRnZSBUaGUgZWRnZSB0byBhZGQuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QoJ2FkZEVkZ2UnLCBmdW5jdGlvbihlZGdlKSB7XHJcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBlZGdlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFuIGlkOlxyXG4gICAgaWYgKE9iamVjdChlZGdlKSAhPT0gZWRnZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxyXG4gICAgICB0aHJvdyAnYWRkRWRnZTogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBlZGdlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5pZCAhPT0gJ251bWJlcicpXHJcbiAgICAgIHRocm93ICdUaGUgZWRnZSBtdXN0IGhhdmUgYSBzdHJpbmcgb3IgbnVtYmVyIGlkLic7XHJcblxyXG4gICAgaWYgKCh0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBlZGdlLnNvdXJjZSAhPT0gJ251bWJlcicpIHx8XHJcbiAgICAgICAgIXRoaXMubm9kZXNJbmRleC5nZXQoZWRnZS5zb3VyY2UpKVxyXG4gICAgICB0aHJvdyAnVGhlIGVkZ2Ugc291cmNlIG11c3QgaGF2ZSBhbiBleGlzdGluZyBub2RlIGlkLic7XHJcblxyXG4gICAgaWYgKCh0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBlZGdlLnRhcmdldCAhPT0gJ251bWJlcicpIHx8XHJcbiAgICAgICAgIXRoaXMubm9kZXNJbmRleC5nZXQoZWRnZS50YXJnZXQpKVxyXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgdGFyZ2V0IG11c3QgaGF2ZSBhbiBleGlzdGluZyBub2RlIGlkLic7XHJcblxyXG4gICAgaWYgKHRoaXMuZWRnZXNJbmRleC5nZXQoZWRnZS5pZCkpXHJcbiAgICAgIHRocm93ICdUaGUgZWRnZSBcIicgKyBlZGdlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XHJcblxyXG4gICAgdmFyIGssXHJcbiAgICAgICAgdmFsaWRFZGdlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcclxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdjbG9uZScpKSB7XHJcbiAgICAgIGZvciAoayBpbiBlZGdlKVxyXG4gICAgICAgIGlmIChrICE9PSAnaWQnICYmIGsgIT09ICdzb3VyY2UnICYmIGsgIT09ICd0YXJnZXQnKVxyXG4gICAgICAgICAgdmFsaWRFZGdlW2tdID0gZWRnZVtrXTtcclxuICAgIH0gZWxzZVxyXG4gICAgICB2YWxpZEVkZ2UgPSBlZGdlO1xyXG5cclxuICAgIC8vIFRyeSB0byBmaXggdGhlIGVkZ2Ugc2l6ZVxyXG4gICAgaWYgKHZhbGlkRWRnZS5zaXplICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbGlkRWRnZS5zaXplICE9PSAnbnVtYmVyJykge1xyXG4gICAgICB2YWxpZEVkZ2Uuc2l6ZSA9IHBhcnNlRmxvYXQodmFsaWRFZGdlLnNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGVkZ2Ugc2l6ZVxyXG4gICAgaWYgKCF2YWxpZEVkZ2Uuc2l6ZSB8fCB2YWxpZEVkZ2Uuc2l6ZSA8PSAwKSB7XHJcbiAgICAgIHZhbGlkRWRnZS5zaXplID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayB0aGUgXCJpbW11dGFibGVcIiBvcHRpb246XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnaW1tdXRhYmxlJykpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ2lkJywge1xyXG4gICAgICAgIHZhbHVlOiBlZGdlLmlkLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRFZGdlLCAnc291cmNlJywge1xyXG4gICAgICAgIHZhbHVlOiBlZGdlLnNvdXJjZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ3RhcmdldCcsIHtcclxuICAgICAgICB2YWx1ZTogZWRnZS50YXJnZXQsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbGlkRWRnZS5pZCA9IGVkZ2UuaWQ7XHJcbiAgICAgIHZhbGlkRWRnZS5zb3VyY2UgPSBlZGdlLnNvdXJjZTtcclxuICAgICAgdmFsaWRFZGdlLnRhcmdldCA9IGVkZ2UudGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0aGUgZWRnZSB0byBpbmRleGVzOlxyXG4gICAgdGhpcy5lZGdlc0FycmF5LnB1c2godmFsaWRFZGdlKTtcclxuICAgIHRoaXMuZWRnZXNJbmRleC5zZXQodmFsaWRFZGdlLmlkLCB2YWxpZEVkZ2UpO1xyXG5cclxuICAgIGlmICghdGhpcy5pbk5laWdoYm9yc0luZGV4LmdldCh2YWxpZEVkZ2UudGFyZ2V0KS5nZXQodmFsaWRFZGdlLnNvdXJjZSkpXHJcbiAgICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnRhcmdldCkuc2V0KHZhbGlkRWRnZS5zb3VyY2UsXHJcbiAgICAgICAgbmV3IHNpZ21hLnV0aWxzLm1hcCgpKTtcclxuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnRhcmdldCkuZ2V0KHZhbGlkRWRnZS5zb3VyY2UpLnNldCh2YWxpZEVkZ2UuaWQsXHJcbiAgICAgIHZhbGlkRWRnZSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLm91dE5laWdoYm9yc0luZGV4LmdldCh2YWxpZEVkZ2Uuc291cmNlKS5nZXQodmFsaWRFZGdlLnRhcmdldCkpXHJcbiAgICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS5zb3VyY2UpLnNldCh2YWxpZEVkZ2UudGFyZ2V0LFxyXG4gICAgICAgIG5ldyBzaWdtYS51dGlscy5tYXAoKSk7XHJcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4LmdldCh2YWxpZEVkZ2Uuc291cmNlKS5nZXQodmFsaWRFZGdlLnRhcmdldCkuc2V0KHZhbGlkRWRnZS5pZCxcclxuICAgICAgdmFsaWRFZGdlKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS5zb3VyY2UpLmdldCh2YWxpZEVkZ2UudGFyZ2V0KSlcclxuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnNvdXJjZSkuc2V0KHZhbGlkRWRnZS50YXJnZXQsXHJcbiAgICAgICAgbmV3IHNpZ21hLnV0aWxzLm1hcCgpKTtcclxuICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS5zb3VyY2UpLmdldCh2YWxpZEVkZ2UudGFyZ2V0KS5zZXQodmFsaWRFZGdlLmlkLFxyXG4gICAgICB2YWxpZEVkZ2UpO1xyXG5cclxuICAgIGlmICh2YWxpZEVkZ2UudGFyZ2V0ICE9PSB2YWxpZEVkZ2Uuc291cmNlKSB7XHJcbiAgICAgIGlmICghdGhpcy5hbGxOZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnRhcmdldCkuZ2V0KHZhbGlkRWRnZS5zb3VyY2UpKVxyXG4gICAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS50YXJnZXQpLnNldCh2YWxpZEVkZ2Uuc291cmNlLFxyXG4gICAgICAgICAgbmV3IHNpZ21hLnV0aWxzLm1hcCgpKTtcclxuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnRhcmdldCkuZ2V0KHZhbGlkRWRnZS5zb3VyY2UpLnNldCh2YWxpZEVkZ2UuaWQsXHJcbiAgICAgICAgdmFsaWRFZGdlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgZHJvcHMgYSBub2RlIGZyb20gdGhlIGdyYXBoLiBJdCBhbHNvIHJlbW92ZXMgZWFjaCBlZGdlIHRoYXQgaXNcclxuICAgKiBib3VuZCB0byBpdCwgdGhyb3VnaCB0aGUgZHJvcEVkZ2UgbWV0aG9kLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIG5vZGVcclxuICAgKiBkb2VzIG5vdCBleGlzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgVGhlIG5vZGUgaWQuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgZ3JhcGguYWRkTWV0aG9kKCdkcm9wTm9kZScsIGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBhcmd1bWVudHMgYXJlIHZhbGlkOlxyXG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHx8XHJcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcclxuICAgICAgdGhyb3cgJ2Ryb3BOb2RlOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICBpZiAoIXRoaXMubm9kZXNJbmRleC5nZXQoaWQpKVxyXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgXCInICsgaWQgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcclxuXHJcbiAgICB2YXIgaSwgaywgbDtcclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSBpbmRleGVzOlxyXG4gICAgdGhpcy5ub2Rlc0luZGV4LmRlbGV0ZShpZCk7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgaWYgKHRoaXMubm9kZXNBcnJheVtpXS5pZCA9PT0gaWQpIHtcclxuICAgICAgICB0aGlzLm5vZGVzQXJyYXkuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZXM6XHJcbiAgICBmb3IgKGkgPSB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uc291cmNlID09PSBpZCB8fCB0aGlzLmVkZ2VzQXJyYXlbaV0udGFyZ2V0ID09PSBpZClcclxuICAgICAgICB0aGlzLmRyb3BFZGdlKHRoaXMuZWRnZXNBcnJheVtpXS5pZCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZSBpbmRleGVzOlxyXG4gICAgdGhpcy5pbk5laWdoYm9yc0luZGV4LmRlbGV0ZShpZCk7XHJcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4LmRlbGV0ZShpZCk7XHJcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4LmRlbGV0ZShpZCk7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdGhpcy5ub2Rlc0luZGV4LmZvckVhY2goZnVuY3Rpb24obiwgaykge1xyXG4gICAgICBzZWxmLmluTmVpZ2hib3JzSW5kZXguZ2V0KGspLmRlbGV0ZShpZCk7XHJcbiAgICAgIHNlbGYub3V0TmVpZ2hib3JzSW5kZXguZ2V0KGspLmRlbGV0ZShpZCk7XHJcbiAgICAgIHNlbGYuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KGspLmRlbGV0ZShpZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgZHJvcHMgYW4gZWRnZSBmcm9tIHRoZSBncmFwaC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBlZGdlXHJcbiAgICogZG9lcyBub3QgZXhpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFRoZSBlZGdlIGlkLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCgnZHJvcEVkZ2UnLCBmdW5jdGlvbihpZCkge1xyXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcclxuICAgIGlmICgodHlwZW9mIGlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB8fFxyXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXHJcbiAgICAgIHRocm93ICdkcm9wRWRnZTogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgaWYgKCF0aGlzLmVkZ2VzSW5kZXguZ2V0KGlkKSlcclxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIFwiJyArIGlkICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XHJcblxyXG4gICAgdmFyIGksIGwsIGVkZ2U7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kZXhlczpcclxuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzSW5kZXguZ2V0KGlkKTtcclxuICAgIHRoaXMuZWRnZXNJbmRleC5kZWxldGUoaWQpO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWRnZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQgPT09IGlkKSB7XHJcbiAgICAgICAgdGhpcy5lZGdlc0FycmF5LnNwbGljZShpLCAxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleC5nZXQoZWRnZS50YXJnZXQpLmdldChlZGdlLnNvdXJjZSkuZGVsZXRlKGVkZ2UuaWQpO1xyXG4gICAgaWYgKHRoaXMuaW5OZWlnaGJvcnNJbmRleC5nZXQoZWRnZS50YXJnZXQpLmdldChlZGdlLnNvdXJjZSkuc2l6ZSA9PSAwKVxyXG4gICAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2UudGFyZ2V0KS5kZWxldGUoZWRnZS5zb3VyY2UpO1xyXG5cclxuICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2Uuc291cmNlKS5nZXQoZWRnZS50YXJnZXQpLmRlbGV0ZShlZGdlLmlkKTtcclxuICAgIGlmICh0aGlzLm91dE5laWdoYm9yc0luZGV4LmdldChlZGdlLnNvdXJjZSkuZ2V0KGVkZ2UudGFyZ2V0KS5zaXplID09IDApXHJcbiAgICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2Uuc291cmNlKS5kZWxldGUoZWRnZS50YXJnZXQpO1xyXG5cclxuICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2Uuc291cmNlKS5nZXQoZWRnZS50YXJnZXQpLmRlbGV0ZShlZGdlLmlkKTtcclxuICAgIGlmICh0aGlzLmFsbE5laWdoYm9yc0luZGV4LmdldChlZGdlLnNvdXJjZSkuZ2V0KGVkZ2UudGFyZ2V0KS5zaXplID09IDApXHJcbiAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2Uuc291cmNlKS5kZWxldGUoZWRnZS50YXJnZXQpO1xyXG5cclxuICAgIGlmIChlZGdlLnRhcmdldCAhPT0gZWRnZS5zb3VyY2UpIHtcclxuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleC5nZXQoZWRnZS50YXJnZXQpLmdldChlZGdlLnNvdXJjZSkuZGVsZXRlKGVkZ2UuaWQpO1xyXG4gICAgICBpZiAodGhpcy5hbGxOZWlnaGJvcnNJbmRleC5nZXQoZWRnZS50YXJnZXQpLmdldChlZGdlLnNvdXJjZSkuc2l6ZSA9PSAwKVxyXG4gICAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2UudGFyZ2V0KS5kZWxldGUoZWRnZS5zb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBkZXN0cm95cyB0aGUgY3VycmVudCBpbnN0YW5jZS4gSXQgYmFzaWNhbGx5IGVtcHRpZXMgZWFjaCBpbmRleFxyXG4gICAqIGFuZCBtZXRob2RzIGF0dGFjaGVkIHRvIHRoZSBncmFwaC5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QoJ2tpbGwnLCBmdW5jdGlvbigpIHtcclxuICAgIC8vIERlbGV0ZSBhcnJheXM6XHJcbiAgICB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoID0gMDtcclxuICAgIHRoaXMuZWRnZXNBcnJheS5sZW5ndGggPSAwO1xyXG4gICAgZGVsZXRlIHRoaXMubm9kZXNBcnJheTtcclxuICAgIGRlbGV0ZSB0aGlzLmVkZ2VzQXJyYXk7XHJcblxyXG4gICAgLy8gRGVsZXRlIGluZGV4ZXM6XHJcbiAgICBkZWxldGUgdGhpcy5ub2Rlc0luZGV4O1xyXG4gICAgZGVsZXRlIHRoaXMuZWRnZXNJbmRleDtcclxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXg7XHJcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleDtcclxuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4O1xyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBlbXB0aWVzIHRoZSBub2RlcyBhbmQgZWRnZXMgYXJyYXlzLCBhcyB3ZWxsIGFzIHRoZSBkaWZmZXJlbnRcclxuICAgKiBpbmRleGVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgZ3JhcGggaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgZ3JhcGguYWRkTWV0aG9kKCdjbGVhcicsIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoID0gMDtcclxuXHJcbiAgICAvLyBEdWUgdG8gR0MgaXNzdWVzLCBJIHByZWZlciBub3QgdG8gY3JlYXRlIG5ldyBvYmplY3QuIFRoZXNlIG9iamVjdHMgYXJlXHJcbiAgICAvLyBvbmx5IGF2YWlsYWJsZSBmcm9tIHRoZSBtZXRob2RzIGFuZCBhdHRhY2hlZCBmdW5jdGlvbnMsIGJ1dCBzdGlsbCwgaXQgaXNcclxuICAgIC8vIGJldHRlciB0byBwcmV2ZW50IGdob3N0IHJlZmVyZW5jZXMgdG8gdW5yZWxldmFudCBkYXRhLi4uXHJcbiAgICB0aGlzLm5vZGVzSW5kZXguY2xlYXIoKTtcclxuICAgIHRoaXMuZWRnZXNJbmRleC5jbGVhcigpO1xyXG4gICAgdGhpcy5ub2Rlc0luZGV4LmNsZWFyKCk7XHJcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXguY2xlYXIoKTtcclxuICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXguY2xlYXIoKTtcclxuICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguY2xlYXIoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcmVhZHMgYW4gb2JqZWN0IGFuZCBhZGRzIHRoZSBub2RlcyBhbmQgZWRnZXMsIHRocm91Z2ggdGhlXHJcbiAgICogcHJvcGVyIG1ldGhvZHMgXCJhZGROb2RlXCIgYW5kIFwiYWRkRWRnZVwiLlxyXG4gICAqXHJcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlOlxyXG4gICAqXHJcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcclxuICAgKiAgPiBteUdyYXBoLnJlYWQoe1xyXG4gICAqICA+ICAgbm9kZXM6IFtcclxuICAgKiAgPiAgICAgeyBpZDogJ24wJyB9LFxyXG4gICAqICA+ICAgICB7IGlkOiAnbjEnIH1cclxuICAgKiAgPiAgIF0sXHJcbiAgICogID4gICBlZGdlczogW1xyXG4gICAqICA+ICAgICB7XHJcbiAgICogID4gICAgICAgaWQ6ICdlMCcsXHJcbiAgICogID4gICAgICAgc291cmNlOiAnbjAnLFxyXG4gICAqICA+ICAgICAgIHRhcmdldDogJ24xJ1xyXG4gICAqICA+ICAgICB9XHJcbiAgICogID4gICBdXHJcbiAgICogID4gfSk7XHJcbiAgICogID5cclxuICAgKiAgPiBjb25zb2xlLmxvZyhcclxuICAgKiAgPiAgIG15R3JhcGgubm9kZXMoKS5sZW5ndGgsXHJcbiAgICogID4gICBteUdyYXBoLmVkZ2VzKCkubGVuZ3RoXHJcbiAgICogID4gKTsgLy8gb3V0cHV0cyAyIDFcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gZyBUaGUgZ3JhcGggb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgZ3JhcGggaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgZ3JhcGguYWRkTWV0aG9kKCdyZWFkJywgZnVuY3Rpb24oZykge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgYSxcclxuICAgICAgICBsO1xyXG5cclxuICAgIGEgPSBnLm5vZGVzIHx8IFtdO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICB0aGlzLmFkZE5vZGUoYVtpXSk7XHJcblxyXG4gICAgYSA9IGcuZWRnZXMgfHwgW107XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIHRoaXMuYWRkRWRnZShhW2ldKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgb25lIG9yIHNldmVyYWwgbm9kZXMsIGRlcGVuZGluZyBvbiBob3cgaXQgaXMgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBub2RlcywgY2FsbCBcIm5vZGVzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcclxuICAgKiBzcGVjaWZpYyBub2RlLCBjYWxsIGl0IHdpdGggdGhlIGlkIG9mIHRoZSBub2RlLiBUaGUgZ2V0IG11bHRpcGxlIG5vZGUsXHJcbiAgICogY2FsbCBpdCB3aXRoIGFuIGFycmF5IG9mIGlkcywgYW5kIGl0IHdpbGwgcmV0dXJuIHRoZSBhcnJheSBvZiBub2RlcywgaW5cclxuICAgKiB0aGUgc2FtZSBvcmRlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfGFycmF5KX0gdiBFdmVudHVhbGx5IG9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxyXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBub2RlIG9yIGFycmF5IG9mIG5vZGVzLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCgnbm9kZXMnLCBmdW5jdGlvbih2KSB7XHJcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybiBpdDpcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNBcnJheS5zbGljZSgwKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxyXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0luZGV4LmdldCh2KTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgbm9kZTpcclxuICAgIGlmIChcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSdcclxuICAgICkge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICAgIGwsXHJcbiAgICAgICAgICBhID0gW107XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICBhLnB1c2godGhpcy5ub2Rlc0luZGV4LmdldCh2W2ldKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhyb3cgJ25vZGVzOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93ICdub2RlczogV3JvbmcgYXJndW1lbnRzLic7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIHRoZSBkZWdyZWUgb2Ygb25lIG9yIHNldmVyYWwgbm9kZXMsIGRlcGVuZGluZyBvbiBob3dcclxuICAgKiBpdCBpcyBjYWxsZWQuIEl0IGlzIGFsc28gcG9zc2libGUgdG8gZ2V0IGluY29taW5nIG9yIG91dGNvbWluZyBkZWdyZWVzXHJcbiAgICogaW5zdGVhZCBieSBzcGVjaWZ5aW5nICdpbicgb3IgJ291dCcgYXMgYSBzZWNvbmQgYXJndW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl9IHYgICAgIE9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxyXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgd2hpY2ggV2hpY2ggZGVncmVlIGlzIHJlcXVpcmVkLiBWYWx1ZXMgYXJlICdpbicsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3V0JywgYW5kIGJ5IGRlZmF1bHQgdGhlIG5vcm1hbCBkZWdyZWUuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfGFycmF5fSAgICAgICBUaGUgcmVsYXRlZCBkZWdyZWUgb3IgYXJyYXkgb2YgZGVncmVlcy5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QoJ2RlZ3JlZScsIGZ1bmN0aW9uKHYsIHdoaWNoKSB7XHJcbiAgICAvLyBDaGVjayB3aGljaCBkZWdyZWUgaXMgcmVxdWlyZWQ6XHJcbiAgICB3aGljaCA9IHtcclxuICAgICAgJ2luJzogdGhpcy5pbk5laWdoYm9yc0luZGV4LFxyXG4gICAgICAnb3V0JzogdGhpcy5vdXROZWlnaGJvcnNJbmRleFxyXG4gICAgfVt3aGljaCB8fCAnJ10gfHwgdGhpcy5hbGxOZWlnaGJvcnNJbmRleDtcclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcclxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKVxyXG4gICAgICByZXR1cm4gd2hpY2guZ2V0KHYpLnNpemU7XHJcblxyXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIG5vZGU6XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nKSB7XHJcbiAgICAgIHZhciBpLFxyXG4gICAgICAgICAgbCxcclxuICAgICAgICAgIGEgPSBbXTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICBpZiAodHlwZW9mIHZbaV0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2W2ldID09PSAnbnVtYmVyJylcclxuICAgICAgICAgIGEucHVzaCh3aGljaC5nZXQodltpXSkuc2l6ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhyb3cgJ2RlZ3JlZTogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyAnZGVncmVlOiBXcm9uZyBhcmd1bWVudHMuJztcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgb25lIG9yIHNldmVyYWwgZWRnZXMsIGRlcGVuZGluZyBvbiBob3cgaXQgaXMgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBlZGdlcywgY2FsbCBcImVkZ2VzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcclxuICAgKiBzcGVjaWZpYyBlZGdlLCBjYWxsIGl0IHdpdGggdGhlIGlkIG9mIHRoZSBlZGdlLiBUaGUgZ2V0IG11bHRpcGxlIGVkZ2UsXHJcbiAgICogY2FsbCBpdCB3aXRoIGFuIGFycmF5IG9mIGlkcywgYW5kIGl0IHdpbGwgcmV0dXJuIHRoZSBhcnJheSBvZiBlZGdlcywgaW5cclxuICAgKiB0aGUgc2FtZSBvcmRlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfGFycmF5KX0gdiBFdmVudHVhbGx5IG9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxyXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBlZGdlIG9yIGFycmF5IG9mIGVkZ2VzLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCgnZWRnZXMnLCBmdW5jdGlvbih2KSB7XHJcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2YgZWRnZXMgYW5kIHJldHVybiBpdDpcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNBcnJheS5zbGljZSgwKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgZWRnZTpcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxyXG4gICAgICByZXR1cm4gdGhpcy5lZGdlc0luZGV4LmdldCh2KTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgZWRnZTpcclxuICAgIGlmIChcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSdcclxuICAgICkge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICAgIGwsXHJcbiAgICAgICAgICBhID0gW107XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICBhLnB1c2godGhpcy5lZGdlc0luZGV4LmdldCh2W2ldKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93ICdlZGdlczogV3JvbmcgYXJndW1lbnRzLic7XHJcbiAgfSk7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFWFBPUlQ6XHJcbiAgICogKioqKioqKlxyXG4gICAqL1xyXG4gIGlmICh0eXBlb2Ygc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBzaWdtYS5jbGFzc2VzID0gc2lnbWEuY2xhc3NlcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgc2lnbWEuY2xhc3Nlcy5ncmFwaCA9IGdyYXBoO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoO1xyXG4gICAgZXhwb3J0cy5ncmFwaCA9IGdyYXBoO1xyXG4gIH0gZWxzZVxyXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2xhc3NlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgY2FtZXJhIGNvbnN0cnVjdG9yLiBJdCBqdXN0IGluaXRpYWxpemVzIGl0cyBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICBpZCAgICAgICBUaGUgaWQuXHJcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gIGdyYXBoICAgIFRoZSBncmFwaC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICAgIG9wdGlvbnMgIEV2ZW50dWFsbHkgc29tZSBvdmVycmlkaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhID0gZnVuY3Rpb24oaWQsIGdyYXBoLCBzZXR0aW5ncywgb3B0aW9ucykge1xyXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dyYXBoJywge1xyXG4gICAgICB2YWx1ZTogZ3JhcGhcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcclxuICAgICAgdmFsdWU6IGlkXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhZFByZWZpeCcsIHtcclxuICAgICAgdmFsdWU6ICdyZWFkX2NhbScgKyBpZCArICc6J1xyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZWZpeCcsIHtcclxuICAgICAgdmFsdWU6ICdjYW0nICsgaWQgKyAnOidcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMueCA9IDA7XHJcbiAgICB0aGlzLnkgPSAwO1xyXG4gICAgdGhpcy5yYXRpbyA9IDE7XHJcbiAgICB0aGlzLmFuZ2xlID0gMDtcclxuICAgIHRoaXMuaXNBbmltYXRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5zZXR0aW5ncyA9ICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucykgP1xyXG4gICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdChvcHRpb25zKSA6XHJcbiAgICAgIHNldHRpbmdzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGNhbWVyYSBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29vcmRpbmF0ZXMgVGhlIG5ldyBjb29yZGluYXRlcyBvYmplY3QuXHJcbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBjYW1lcmEuXHJcbiAgICovXHJcbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdvVG8gPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xyXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzKCdlbmFibGVDYW1lcmEnKSlcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBjID0gY29vcmRpbmF0ZXMgfHwge30sXHJcbiAgICAgICAga2V5cyA9ICgncmF0aW8nIGluIGNvb3JkaW5hdGVzICYmICF0aGlzLnNldHRpbmdzKCd6b29tT25Mb2NhdGlvbicpKVxyXG4gICAgICAgICAgPyBbJ3JhdGlvJywgJ2FuZ2xlJ10gOiBbJ3gnLCAneScsICdyYXRpbycsICdhbmdsZSddO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgaWYgKGNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY1trZXlzW2ldXSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGNba2V5c1tpXV0pKVxyXG4gICAgICAgICAgdGhpc1trZXlzW2ldXSA9IGNba2V5c1tpXV07XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhyb3cgJ1ZhbHVlIGZvciBcIicgKyBrZXlzW2ldICsgJ1wiIGlzIG5vdCBhIG51bWJlci4nO1xyXG4gICAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdjb29yZGluYXRlc1VwZGF0ZWQnKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgZ3JhcGggYW5kIGNvbXB1dGVzIGZvciBlYWNoIG5vZGUgYW5kIGVkZ2VzIGl0c1xyXG4gICAqIGNvb3JkaW5hdGVzIHJlbGF0aXZlbHkgdG8gdGhlIGNlbnRlciBvZiB0aGUgY2FtZXJhLiBCYXNpY2FsbHksIGl0IHdpbGxcclxuICAgKiBjb21wdXRlIHRoZSBjb29yZGluYXRlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgZ3JhcGhpYyByZW5kZXJlcnMuXHJcbiAgICpcclxuICAgKiBTaW5jZSBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGRpZmZlcmVudCBjYW1lcmFzIGFuZCBkaWZmZXJlbnRcclxuICAgKiByZW5kZXJlcnMsIGl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYSBwcmVmaXggdG8gcHV0IGJlZm9yZSB0aGUgbmV3XHJcbiAgICogY29vcmRpbmF0ZXMgKHRvIGdldCBzb21ldGhpbmcgbGlrZSBcIm5vZGUuY2FtZXJhMV94XCIpXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSByZWFkICAgIFRoZSBwcmVmaXggb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHJlYWQuXHJcbiAgICogQHBhcmFtICB7P3N0cmluZ30gd3JpdGUgICBUaGUgcHJlZml4IG9mIHRoZSBjb29yZGluYXRlcyB0byB3cml0ZS5cclxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IG9mIG9wdGlvbnMuIFRob3NlIGNhbiBiZTpcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIG5vZGVzIGFycmF5LlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHJlc3RyaWN0ZWQgZWRnZXMgYXJyYXkuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgd2lkdGguXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgaGVpZ2h0LlxyXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgIFJldHVybnMgdGhlIGNhbWVyYS5cclxuICAgKi9cclxuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuYXBwbHlWaWV3ID0gZnVuY3Rpb24ocmVhZCwgd3JpdGUsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgd3JpdGUgPSB3cml0ZSAhPT0gdW5kZWZpbmVkID8gd3JpdGUgOiB0aGlzLnByZWZpeDtcclxuICAgIHJlYWQgPSByZWFkICE9PSB1bmRlZmluZWQgPyByZWFkIDogdGhpcy5yZWFkUHJlZml4O1xyXG5cclxuICAgIHZhciBub2RlcyA9IG9wdGlvbnMubm9kZXMgfHwgdGhpcy5ncmFwaC5ub2RlcygpLFxyXG4gICAgICAgIGVkZ2VzID0gb3B0aW9ucy5lZGdlcyB8fCB0aGlzLmdyYXBoLmVkZ2VzKCk7XHJcblxyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBub2RlLFxyXG4gICAgICAgIHJlbENvcyA9IE1hdGguY29zKHRoaXMuYW5nbGUpIC8gdGhpcy5yYXRpbyxcclxuICAgICAgICByZWxTaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXHJcbiAgICAgICAgbm9kZVJhdGlvID0gTWF0aC5wb3codGhpcy5yYXRpbywgdGhpcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKSxcclxuICAgICAgICBlZGdlUmF0aW8gPSBNYXRoLnBvdyh0aGlzLnJhdGlvLCB0aGlzLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpLFxyXG4gICAgICAgIHhPZmZzZXQgPSAob3B0aW9ucy53aWR0aCB8fCAwKSAvIDIgLSB0aGlzLnggKiByZWxDb3MgLSB0aGlzLnkgKiByZWxTaW4sXHJcbiAgICAgICAgeU9mZnNldCA9IChvcHRpb25zLmhlaWdodCB8fCAwKSAvIDIgLSB0aGlzLnkgKiByZWxDb3MgKyB0aGlzLnggKiByZWxTaW47XHJcblxyXG4gICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgIG5vZGVbd3JpdGUgKyAneCddID1cclxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbENvcyArXHJcbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxTaW4gK1xyXG4gICAgICAgIHhPZmZzZXQ7XHJcbiAgICAgIG5vZGVbd3JpdGUgKyAneSddID1cclxuICAgICAgICAobm9kZVtyZWFkICsgJ3knXSB8fCAwKSAqIHJlbENvcyAtXHJcbiAgICAgICAgKG5vZGVbcmVhZCArICd4J10gfHwgMCkgKiByZWxTaW4gK1xyXG4gICAgICAgIHlPZmZzZXQ7XHJcbiAgICAgIG5vZGVbd3JpdGUgKyAnc2l6ZSddID1cclxuICAgICAgICAobm9kZVtyZWFkICsgJ3NpemUnXSB8fCAwKSAvXHJcbiAgICAgICAgbm9kZVJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgZWRnZXNbaV1bd3JpdGUgKyAnc2l6ZSddID1cclxuICAgICAgICAoZWRnZXNbaV1bcmVhZCArICdzaXplJ10gfHwgMCkgL1xyXG4gICAgICAgIGVkZ2VSYXRpbztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lIG9mIHRoZVxyXG4gICAqIGNhbWVyYSB0byB0aGUgZnJhbWUgb2YgdGhlIGdyYXBoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgY2FtZXJhLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgIGNhbWVyYS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIHBvaW50IGNvb3JkaW5hdGVzIGluIHRoZSBmcmFtZSBvZiB0aGUgZ3JhcGguXHJcbiAgICovXHJcbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdyYXBoUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB2ZWN0b3IpIHtcclxuICAgIHZhciBYID0gMCxcclxuICAgICAgICBZID0gMCxcclxuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcclxuICAgICAgICBzaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKTtcclxuXHJcbiAgICAvLyBSZXZlcnQgdGhlIG9yaWdpbiBkaWZmZXJlbnRpYWwgdmVjdG9yOlxyXG4gICAgaWYgKCF2ZWN0b3IpIHtcclxuICAgICAgWCA9IC0gKHRoaXMueCAqIGNvcyArIHRoaXMueSAqIHNpbikgLyB0aGlzLnJhdGlvO1xyXG4gICAgICBZID0gLSAodGhpcy55ICogY29zIC0gdGhpcy54ICogc2luKSAvIHRoaXMucmF0aW87XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogKHggKiBjb3MgKyB5ICogc2luKSAvIHRoaXMucmF0aW8gKyBYLFxyXG4gICAgICB5OiAoeSAqIGNvcyAtIHggKiBzaW4pIC8gdGhpcy5yYXRpbyArIFlcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZSBvZiB0aGVcclxuICAgKiBncmFwaCB0byB0aGUgZnJhbWUgb2YgdGhlIGNhbWVyYS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgIGdyYXBoLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgIGdyYXBoLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBjYW1lcmEuXHJcbiAgICovXHJcbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmNhbWVyYVBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgdmVjdG9yKSB7XHJcbiAgICB2YXIgWCA9IDAsXHJcbiAgICAgICAgWSA9IDAsXHJcbiAgICAgICAgY29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSksXHJcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XHJcblxyXG4gICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW4gZGlmZmVyZW50aWFsIHZlY3RvcjpcclxuICAgIGlmICghdmVjdG9yKSB7XHJcbiAgICAgIFggPSAtICh0aGlzLnggKiBjb3MgKyB0aGlzLnkgKiBzaW4pIC8gdGhpcy5yYXRpbztcclxuICAgICAgWSA9IC0gKHRoaXMueSAqIGNvcyAtIHRoaXMueCAqIHNpbikgLyB0aGlzLnJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6ICgoeCAtIFgpICogY29zIC0gKHkgLSBZKSAqIHNpbikgKiB0aGlzLnJhdGlvLFxyXG4gICAgICB5OiAoKHkgLSBZKSAqIGNvcyArICh4IC0gWCkgKiBzaW4pICogdGhpcy5yYXRpb1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYS4gVGhpcyBpc1xyXG4gICAqIGVzcGVjaWFsbHkgdXNlZnVsIHRvIGFwcGx5IHRoZSBjYW1lcmEgdmlldyBkaXJlY3RseSBpbiBzaGFkZXJzLCBpbiBjYXNlIG9mXHJcbiAgICogV2ViR0wgcmVuZGVyaW5nLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YXJyYXl9IFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXHJcbiAgICovXHJcbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNjYWxlID0gc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUoMSAvIHRoaXMucmF0aW8pLFxyXG4gICAgICAgIHJvdGF0aW9uID0gc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24odGhpcy5hbmdsZSksXHJcbiAgICAgICAgdHJhbnNsYXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbigtdGhpcy54LCAtdGhpcy55KSxcclxuICAgICAgICBtYXRyaXggPSBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseShcclxuICAgICAgICAgIHRyYW5zbGF0aW9uLFxyXG4gICAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXHJcbiAgICAgICAgICAgIHJvdGF0aW9uLFxyXG4gICAgICAgICAgICBzY2FsZVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgcmV0dXJuIG1hdHJpeDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUYWtpbmcgYSB3aWR0aCBhbmQgYSBoZWlnaHQgYXMgcGFyYW1ldGVycywgdGhpcyBtZXRob2QgcmV0dXJucyB0aGVcclxuICAgKiBjb29yZGluYXRlcyBvZiB0aGUgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGUgY2FtZXJhIG9uIHNjcmVlbiwgaW4gdGhlXHJcbiAgICogZ3JhcGgncyByZWZlcmVudGllbC5cclxuICAgKlxyXG4gICAqIFRvIGtlZXAgZGlzcGxheWluZyBsYWJlbHMgb2Ygbm9kZXMgZ29pbmcgb3V0IG9mIHRoZSBzY3JlZW4sIHRoZSBtZXRob2RcclxuICAgKiBrZWVwcyBhIG1hcmdpbiBhcm91bmQgdGhlIHNjcmVlbiBpbiB0aGUgcmV0dXJuZWQgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aCAgVGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSByZWN0YW5nbGUgYXMgeDEsIHkxLCB4MiBhbmQgeTIsIHJlcHJlc2VudGluZ1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHR3byBvcHBvc2l0ZSBwb2ludHMuXHJcbiAgICovXHJcbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldFJlY3RhbmdsZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciB3aWR0aFZlY3QgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoLCAwLCB0cnVlKSxcclxuICAgICAgICBoZWlnaHRWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbigwLCBoZWlnaHQsIHRydWUpLFxyXG4gICAgICAgIGNlbnRlclZlY3QgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgdHJ1ZSksXHJcbiAgICAgICAgbWFyZ2luWCA9IHRoaXMuY2FtZXJhUG9zaXRpb24od2lkdGggLyA0LCAwLCB0cnVlKS54LFxyXG4gICAgICAgIG1hcmdpblkgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKDAsIGhlaWdodCAvIDQsIHRydWUpLnk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDE6IHRoaXMueCAtIGNlbnRlclZlY3QueCAtIG1hcmdpblgsXHJcbiAgICAgIHkxOiB0aGlzLnkgLSBjZW50ZXJWZWN0LnkgLSBtYXJnaW5ZLFxyXG4gICAgICB4MjogdGhpcy54IC0gY2VudGVyVmVjdC54ICsgbWFyZ2luWCArIHdpZHRoVmVjdC54LFxyXG4gICAgICB5MjogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSArIHdpZHRoVmVjdC55LFxyXG4gICAgICBoZWlnaHQ6IE1hdGguc3FydChcclxuICAgICAgICBNYXRoLnBvdyhoZWlnaHRWZWN0LngsIDIpICtcclxuICAgICAgICBNYXRoLnBvdyhoZWlnaHRWZWN0LnkgKyAyICogbWFyZ2luWSwgMilcclxuICAgICAgKVxyXG4gICAgfTtcclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNpZ21hIFF1YWR0cmVlIE1vZHVsZVxyXG4gICAqID09PT09PT09PT09PT09PT09PT09PVxyXG4gICAqXHJcbiAgICogQXV0aG9yOiBHdWlsbGF1bWUgUGxpcXVlIChZb21ndWl0aGVyZWFsKSwgU8OpYmFzdGllbiBIZXltYW5uLCBEYW1pZW4gTWFyacOpXHJcbiAgICovXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKlxyXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxyXG4gICAqL1xyXG5cclxuICB2YXIgX2dlb20gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxyXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDE6IG4ueCAtIG4uc2l6ZSxcclxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxyXG4gICAgICAgIHgyOiBuLnggKyBuLnNpemUsXHJcbiAgICAgICAgeTI6IG4ueSAtIG4uc2l6ZSxcclxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIGVkZ2Ugd2l0aCB4MSwgeTEsIHgyLCB5MiBhbmQgc2l6ZSBpbnRvIGFuXHJcbiAgICAgKiBheGlzLWFsaWduZWQgc3F1YXJlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBncmFwaCBlZGdlIHdpdGggYXQgbGVhc3QgdHdvIHBvaW50c1xyXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGEgc2l6ZS5cclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXHJcbiAgICAgKi9cclxuICAgIGxpbmVUb1NxdWFyZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICBpZiAoZS55MSA8IGUueTIpIHtcclxuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gdG9wXHJcbiAgICAgICAgaWYgKGUueDEgPCBlLngyKSB7XHJcbiAgICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gbGVmdFxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDE6IGUueDEgLSBlLnNpemUsXHJcbiAgICAgICAgICAgIHkxOiBlLnkxIC0gZS5zaXplLFxyXG4gICAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcclxuICAgICAgICAgICAgeTI6IGUueTEgLSBlLnNpemUsXHJcbiAgICAgICAgICAgIGhlaWdodDogZS55MiAtIGUueTEgKyBlLnNpemUgKiAyXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gcmlnaHRcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDE6IGUueDIgLSBlLnNpemUsXHJcbiAgICAgICAgICB5MTogZS55MSAtIGUuc2l6ZSxcclxuICAgICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxyXG4gICAgICAgICAgeTI6IGUueTEgLSBlLnNpemUsXHJcbiAgICAgICAgICBoZWlnaHQ6IGUueTIgLSBlLnkxICsgZS5zaXplICogMlxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIChlLngyLCBlLnkyKSBvbiB0b3BcclxuICAgICAgaWYgKGUueDEgPCBlLngyKSB7XHJcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIGxlZnRcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDE6IGUueDEgLSBlLnNpemUsXHJcbiAgICAgICAgICB5MTogZS55MiAtIGUuc2l6ZSxcclxuICAgICAgICAgIHgyOiBlLngyICsgZS5zaXplLFxyXG4gICAgICAgICAgeTI6IGUueTIgLSBlLnNpemUsXHJcbiAgICAgICAgICBoZWlnaHQ6IGUueTEgLSBlLnkyICsgZS5zaXplICogMlxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgLy8gKGUueDIsIGUueTIpIG9uIHJpZ2h0XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDE6IGUueDIgLSBlLnNpemUsXHJcbiAgICAgICAgeTE6IGUueTIgLSBlLnNpemUsXHJcbiAgICAgICAgeDI6IGUueDEgKyBlLnNpemUsXHJcbiAgICAgICAgeTI6IGUueTIgLSBlLnNpemUsXHJcbiAgICAgICAgaGVpZ2h0OiBlLnkxIC0gZS55MiArIGUuc2l6ZSAqIDJcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggZWRnZSBvZiB0eXBlICdjdXJ2ZScgd2l0aCB4MSwgeTEsIHgyLCB5MixcclxuICAgICAqIGNvbnRyb2wgcG9pbnQgYW5kIHNpemUgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gZSAgQSBncmFwaCBlZGdlIHdpdGggYXQgbGVhc3QgdHdvIHBvaW50c1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGEgc2l6ZS5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gY3AgQSBjb250cm9sIHBvaW50ICh4LHkpLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgcXVhZHJhdGljQ3VydmVUb1NxdWFyZTogZnVuY3Rpb24oZSwgY3ApIHtcclxuICAgICAgdmFyIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKFxyXG4gICAgICAgIDAuNSxcclxuICAgICAgICBlLngxLFxyXG4gICAgICAgIGUueTEsXHJcbiAgICAgICAgZS54MixcclxuICAgICAgICBlLnkyLFxyXG4gICAgICAgIGNwLngsXHJcbiAgICAgICAgY3AueVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSB0d28gcG9pbnRzIGFuZCB0aGUgcG9pbnQgYXQgdGhlIG1pZGRsZSBvZiB0aGVcclxuICAgICAgLy8gY3VydmU6XHJcbiAgICAgIHZhciBtaW5YID0gTWF0aC5taW4oZS54MSwgZS54MiwgcHQueCksXHJcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoZS54MSwgZS54MiwgcHQueCksXHJcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4oZS55MSwgZS55MiwgcHQueSksXHJcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgoZS55MSwgZS55MiwgcHQueSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHgxOiBtaW5YIC0gZS5zaXplLFxyXG4gICAgICAgIHkxOiBtaW5ZIC0gZS5zaXplLFxyXG4gICAgICAgIHgyOiBtYXhYICsgZS5zaXplLFxyXG4gICAgICAgIHkyOiBtaW5ZIC0gZS5zaXplLFxyXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBlLnNpemUgKiAyXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIHNlbGYgbG9vcCBpbnRvIGFuIGF4aXMtYWxpZ25lZCBzcXVhcmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBuIEEgZ3JhcGggbm9kZSB3aXRoIGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXHJcbiAgICAgKi9cclxuICAgIHNlbGZMb29wVG9TcXVhcmU6IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgLy8gRml0dGluZyB0byB0aGUgY3VydmUgaXMgdG9vIGNvc3RseSwgd2UgY29tcHV0ZSBhIGxhcmdlciBib3VuZGluZyBib3hcclxuICAgICAgLy8gdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzOlxyXG4gICAgICB2YXIgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMobi54LCBuLnksIG4uc2l6ZSk7XHJcblxyXG4gICAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHBvaW50IGFuZCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzOlxyXG4gICAgICB2YXIgbWluWCA9IE1hdGgubWluKG4ueCwgY3AueDEsIGNwLngyKSxcclxuICAgICAgICAgIG1heFggPSBNYXRoLm1heChuLngsIGNwLngxLCBjcC54MiksXHJcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obi55LCBjcC55MSwgY3AueTIpLFxyXG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG4ueSwgY3AueTEsIGNwLnkyKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDE6IG1pblggLSBuLnNpemUsXHJcbiAgICAgICAgeTE6IG1pblkgLSBuLnNpemUsXHJcbiAgICAgICAgeDI6IG1heFggKyBuLnNpemUsXHJcbiAgICAgICAgeTI6IG1pblkgLSBuLnNpemUsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSArIG4uc2l6ZSAqIDJcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxyXG4gICAgICovXHJcbiAgICBpc0F4aXNBbGlnbmVkOiBmdW5jdGlvbihyKSB7XHJcbiAgICAgIHJldHVybiByLngxID09PSByLngyIHx8IHIueTEgPT09IHIueTI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0b3AgcG9pbnRzIG9mIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUuIFRoaXMgaXMgdXNlZnVsIGluXHJcbiAgICAgKiBjYXNlcyB3aGVuIHRoZSByZWN0YW5nbGUgaGFzIGJlZW4gcm90YXRlZCAobGVmdCwgcmlnaHQgb3IgYm90dG9tIHVwKSBhbmRcclxuICAgICAqIGxhdGVyIG9wZXJhdGlvbnMgbmVlZCB0byBrbm93IHRoZSB0b3AgcG9pbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHNcclxuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmVjdGFuZ2xlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBheGlzQWxpZ25lZFRvcFBvaW50czogZnVuY3Rpb24ocikge1xyXG5cclxuICAgICAgLy8gQmFzaWNcclxuICAgICAgaWYgKHIueTEgPT09IHIueTIgJiYgci54MSA8IHIueDIpXHJcbiAgICAgICAgcmV0dXJuIHI7XHJcblxyXG4gICAgICAvLyBSb3RhdGVkIHRvIHJpZ2h0XHJcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPiByLnkxKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB4MTogci54MSAtIHIuaGVpZ2h0LCB5MTogci55MSxcclxuICAgICAgICAgIHgyOiByLngxLCB5Mjogci55MSxcclxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgLy8gUm90YXRlZCB0byBsZWZ0XHJcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPCByLnkxKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB4MTogci54MSwgeTE6IHIueTIsXHJcbiAgICAgICAgICB4Mjogci54MiArIHIuaGVpZ2h0LCB5Mjogci55MixcclxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgLy8gQm90dG9tJ3MgdXBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4MTogci54MiwgeTE6IHIueTEgLSByLmhlaWdodCxcclxuICAgICAgICB4Mjogci54MSwgeTI6IHIueTEgLSByLmhlaWdodCxcclxuICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgbGVmdCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxyXG4gICAgICovXHJcbiAgICBsb3dlckxlZnRDb29yOiBmdW5jdGlvbihyKSB7XHJcbiAgICAgIHZhciB3aWR0aCA9IChcclxuICAgICAgICBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAoci54MiAtIHIueDEpICogKHIueDIgLSByLngxKSArXHJcbiAgICAgICAgICAoci55MiAtIHIueTEpICogKHIueTIgLSByLnkxKVxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogci54MSAtIChyLnkyIC0gci55MSkgKiByLmhlaWdodCAvIHdpZHRoLFxyXG4gICAgICAgIHk6IHIueTEgKyAoci54MiAtIHIueDEpICogci5oZWlnaHQgLyB3aWR0aFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIHJpZ2h0IGNvcm5lciBmcm9tIGl0cyB0b3AgcG9pbnRzXHJcbiAgICAgKiBhbmQgaXRzIGxvd2VyIGxlZnQgY29ybmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBjb3JuZXIncyBjb29yZGluYXRlcyAoeCwgeSkuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxyXG4gICAgICovXHJcbiAgICBsb3dlclJpZ2h0Q29vcjogZnVuY3Rpb24ociwgbGxjKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogbGxjLnggLSByLngxICsgci54MixcclxuICAgICAgICB5OiBsbGMueSAtIHIueTEgKyByLnkyXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiBhbGwgdGhlIGNvcm5lcnMgb2YgYSByZWN0YW5nbGUgZnJvbSBpdHMgdG9wIHBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cclxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2YgdGhlIGZvdXIgY29ybmVycycgY29vcmRpbmF0ZXMgKHgsIHkpLlxyXG4gICAgICovXHJcbiAgICByZWN0YW5nbGVDb3JuZXJzOiBmdW5jdGlvbihyKSB7XHJcbiAgICAgIHZhciBsbGMgPSB0aGlzLmxvd2VyTGVmdENvb3IociksXHJcbiAgICAgICAgICBscmMgPSB0aGlzLmxvd2VyUmlnaHRDb29yKHIsIGxsYyk7XHJcblxyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIHt4OiByLngxLCB5OiByLnkxfSxcclxuICAgICAgICB7eDogci54MiwgeTogci55Mn0sXHJcbiAgICAgICAge3g6IGxsYy54LCB5OiBsbGMueX0sXHJcbiAgICAgICAge3g6IGxyYy54LCB5OiBscmMueX1cclxuICAgICAgXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGxpdCBhIHNxdWFyZSBkZWZpbmVkIGJ5IGl0cyBib3VuZGFyaWVzIGludG8gZm91ci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEJvdW5kYXJpZXMgb2YgdGhlIHNxdWFyZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkuXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZvdXIgbmV3IHNxdWFyZXMsIHRoZW1zZWx2ZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgZGVmaW5lZCBieSBhbiBhcnJheSBvZiB0aGVpciBmb3VyIGNvcm5lcnMgKHgsIHkpLlxyXG4gICAgICovXHJcbiAgICBzcGxpdFNxdWFyZTogZnVuY3Rpb24oYikge1xyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIFtcclxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueX0sXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXHJcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBbXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55fSxcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBbXHJcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxyXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHR9LFxyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH0sXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHR9XHJcbiAgICAgICAgXVxyXG4gICAgICBdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGZvdXIgYXhpcyBiZXR3ZWVuIGNvcm5lcnMgb2YgcmVjdGFuZ2xlIEEgYW5kIGNvcm5lcnMgb2ZcclxuICAgICAqIHJlY3RhbmdsZSBCLiBUaGlzIGlzIG5lZWRlZCBsYXRlciB0byBjaGVjayBhbiBldmVudHVhbCBjb2xsaXNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBBJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQidzIGZvdXIgY29ybmVycyAoeCwgeSkuXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgZm91ciBheGlzIGRlZmluZWQgYnkgdGhlaXIgY29vcmRpbmF0ZXMgKHgseSkuXHJcbiAgICAgKi9cclxuICAgIGF4aXM6IGZ1bmN0aW9uKGMxLCBjMikge1xyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbMF0ueCwgeTogYzFbMV0ueSAtIGMxWzBdLnl9LFxyXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbM10ueCwgeTogYzFbMV0ueSAtIGMxWzNdLnl9LFxyXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMl0ueCwgeTogYzJbMF0ueSAtIGMyWzJdLnl9LFxyXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMV0ueCwgeTogYzJbMF0ueSAtIGMyWzFdLnl9XHJcbiAgICAgIF07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdCBhIHJlY3RhbmdsZSdzIGNvcm5lciBvbiBhbiBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBjb3JuZXIgKHgsIHkpLlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhbiBheGlzICh4LCB5KS5cclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHByb2plY3Rpb24gZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXHJcbiAgICAgKi9cclxuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKGMsIGEpIHtcclxuICAgICAgdmFyIGwgPSAoXHJcbiAgICAgICAgKGMueCAqIGEueCArIGMueSAqIGEueSkgL1xyXG4gICAgICAgIChhLnggKiBhLnggKyBhLnkgKiBhLnkpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGwgKiBhLngsXHJcbiAgICAgICAgeTogbCAqIGEueVxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBvbmUgcGFydGljdWxhciBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICBBbiBheGlzJyBjb29yZGluYXRlcyAoeCwgeSkuXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUgb24gdGhlIGF4aXMuXHJcbiAgICAgKi9cclxuICAgIGF4aXNDb2xsaXNpb246IGZ1bmN0aW9uKGEsIGMxLCBjMikge1xyXG4gICAgICB2YXIgc2MxID0gW10sXHJcbiAgICAgICAgICBzYzIgPSBbXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCA0OyBjaSsrKSB7XHJcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9qZWN0aW9uKGMxW2NpXSwgYSksXHJcbiAgICAgICAgICAgIHAyID0gdGhpcy5wcm9qZWN0aW9uKGMyW2NpXSwgYSk7XHJcblxyXG4gICAgICAgIHNjMS5wdXNoKHAxLnggKiBhLnggKyBwMS55ICogYS55KTtcclxuICAgICAgICBzYzIucHVzaChwMi54ICogYS54ICsgcDIueSAqIGEueSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBtYXhjMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMSksXHJcbiAgICAgICAgICBtYXhjMiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMiksXHJcbiAgICAgICAgICBtaW5jMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMSksXHJcbiAgICAgICAgICBtaW5jMiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMik7XHJcblxyXG4gICAgICByZXR1cm4gKG1pbmMyIDw9IG1heGMxICYmIG1heGMyID49IG1pbmMxKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gZWFjaCBvbmUgb2YgdGhlaXIgZm91ciBheGlzLiBJZlxyXG4gICAgICogYWxsIGF4aXMgY29sbGlkZSwgdGhlbiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gY29sbGlkZSBvbiB0aGUgcGxhbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cclxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlLlxyXG4gICAgICovXHJcbiAgICBjb2xsaXNpb246IGZ1bmN0aW9uKGMxLCBjMikge1xyXG4gICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyhjMSwgYzIpLFxyXG4gICAgICAgICAgY29sID0gdHJ1ZTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxyXG4gICAgICAgIGNvbCA9IGNvbCAmJiB0aGlzLmF4aXNDb2xsaXNpb24oYXhpc1tpXSwgYzEsIGMyKTtcclxuXHJcbiAgICAgIHJldHVybiBjb2w7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFF1YWQgRnVuY3Rpb25zXHJcbiAgICogLS0tLS0tLS0tLS0tXHJcbiAgICpcclxuICAgKiBUaGUgUXVhZHRyZWUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMuXHJcbiAgICogRm9yIGVhY2ggb2YgdGhvc2UgZnVuY3Rpb25zLCB3ZSBjb25zaWRlciB0aGF0IGluIGEgc3BsaXR0ZWQgcXVhZCwgdGhlXHJcbiAgICogaW5kZXggb2YgZWFjaCBub2RlIGlzIHRoZSBmb2xsb3dpbmc6XHJcbiAgICogMDogdG9wIGxlZnRcclxuICAgKiAxOiB0b3AgcmlnaHRcclxuICAgKiAyOiBib3R0b20gbGVmdFxyXG4gICAqIDM6IGJvdHRvbSByaWdodFxyXG4gICAqXHJcbiAgICogTW9yZW92ZXIsIHRoZSBoZXJlYWZ0ZXIgcXVhZCdzIHBoaWxvc29waHkgaXMgdG8gY29uc2lkZXIgdGhhdCBpZiBhbiBlbGVtZW50XHJcbiAgICogY29sbGlkZXMgd2l0aCBtb3JlIHRoYW4gb25lIG5vZGVzLCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byBlYWNoIG9mIHRoZVxyXG4gICAqIG5vZGVzIGl0IGNvbGxpZGVzIHdpdGggd2hlcmUgb3RoZXIgd291bGQgbGV0IGl0IGxpZSBvbiBhIGhpZ2hlciBub2RlLlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50IGluIHRoZSBxdWFkXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCAgICAgIEEgcG9pbnQgZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZEJvdW5kcyBCb3VuZGFyaWVzIG9mIHRoZSBxdWFkICh4LCB5LCB3aWR0aCwgaGVpZ3RoKS5cclxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfcXVhZEluZGV4KHBvaW50LCBxdWFkQm91bmRzKSB7XHJcbiAgICB2YXIgeG1wID0gcXVhZEJvdW5kcy54ICsgcXVhZEJvdW5kcy53aWR0aCAvIDIsXHJcbiAgICAgICAgeW1wID0gcXVhZEJvdW5kcy55ICsgcXVhZEJvdW5kcy5oZWlnaHQgLyAyLFxyXG4gICAgICAgIHRvcCA9IChwb2ludC55IDwgeW1wKSxcclxuICAgICAgICBsZWZ0ID0gKHBvaW50LnggPCB4bXApO1xyXG5cclxuICAgIGlmICh0b3ApIHtcclxuICAgICAgaWYgKGxlZnQpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAobGVmdClcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiAzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcmVjdGFuZ2xlICAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MiwgeTIpIGFuZCBoZWlnaHQuXHJcbiAgICogQHBhcmFtICB7YXJyYXl9ICAgcXVhZENvcm5lcnMgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5kZXhlcyBjb250YWluaW5nIG9uZSB0b1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3F1YWRJbmRleGVzKHJlY3RhbmdsZSwgcXVhZENvcm5lcnMpIHtcclxuICAgIHZhciBpbmRleGVzID0gW107XHJcblxyXG4gICAgLy8gSXRlcmF0aW5nIHRocm91Z2ggcXVhZHNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxyXG4gICAgICBpZiAoKHJlY3RhbmdsZS54MiA+PSBxdWFkQ29ybmVyc1tpXVswXS54KSAmJlxyXG4gICAgICAgICAgKHJlY3RhbmdsZS54MSA8PSBxdWFkQ29ybmVyc1tpXVsxXS54KSAmJlxyXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSArIHJlY3RhbmdsZS5oZWlnaHQgPj0gcXVhZENvcm5lcnNbaV1bMF0ueSkgJiZcclxuICAgICAgICAgIChyZWN0YW5nbGUueTEgPD0gcXVhZENvcm5lcnNbaV1bMl0ueSkpXHJcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xyXG5cclxuICAgIHJldHVybiBpbmRleGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYSBub24tYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7YXJyYXl9ICBjb3JuZXJzICAgICAgQW4gYXJyYXkgY29udGFpbmluZyBlYWNoIGNvcm5lciBvZiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgZGVmaW5lZCBieSBpdHMgY29vcmRpbmF0ZXMgKHgsIHkpLlxyXG4gICAqIEBwYXJhbSAge2FycmF5fSAgcXVhZENvcm5lcnMgIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9xdWFkQ29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzKSB7XHJcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xyXG5cclxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcclxuICAgICAgaWYgKF9nZW9tLmNvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVyc1tpXSkpXHJcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xyXG5cclxuICAgIHJldHVybiBpbmRleGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3ViZGl2aWRlIGEgcXVhZCBieSBjcmVhdGluZyBhIG5vZGUgYXQgYSBwcmVjaXNlIGluZGV4LiBUaGUgZnVuY3Rpb24gZG9lc1xyXG4gICAqIG5vdCBnZW5lcmF0ZSBhbGwgZm91ciBub2RlcyBub3QgdG8gcG90ZW50aWFsbHkgY3JlYXRlIHVudXNlZCBub2Rlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY3JlYXRlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBxdWFkICBUaGUgcXVhZCBvYmplY3QgdG8gc3ViZGl2aWRlLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBBIG5ldyBxdWFkIHJlcHJlc2VudGluZyB0aGUgbm9kZSBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9xdWFkU3ViZGl2aWRlKGluZGV4LCBxdWFkKSB7XHJcbiAgICB2YXIgbmV4dCA9IHF1YWQubGV2ZWwgKyAxLFxyXG4gICAgICAgIHN1YncgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLndpZHRoIC8gMiksXHJcbiAgICAgICAgc3ViaCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMuaGVpZ2h0IC8gMiksXHJcbiAgICAgICAgcXggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLngpLFxyXG4gICAgICAgIHF5ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy55KSxcclxuICAgICAgICB4LFxyXG4gICAgICAgIHk7XHJcblxyXG4gICAgc3dpdGNoIChpbmRleCkge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgeCA9IHF4O1xyXG4gICAgICAgIHkgPSBxeTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHggPSBxeCArIHN1Ync7XHJcbiAgICAgICAgeSA9IHF5O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgeCA9IHF4O1xyXG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xyXG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9xdWFkVHJlZShcclxuICAgICAge3g6IHgsIHk6IHksIHdpZHRoOiBzdWJ3LCBoZWlnaHQ6IHN1Ymh9LFxyXG4gICAgICBuZXh0LFxyXG4gICAgICBxdWFkLm1heEVsZW1lbnRzLFxyXG4gICAgICBxdWFkLm1heExldmVsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVjdXJzaXZlbHkgaW5zZXJ0IGFuIGVsZW1lbnQgaW50byB0aGUgcXVhZHRyZWUuIE9ubHkgcG9pbnRzXHJcbiAgICogd2l0aCBzaXplLCBpLmUuIGF4aXMtYWxpZ25lZCBzcXVhcmVzLCBtYXkgYmUgaW5zZXJ0ZWQgd2l0aCB0aGlzXHJcbiAgICogbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgZWwgICAgICAgICBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHF1YWR0cmVlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHNpemVkUG9pbnQgQSBzaXplZCBwb2ludCBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICAgICAgIFRoZSBxdWFkIGluIHdoaWNoIHRvIGluc2VydCB0aGUgZWxlbWVudC5cclxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgICAgIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQpIHtcclxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xyXG5cclxuICAgICAgLy8gU2VhcmNoaW5nIGFwcHJvcHJpYXRlIHF1YWRzXHJcbiAgICAgIHZhciBpbmRleGVzID0gX3F1YWRJbmRleGVzKHNpemVkUG9pbnQsIHF1YWQuY29ybmVycyk7XHJcblxyXG4gICAgICAvLyBJdGVyYXRpbmdcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cclxuICAgICAgICAvLyBTdWJkaXZpZGluZyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9IF9xdWFkU3ViZGl2aWRlKGluZGV4ZXNbaV0sIHF1YWQpO1xyXG5cclxuICAgICAgICAvLyBSZWN1cnNpb25cclxuICAgICAgICBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gUHVzaGluZyB0aGUgZWxlbWVudCBpbiBhIGxlYWYgbm9kZVxyXG4gICAgICBxdWFkLmVsZW1lbnRzLnB1c2goZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgaGVsZCBieSB0aGUgbm9kZSBjb250YWluaW5nIHRoZVxyXG4gICAqIHNlYXJjaGVkIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgVGhlIHNlYXJjaGVkIHBvaW50ICh4LCB5KS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICBUaGUgc2VhcmNoZWQgcXVhZC5cclxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIHJlbGV2YW50XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQpIHtcclxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xyXG4gICAgICB2YXIgaW5kZXggPSBfcXVhZEluZGV4KHBvaW50LCBxdWFkLmJvdW5kcyk7XHJcblxyXG4gICAgICAvLyBJZiBub2RlIGRvZXMgbm90IGV4aXN0IHdlIHJldHVybiBhbiBlbXB0eSBsaXN0XHJcbiAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZC5ub2Rlc1tpbmRleF0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiBxdWFkLmVsZW1lbnRzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiBhbiByZWN0YW5ndWxhciBhcmVhXHJcbiAgICogdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBheGlzLWFsaWduZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R8YXJyYXl9IHJlY3REYXRhICAgICAgIFRoZSBzZWFyY2hlZCBhcmVhIGRlZmluZWQgZWl0aGVyIGJ5XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvZiBmb3VyIGNvcm5lcnMgKHgsIHkpIGluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FzZSBvZiBhIG5vbi1heGlzLWFsaWduZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBvciBhbiBvYmplY3Qgd2l0aCB0d28gdG9wXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBxdWFkICAgICAgICAgICBUaGUgc2VhcmNoZWQgcXVhZC5cclxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIGNvbGxpc2lvbkZ1bmMgIFRoZSBjb2xsaXNpb24gZnVuY3Rpb24gdXNlZCB0byBzZWFyY2hcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBub2RlIGluZGV4ZXMuXHJcbiAgICogQHBhcmFtICB7YXJyYXk/fSAgICAgICBlbHMgICAgICAgICAgICBUaGUgcmV0cmlldmVkIGVsZW1lbnRzLlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlQXJlYShyZWN0RGF0YSwgcXVhZCwgY29sbGlzaW9uRnVuYywgZWxzKSB7XHJcbiAgICBlbHMgPSBlbHMgfHwge307XHJcblxyXG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XHJcbiAgICAgIHZhciBpbmRleGVzID0gY29sbGlzaW9uRnVuYyhyZWN0RGF0YSwgcXVhZC5jb3JuZXJzKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxyXG4gICAgICAgICAgICByZWN0RGF0YSxcclxuICAgICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSxcclxuICAgICAgICAgICAgY29sbGlzaW9uRnVuYyxcclxuICAgICAgICAgICAgZWxzXHJcbiAgICAgICAgICApO1xyXG4gICAgfSBlbHNlXHJcbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcXVhZC5lbGVtZW50cy5sZW5ndGg7IGogPCBtOyBqKyspXHJcbiAgICAgICAgaWYgKGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID0gcXVhZC5lbGVtZW50c1tqXTtcclxuXHJcbiAgICByZXR1cm4gZWxzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyB0aGUgcXVhZHRyZWUgb2JqZWN0IGl0c2VsZi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBib3VuZHMgICAgICAgVGhlIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBhblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luICh4LCB5KSwgd2lkdGggYW5kIGhlaWd0aC5cclxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbGV2ZWwgICAgICAgIFRoZSBsZXZlbCBvZiB0aGUgcXVhZCBpbiB0aGUgdHJlZS5cclxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4RWxlbWVudHMgIFRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGUuXHJcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heExldmVsICAgICBUaGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3F1YWRUcmVlKGJvdW5kcywgbGV2ZWwsIG1heEVsZW1lbnRzLCBtYXhMZXZlbCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGV2ZWw6IGxldmVsIHx8IDAsXHJcbiAgICAgIGJvdW5kczogYm91bmRzLFxyXG4gICAgICBjb3JuZXJzOiBfZ2VvbS5zcGxpdFNxdWFyZShib3VuZHMpLFxyXG4gICAgICBtYXhFbGVtZW50czogbWF4RWxlbWVudHMgfHwgMjAsXHJcbiAgICAgIG1heExldmVsOiBtYXhMZXZlbCB8fCA0LFxyXG4gICAgICBlbGVtZW50czogW10sXHJcbiAgICAgIG5vZGVzOiBbXVxyXG4gICAgfTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBTaWdtYSBRdWFkIENvbnN0cnVjdG9yXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqXHJcbiAgICogVGhlIHF1YWQgQVBJIGFzIGV4cG9zZWQgdG8gc2lnbWEuXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBxdWFkIGNvcmUgdGhhdCB3aWxsIGJlY29tZSB0aGUgc2lnbWEgaW50ZXJmYWNlIHdpdGggdGhlIHF1YWR0cmVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbj99IGluZGV4RWRnZXMgVGVsbCB0byBpbmRleCBlZGdlcyBvciBub2Rlc1xyXG4gICAqXHJcbiAgICogcHJvcGVydHkge29iamVjdH0gX3RyZWUgICAgICAgUHJvcGVydHkgaG9sZGluZyB0aGUgcXVhZHRyZWUgb2JqZWN0XHJcbiAgICogcHJvcGVydHkge29iamVjdH0gX2dlb20gICAgICAgRXhwb3NpdGlvbiBvZiB0aGUgX2dlb20gbmFtZXNwYWNlIGZvciB0ZXN0aW5nXHJcbiAgICogcHJvcGVydHkge29iamVjdH0gX2NhY2hlICAgICAgQ2FjaGUgZm9yIHRoZSBhcmVhIG1ldGhvZFxyXG4gICAqL1xyXG4gIHZhciBxdWFkID0gZnVuY3Rpb24oaW5kZXhFZGdlcykge1xyXG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xyXG4gICAgdGhpcy5fdHJlZSA9IG51bGw7XHJcbiAgICB0aGlzLl9jYWNoZSA9IHtcclxuICAgICAgcXVlcnk6IGZhbHNlLFxyXG4gICAgICByZXN1bHQ6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcbiAgICB0aGlzLl9pbmRleEVkZ2VzID0gaW5kZXhFZGdlcyB8fCBmYWxzZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJbmRleCBhIGdyYXBoIGJ5IGluc2VydGluZyBpdHMgZWxlbWVudHMgaW50byB0aGUgcXVhZHRyZWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHthcnJheX0gIGdyYXBoICAgICAgVGhlIGdyYXBoIHRvIGluZGV4XHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgICAgIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXJzIHdpdGggYXQgbGVhc3QgdGhlIHF1YWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogUGFyYW1ldGVyczpcclxuICAgKiAtLS0tLS0tLS0tXHJcbiAgICogYm91bmRzOiAgICAgIHtvYmplY3R9ICAgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGl0cyBvcmlnaW4gKHgsIHkpXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggYW5kIGhlaWd0aC5cclxuICAgKiBwcmVmaXg6ICAgICAge3N0cmluZz99ICBhIHByZWZpeCBmb3Igbm9kZSBnZW9tZXRyaWMgYXR0cmlidXRlcy5cclxuICAgKiBtYXhFbGVtZW50czoge2ludGVnZXI/fSB0aGUgbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiBhIGxlYWYgbm9kZS5cclxuICAgKiBtYXhMZXZlbDogICAge2ludGVnZXI/fSB0aGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cclxuICAgKi9cclxuICBxdWFkLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKGdyYXBoLCBwYXJhbXMpIHtcclxuICAgIGlmICghdGhpcy5fZW5hYmxlZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdHJlZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbmZvcmNpbmcgcHJlc2VuY2Ugb2YgYm91bmRhcmllc1xyXG4gICAgaWYgKCFwYXJhbXMuYm91bmRzKVxyXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5xdWFkLmluZGV4OiBib3VuZHMgaW5mb3JtYXRpb24gbm90IGdpdmVuLic7XHJcblxyXG4gICAgLy8gUHJlZml4XHJcbiAgICB2YXIgcHJlZml4ID0gcGFyYW1zLnByZWZpeCB8fCAnJyxcclxuICAgICAgICBjcCxcclxuICAgICAgICBjYyA9IHBhcmFtcy5jdXJ2YXR1cmVDb2VmZmljaWVudHMsXHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHRhcmdldCxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgbixcclxuICAgICAgICBlO1xyXG5cclxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXHJcbiAgICB0aGlzLl90cmVlID0gX3F1YWRUcmVlKFxyXG4gICAgICBwYXJhbXMuYm91bmRzLFxyXG4gICAgICAwLFxyXG4gICAgICBwYXJhbXMubWF4RWxlbWVudHMsXHJcbiAgICAgIHBhcmFtcy5tYXhMZXZlbFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2luZGV4RWRnZXMpIHtcclxuICAgICAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXMoKTtcclxuICAgICAgLy8gSW5zZXJ0aW5nIGdyYXBoIG5vZGVzIGludG8gdGhlIHRyZWVcclxuICAgICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cclxuICAgICAgICAvLyBJbnNlcnRpbmcgbm9kZVxyXG4gICAgICAgIF9xdWFkSW5zZXJ0KFxyXG4gICAgICAgICAgbm9kZXNbaV0sXHJcbiAgICAgICAgICBfZ2VvbS5wb2ludFRvU3F1YXJlKHtcclxuICAgICAgICAgICAgeDogbm9kZXNbaV1bcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgeTogbm9kZXNbaV1bcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgc2l6ZTogbm9kZXNbaV1bcHJlZml4ICsgJ3NpemUnXVxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICB0aGlzLl90cmVlXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGVkZ2VzID0gZ3JhcGguZWRnZXMoKTtcclxuICAgICAgLy8gSW5zZXJ0aW5nIGdyYXBoIGVkZ2VzIGludG8gdGhlIHRyZWVcclxuICAgICAgZm9yIChpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHNvdXJjZSA9IGdyYXBoLm5vZGVzKGVkZ2VzW2ldLnNvdXJjZSk7XHJcbiAgICAgICAgdGFyZ2V0ID0gZ3JhcGgubm9kZXMoZWRnZXNbaV0udGFyZ2V0KTtcclxuICAgICAgICBlID0ge1xyXG4gICAgICAgICAgeDE6IHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgeTE6IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgeDI6IHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgeTI6IHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgc2l6ZTogZWRnZXNbaV1bcHJlZml4ICsgJ3NpemUnXSB8fCAwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0aW5nIGVkZ2VcclxuICAgICAgICBpZiAoZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlJyB8fCBlZGdlc1tpXS50eXBlID09PSAnY3VydmVkQXJyb3cnKSB7XHJcbiAgICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgICAgICAgbiA9IHtcclxuICAgICAgICAgICAgICB4OiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICB5OiBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICBzaXplOiBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSB8fCAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF9xdWFkSW5zZXJ0KFxyXG4gICAgICAgICAgICAgIGVkZ2VzW2ldLFxyXG4gICAgICAgICAgICAgIF9nZW9tLnNlbGZMb29wVG9TcXVhcmUobiksXHJcbiAgICAgICAgICAgICAgdGhpcy5fdHJlZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoZS54MSwgZS55MSwgZS54MiwgZS55MiwgZWRnZXNbaV0uY2MgfHwgY2MpO1xyXG4gICAgICAgICAgICBfcXVhZEluc2VydChcclxuICAgICAgICAgICAgICBlZGdlc1tpXSxcclxuICAgICAgICAgICAgICBfZ2VvbS5xdWFkcmF0aWNDdXJ2ZVRvU3F1YXJlKGUsIGNwKSxcclxuICAgICAgICAgICAgICB0aGlzLl90cmVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBfcXVhZEluc2VydChcclxuICAgICAgICAgICAgZWRnZXNbaV0sXHJcbiAgICAgICAgICAgIF9nZW9tLmxpbmVUb1NxdWFyZShlKSxcclxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgY2FjaGU6XHJcbiAgICB0aGlzLl9jYWNoZSA9IHtcclxuICAgICAgcXVlcnk6IGZhbHNlLFxyXG4gICAgICByZXN1bHQ6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHJlbW92ZT9cclxuICAgIHJldHVybiB0aGlzLl90cmVlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIG5vZGVzIGhlbGQgYnkgdGhlIHF1YWR0cmVlIG5vZGUgY29udGFpbmluZyB0aGVcclxuICAgKiBzZWFyY2hlZCBwb2ludC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBvZiB0aGUgcG9pbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cclxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIG5vZGVzIHJldHJpZXZlZC5cclxuICAgKi9cclxuICBxdWFkLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIGlmICghdGhpcy5fZW5hYmxlZClcclxuICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl90cmVlID9cclxuICAgICAgX3F1YWRSZXRyaWV2ZVBvaW50KHt4OiB4LCB5OiB5fSwgdGhpcy5fdHJlZSkgfHwgW10gOlxyXG4gICAgICBbXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBub2RlcyB3aXRoaW4gYSByZWN0YW5ndWxhciBhcmVhLiBUaGUgbWV0aG9kcyBrZWVwIHRoZVxyXG4gICAqIGxhc3QgYXJlYSBxdWVyaWVkIGluIGNhY2hlIGZvciBvcHRpbWl6YXRpb24gcmVhc29uIGFuZCB3aWxsIGFjdCBkaWZmZXJlbnRseVxyXG4gICAqIGZvciB0aGUgc2FtZSByZWFzb24gaWYgdGhlIGFyZWEgaXMgYXhpcy1hbGlnbmVkIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MilcclxuICAgKiAgICAgICAgICAgICAgICAgIGFuZCBoZWlnaHQuXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXHJcbiAgICovXHJcbiAgcXVhZC5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKHJlY3QpIHtcclxuICAgIGlmICghdGhpcy5fZW5hYmxlZClcclxuICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVjdCksXHJcbiAgICAgICAgY29sbGlzaW9uRnVuYyxcclxuICAgICAgICByZWN0RGF0YTtcclxuXHJcbiAgICAvLyBSZXR1cm5pbmcgY2FjaGU/XHJcbiAgICBpZiAodGhpcy5fY2FjaGUucXVlcnkgPT09IHNlcmlhbGl6ZWQpXHJcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5yZXN1bHQ7XHJcblxyXG4gICAgLy8gQXhpcyBhbGlnbmVkID9cclxuICAgIGlmIChfZ2VvbS5pc0F4aXNBbGlnbmVkKHJlY3QpKSB7XHJcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZEluZGV4ZXM7XHJcbiAgICAgIHJlY3REYXRhID0gX2dlb20uYXhpc0FsaWduZWRUb3BQb2ludHMocmVjdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkQ29sbGlzaW9uO1xyXG4gICAgICByZWN0RGF0YSA9IF9nZW9tLnJlY3RhbmdsZUNvcm5lcnMocmVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0cmlldmluZyBub2Rlc1xyXG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fdHJlZSA/XHJcbiAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxyXG4gICAgICAgIHJlY3REYXRhLFxyXG4gICAgICAgIHRoaXMuX3RyZWUsXHJcbiAgICAgICAgY29sbGlzaW9uRnVuY1xyXG4gICAgICApIDpcclxuICAgICAgW107XHJcblxyXG4gICAgLy8gT2JqZWN0IHRvIGFycmF5XHJcbiAgICB2YXIgZWxlbWVudHNBcnIgPSBbXTtcclxuICAgIGZvciAodmFyIGkgaW4gZWxlbWVudHMpXHJcbiAgICAgIGVsZW1lbnRzQXJyLnB1c2goZWxlbWVudHNbaV0pO1xyXG5cclxuICAgIC8vIENhY2hpbmdcclxuICAgIHRoaXMuX2NhY2hlLnF1ZXJ5ID0gc2VyaWFsaXplZDtcclxuICAgIHRoaXMuX2NhY2hlLnJlc3VsdCA9IGVsZW1lbnRzQXJyO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50c0FycjtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRVhQT1JUOlxyXG4gICAqICoqKioqKipcclxuICAgKi9cclxuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XHJcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMucXVhZCA9IHF1YWQ7XHJcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZWRnZXF1YWQgPSBxdWFkLmJpbmQodGhpcywgdHJ1ZSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcclxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcXVhZDtcclxuICAgIGV4cG9ydHMucXVhZCA9IHF1YWQ7XHJcbiAgfSBlbHNlXHJcbiAgICB0aGlzLnF1YWQgPSBxdWFkO1xyXG5cclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FwdG9ycycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgdXNlciBpbnB1dHMgZGVmYXVsdCBjYXB0b3IuIEl0IGRlYWxzIHdpdGggbW91c2UgZXZlbnRzLCBrZXlib2FyZHNcclxuICAgKiBldmVudHMgYW5kIHRvdWNoIGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgdGFyZ2V0ICAgVGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQuXHJcbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJuIHtzaWdtYS5jYXB0b3J9ICAgICAgICAgIFRoZSBmcmVzaCBuZXcgY2FwdG9yIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhcHRvcnMubW91c2UgPSBmdW5jdGlvbih0YXJnZXQsIGNhbWVyYSwgc2V0dGluZ3MpIHtcclxuICAgIHZhciBfc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcclxuICAgICAgICBfY2FtZXJhID0gY2FtZXJhLFxyXG4gICAgICAgIF9zZXR0aW5ncyA9IHNldHRpbmdzLFxyXG5cclxuICAgICAgICAvLyBDQU1FUkEgTUFOQUdFTUVOVDpcclxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKipcclxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxyXG4gICAgICAgIF9zdGFydENhbWVyYVgsXHJcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSxcclxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcclxuXHJcbiAgICAgICAgLy8gVGhlIGxhdGVzdCBzdGFnZSBwb3NpdGlvbjpcclxuICAgICAgICBfbGFzdENhbWVyYVgsXHJcbiAgICAgICAgX2xhc3RDYW1lcmFZLFxyXG4gICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUsXHJcbiAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyxcclxuXHJcbiAgICAgICAgLy8gTU9VU0UgTUFOQUdFTUVOVDpcclxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIC8vIFRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZzpcclxuICAgICAgICBfc3RhcnRNb3VzZVgsXHJcbiAgICAgICAgX3N0YXJ0TW91c2VZLFxyXG5cclxuICAgICAgICBfaXNNb3VzZURvd24sXHJcbiAgICAgICAgX2lzTW92aW5nLFxyXG4gICAgICAgIF9oYXNEcmFnZ2VkLFxyXG4gICAgICAgIF9kb3duU3RhcnRUaW1lLFxyXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQ7XHJcblxyXG4gICAgdGhpcy5lbHRGb2N1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcclxuXHJcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhfdGFyZ2V0LCAnY2xpY2snLCBfZG91YmxlQ2xpY2tIYW5kbGVyKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBfd2hlZWxIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBfd2hlZWxIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9tb3ZlSGFuZGxlciwgZmFsc2UpO1xyXG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBfZG93bkhhbmRsZXIsIGZhbHNlKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfY2xpY2tIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgX291dEhhbmRsZXIsIGZhbHNlKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIF9lbnRlckhhbmRsZXIsIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdXBIYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB1bmJpbmRzIGV2ZXJ5IGhhbmRsZXJzIHRoYXQgbWFrZXMgdGhlIGNhcHRvciB3b3JrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2soX3RhcmdldCwgJ2NsaWNrJyk7XHJcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBfd2hlZWxIYW5kbGVyKTtcclxuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgX3doZWVsSGFuZGxlcik7XHJcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX21vdmVIYW5kbGVyKTtcclxuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBfZG93bkhhbmRsZXIpO1xyXG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2NsaWNrSGFuZGxlcik7XHJcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBfb3V0SGFuZGxlcik7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdXBIYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgLy8gTU9VU0UgRVZFTlRTOlxyXG4gICAgLy8gKioqKioqKioqKioqKlxyXG5cclxuICAgIGZ1bmN0aW9uIF9lbnRlckhhbmRsZXIoZSkge1xyXG4gICAgICBpZiAoIV9zZXR0aW5ncygnY2xpY2tUb0ZvY3VzJykpIHtcclxuICAgICAgICB0YXJnZXQuZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnbW92ZScgbW91c2UgZXZlbnQuIEl0IHdpbGwgZWZmZWN0aXZlbHlcclxuICAgICAqIGRyYWcgdGhlIGdyYXBoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX21vdmVIYW5kbGVyKGUpIHtcclxuICAgICAgdmFyIHgsXHJcbiAgICAgICAgICB5LFxyXG4gICAgICAgICAgcG9zO1xyXG5cclxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnQ6XHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vtb3ZlJyxcclxuICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpKTtcclxuXHJcbiAgICAgICAgaWYgKF9pc01vdXNlRG93bikge1xyXG4gICAgICAgICAgX2lzTW92aW5nID0gdHJ1ZTtcclxuICAgICAgICAgIF9oYXNEcmFnZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZClcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xyXG5cclxuICAgICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIH0sIF9zZXR0aW5ncygnZHJhZ1RpbWVvdXQnKSk7XHJcblxyXG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcclxuXHJcbiAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gdHJ1ZTtcclxuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXHJcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFgoZSkgLSBfc3RhcnRNb3VzZVgsXHJcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBfc3RhcnRNb3VzZVksXHJcbiAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgeCA9IF9zdGFydENhbWVyYVggLSBwb3MueDtcclxuICAgICAgICAgIHkgPSBfc3RhcnRDYW1lcmFZIC0gcG9zLnk7XHJcblxyXG4gICAgICAgICAgaWYgKHggIT09IF9jYW1lcmEueCB8fCB5ICE9PSBfY2FtZXJhLnkpIHtcclxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xyXG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XHJcblxyXG4gICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xyXG4gICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgeTogeVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3VwJyBtb3VzZSBldmVudC4gSXQgd2lsbCBzdG9wIGRyYWdnaW5nIHRoZVxyXG4gICAgICogZ3JhcGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBIYW5kbGVyKGUpIHtcclxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykgJiYgX2lzTW91c2VEb3duKSB7XHJcbiAgICAgICAgX2lzTW91c2VEb3duID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XHJcblxyXG4gICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIHggPSBzaWdtYS51dGlscy5nZXRYKGUpLFxyXG4gICAgICAgICAgICB5ID0gc2lnbWEudXRpbHMuZ2V0WShlKTtcclxuXHJcbiAgICAgICAgaWYgKF9pc01vdmluZykge1xyXG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcclxuICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcclxuICAgICAgICAgICAgX2NhbWVyYSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXHJcbiAgICAgICAgICAgICAgICBfc2V0dGluZ3MoJ21vdXNlSW5lcnRpYVJhdGlvJykgKiAoX2NhbWVyYS54IC0gX2xhc3RDYW1lcmFYKSxcclxuICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xyXG4gICAgICAgICAgICAgICAgX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFSYXRpbycpICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnbW91c2VJbmVydGlhRHVyYXRpb24nKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICBfc3RhcnRNb3VzZVggIT09IHggfHxcclxuICAgICAgICAgIF9zdGFydE1vdXNlWSAhPT0geVxyXG4gICAgICAgIClcclxuICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XHJcbiAgICAgICAgICAgIHg6IF9jYW1lcmEueCxcclxuICAgICAgICAgICAgeTogX2NhbWVyYS55XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2V1cCcsXHJcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBfaXNNb3ZpbmcgZmxhZzpcclxuICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnZG93bicgbW91c2UgZXZlbnQuIEl0IHdpbGwgc3RhcnQgb2JzZXJ2aW5nXHJcbiAgICAgKiB0aGUgbW91c2UgcG9zaXRpb24gZm9yIGRyYWdnaW5nIHRoZSBncmFwaC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9kb3duSGFuZGxlcihlKSB7XHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcclxuICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XHJcbiAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICBfc3RhcnRNb3VzZVggPSBzaWdtYS51dGlscy5nZXRYKGUpO1xyXG4gICAgICAgIF9zdGFydE1vdXNlWSA9IHNpZ21hLnV0aWxzLmdldFkoZSk7XHJcblxyXG4gICAgICAgIF9oYXNEcmFnZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgX2Rvd25TdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgLy8gTWlkZGxlIG1vdXNlIGJ1dHRvbiBwcmVzc2VkXHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAvLyBSaWdodCBtb3VzZSBidXR0b24gcHJlc3NlZFxyXG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodGNsaWNrJyxcclxuICAgICAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBfc3RhcnRNb3VzZVgsIF9zdGFydE1vdXNlWSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIC8vIGNhc2UgMTpcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIExlZnQgbW91c2UgYnV0dG9uIHByZXNzZWRcclxuICAgICAgICAgICAgX2lzTW91c2VEb3duID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlZG93bicsXHJcbiAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ291dCcgbW91c2UgZXZlbnQuIEl0IHdpbGwganVzdCByZWRpc3BhdGNoXHJcbiAgICAgKiB0aGUgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfb3V0SGFuZGxlcihlKSB7XHJcbiAgICAgIF9zZWxmLmVsdEZvY3VzZWQgPSBmYWxzZTtcclxuICAgICAgdGFyZ2V0LmJsdXIoKTtcclxuXHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKVxyXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlb3V0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdjbGljaycgbW91c2UgZXZlbnQuIEl0IHdpbGwgcmVkaXNwYXRjaCB0aGVcclxuICAgICAqIGNsaWNrIGV2ZW50LCBidXQgd2l0aCBub3JtYWxpemVkIFggYW5kIFkgY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2xpY2tIYW5kbGVyKGUpIHtcclxuICAgICAgX3NlbGYuZWx0Rm9jdXNlZCA9IHRydWU7XHJcbiAgICAgIHRhcmdldC5mb2N1cygpO1xyXG5cclxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKTtcclxuICAgICAgICBldmVudC5pc0RyYWdnaW5nID1cclxuICAgICAgICAgICgoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIF9kb3duU3RhcnRUaW1lKSA+IDEwMCkgJiYgX2hhc0RyYWdnZWQ7XHJcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBldmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgZG91YmxlIGNsaWNrIGN1c3RvbSBldmVudC4gSXQgd2lsbFxyXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZG91YmxlQ2xpY2tIYW5kbGVyKGUpIHtcclxuICAgICAgdmFyIHBvcyxcclxuICAgICAgICAgIHJhdGlvLFxyXG4gICAgICAgICAgYW5pbWF0aW9uO1xyXG5cclxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcclxuICAgICAgICByYXRpbyA9IDEgLyBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbWluZ1JhdGlvJyk7XHJcblxyXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZWNsaWNrJyxcclxuICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcclxuXHJcbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcclxuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXHJcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFgoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcclxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29tRHVyYXRpb24nKVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3doZWVsJyBtb3VzZSBldmVudC4gSXQgd2lsbCBiYXNpY2FsbHkgem9vbVxyXG4gICAgICogaW4gb3Igbm90IGludG8gdGhlIGdyYXBoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3doZWVsSGFuZGxlcihlKSB7XHJcbiAgICAgIHZhciBwb3MsXHJcbiAgICAgICAgICByYXRpbyxcclxuICAgICAgICAgIGFuaW1hdGlvbjtcclxuXHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9zZXR0aW5ncygnbW91c2VXaGVlbEVuYWJsZWQnKSAmJiAoIV9zZXR0aW5ncygnY2xpY2tUb0ZvY3VzJykgfHwgX3NlbGYuZWx0Rm9jdXNlZCkpIHtcclxuICAgICAgICByYXRpbyA9IHNpZ21hLnV0aWxzLmdldERlbHRhKGUpID4gMCA/XHJcbiAgICAgICAgICAxIC8gX3NldHRpbmdzKCd6b29taW5nUmF0aW8nKSA6XHJcbiAgICAgICAgICBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpO1xyXG5cclxuICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxyXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxyXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlWm9vbUR1cmF0aW9uJylcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcclxuXHJcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXHJcbiAgICogZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kLlxyXG4gICAqIEBwYXJhbSAge2NhbWVyYX0gICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYSByZWxhdGVkIHRvIHRoZSB0YXJnZXQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7c2lnbWEuY2FwdG9yfSAgICAgICAgICBUaGUgZnJlc2ggbmV3IGNhcHRvciBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5jYXB0b3JzLnRvdWNoID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxyXG4gICAgICAgIF90YXJnZXQgPSB0YXJnZXQsXHJcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcclxuICAgICAgICBfc2V0dGluZ3MgPSBzZXR0aW5ncyxcclxuXHJcbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XHJcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgLy8gVGhlIGNhbWVyYSBwb3NpdGlvbiB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZzpcclxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxyXG4gICAgICAgIF9zdGFydENhbWVyYVksXHJcbiAgICAgICAgX3N0YXJ0Q2FtZXJhQW5nbGUsXHJcbiAgICAgICAgX3N0YXJ0Q2FtZXJhUmF0aW8sXHJcblxyXG4gICAgICAgIC8vIFRoZSBsYXRlc3Qgc3RhZ2UgcG9zaXRpb246XHJcbiAgICAgICAgX2xhc3RDYW1lcmFYLFxyXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcclxuICAgICAgICBfbGFzdENhbWVyYUFuZ2xlLFxyXG4gICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8sXHJcblxyXG4gICAgICAgIC8vIFRPVUNIIE1BTkFHRU1FTlQ6XHJcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKipcclxuICAgICAgICAvLyBUb3VjaGVzIHRoYXQgYXJlIGRvd246XHJcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gW10sXHJcblxyXG4gICAgICAgIF9zdGFydFRvdWNoWDAsXHJcbiAgICAgICAgX3N0YXJ0VG91Y2hZMCxcclxuICAgICAgICBfc3RhcnRUb3VjaFgxLFxyXG4gICAgICAgIF9zdGFydFRvdWNoWTEsXHJcbiAgICAgICAgX3N0YXJ0VG91Y2hBbmdsZSxcclxuICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlLFxyXG5cclxuICAgICAgICBfdG91Y2hNb2RlLFxyXG5cclxuICAgICAgICBfaXNNb3ZpbmcsXHJcbiAgICAgICAgX2RvdWJsZVRhcCxcclxuICAgICAgICBfbW92aW5nVGltZW91dElkO1xyXG5cclxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XHJcblxyXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnLCBfZG91YmxlVGFwSGFuZGxlcik7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBfaGFuZGxlU3RhcnQsIGZhbHNlKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIF9oYW5kbGVMZWF2ZSwgZmFsc2UpO1xyXG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSwgZmFsc2UpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGUpIHtcclxuICAgICAgdmFyIG9mZnNldCA9IHNpZ21hLnV0aWxzLmdldE9mZnNldChfdGFyZ2V0KTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogZS5wYWdlWCAtIG9mZnNldC5sZWZ0LFxyXG4gICAgICAgIHk6IGUucGFnZVkgLSBvZmZzZXQudG9wXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB1bmJpbmRzIGV2ZXJ5IGhhbmRsZXJzIHRoYXQgbWFrZXMgdGhlIGNhcHRvciB3b3JrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnKTtcclxuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX2hhbmRsZVN0YXJ0KTtcclxuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF9oYW5kbGVMZWF2ZSk7XHJcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUpO1xyXG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCBfaGFuZGxlTGVhdmUpO1xyXG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9oYW5kbGVNb3ZlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVE9VQ0ggRVZFTlRTOlxyXG4gICAgLy8gKioqKioqKioqKioqKlxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaHN0YXJ0JyBldmVudC4gSXQgd2lsbCBzZXQgdGhlIHRvdWNoXHJcbiAgICAgKiBtb2RlIChcIl90b3VjaE1vZGVcIikgYW5kIHN0YXJ0IG9ic2VydmluZyB0aGUgdXNlciB0b3VjaCBtb3Zlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9oYW5kbGVTdGFydChlKSB7XHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgdmFyIHgwLFxyXG4gICAgICAgICAgICB4MSxcclxuICAgICAgICAgICAgeTAsXHJcbiAgICAgICAgICAgIHkxLFxyXG4gICAgICAgICAgICBwb3MwLFxyXG4gICAgICAgICAgICBwb3MxO1xyXG5cclxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoX2Rvd25Ub3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDE7XHJcblxyXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFYID0gX2NhbWVyYS54O1xyXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xyXG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XHJcblxyXG4gICAgICAgICAgICBwb3MwID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzBdKTtcclxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMCA9IHBvczAueDtcclxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMCA9IHBvczAueTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDI7XHJcblxyXG4gICAgICAgICAgICBwb3MwID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzBdKTtcclxuICAgICAgICAgICAgcG9zMSA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1sxXSk7XHJcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xyXG4gICAgICAgICAgICB5MCA9IHBvczAueTtcclxuICAgICAgICAgICAgeDEgPSBwb3MxLng7XHJcbiAgICAgICAgICAgIHkxID0gcG9zMS55O1xyXG5cclxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xyXG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XHJcblxyXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSA9IF9jYW1lcmEuYW5nbGU7XHJcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVJhdGlvID0gX2NhbWVyYS5yYXRpbztcclxuXHJcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XHJcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVkgPSBfY2FtZXJhLnk7XHJcblxyXG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgwID0geDA7XHJcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSB5MDtcclxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMSA9IHgxO1xyXG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkxID0geTE7XHJcblxyXG4gICAgICAgICAgICBfc3RhcnRUb3VjaEFuZ2xlID0gTWF0aC5hdGFuMihcclxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCxcclxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFgxIC0gX3N0YXJ0VG91Y2hYMFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCkgKlxyXG4gICAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTEgLSBfc3RhcnRUb3VjaFkwKSArXHJcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKSAqXHJcbiAgICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJyBhbmQgJ3RvdWNobGVhdmUnXHJcbiAgICAgKiBldmVudC4gSXQgd2lsbCB1cGRhdGUgdGhlIHRvdWNoIG1vZGUgaWYgdGhlcmUgYXJlIHN0aWxsIGF0IGxlYXN0IG9uZVxyXG4gICAgICogZmluZ2VyLCBhbmQgc3RvcCBkcmFnZ2luZyBlbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2hhbmRsZUxlYXZlKGUpIHtcclxuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcclxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XHJcbiAgICAgICAgdmFyIGluZXJ0aWFSYXRpbyA9IF9zZXR0aW5ncygndG91Y2hJbmVydGlhUmF0aW8nKTtcclxuXHJcbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpIHtcclxuICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgX2hhbmRsZVN0YXJ0KGUpO1xyXG5cclxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ3N0b3BEcmFnJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2lzTW92aW5nKSB7XHJcbiAgICAgICAgICAgICAgX2RvdWJsZVRhcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcclxuICAgICAgICAgICAgICAgIF9jYW1lcmEsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXHJcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueCAtIF9sYXN0Q2FtZXJhWCksXHJcbiAgICAgICAgICAgICAgICAgIHk6IF9jYW1lcmEueSArXHJcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXHJcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ3RvdWNoSW5lcnRpYUR1cmF0aW9uJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2htb3ZlJyBldmVudC4gSXQgd2lsbCBlZmZlY3RpdmVseSBkcmFnXHJcbiAgICAgKiB0aGUgZ3JhcGgsIGFuZCBldmVudHVhbGx5IHpvb21zIGFuZCB0dXJuIGl0IGlmIHRoZSB1c2VyIGlzIHVzaW5nIHR3b1xyXG4gICAgICogZmluZ2Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9oYW5kbGVNb3ZlKGUpIHtcclxuICAgICAgaWYgKCFfZG91YmxlVGFwICYmIF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcclxuICAgICAgICB2YXIgeDAsXHJcbiAgICAgICAgICAgIHgxLFxyXG4gICAgICAgICAgICB5MCxcclxuICAgICAgICAgICAgeTEsXHJcbiAgICAgICAgICAgIGNvcyxcclxuICAgICAgICAgICAgc2luLFxyXG4gICAgICAgICAgICBlbmQsXHJcbiAgICAgICAgICAgIHBvczAsXHJcbiAgICAgICAgICAgIHBvczEsXHJcbiAgICAgICAgICAgIGRpZmYsXHJcbiAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICBkQW5nbGUsXHJcbiAgICAgICAgICAgIGRSYXRpbyxcclxuICAgICAgICAgICAgbmV3U3RhZ2VYLFxyXG4gICAgICAgICAgICBuZXdTdGFnZVksXHJcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8sXHJcbiAgICAgICAgICAgIG5ld1N0YWdlQW5nbGU7XHJcblxyXG4gICAgICAgIF9kb3duVG91Y2hlcyA9IGUudG91Y2hlcztcclxuICAgICAgICBfaXNNb3ZpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZClcclxuICAgICAgICAgIGNsZWFyVGltZW91dChfbW92aW5nVGltZW91dElkKTtcclxuXHJcbiAgICAgICAgX21vdmluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKF90b3VjaE1vZGUpIHtcclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XHJcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xyXG4gICAgICAgICAgICB5MCA9IHBvczAueTtcclxuXHJcbiAgICAgICAgICAgIGRpZmYgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgIHgwIC0gX3N0YXJ0VG91Y2hYMCxcclxuICAgICAgICAgICAgICB5MCAtIF9zdGFydFRvdWNoWTAsXHJcbiAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgbmV3U3RhZ2VYID0gX3N0YXJ0Q2FtZXJhWCAtIGRpZmYueDtcclxuICAgICAgICAgICAgbmV3U3RhZ2VZID0gX3N0YXJ0Q2FtZXJhWSAtIGRpZmYueTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuZXdTdGFnZVggIT09IF9jYW1lcmEueCB8fCBuZXdTdGFnZVkgIT09IF9jYW1lcmEueSkge1xyXG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcclxuICAgICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XHJcblxyXG4gICAgICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XHJcbiAgICAgICAgICAgICAgICB4OiBuZXdTdGFnZVgsXHJcbiAgICAgICAgICAgICAgICB5OiBuZXdTdGFnZVlcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vtb3ZlJyxcclxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIHBvczAueCwgcG9zMC55KSk7XHJcblxyXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XHJcbiAgICAgICAgICAgIHBvczEgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMV0pO1xyXG4gICAgICAgICAgICB4MCA9IHBvczAueDtcclxuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XHJcbiAgICAgICAgICAgIHgxID0gcG9zMS54O1xyXG4gICAgICAgICAgICB5MSA9IHBvczEueTtcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcclxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hYMCArIF9zdGFydFRvdWNoWDEpIC8gMiAtXHJcbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcclxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMCArIF9zdGFydFRvdWNoWTEpIC8gMiAtXHJcbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcclxuICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGVuZCA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAgKHgwICsgeDEpIC8gMiAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxyXG4gICAgICAgICAgICAgICh5MCArIHkxKSAvIDIgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcclxuICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBkQW5nbGUgPSBNYXRoLmF0YW4yKHkxIC0geTAsIHgxIC0geDApIC0gX3N0YXJ0VG91Y2hBbmdsZTtcclxuICAgICAgICAgICAgZFJhdGlvID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgICAgICAgICh5MSAtIHkwKSAqICh5MSAtIHkwKSArICh4MSAtIHgwKSAqICh4MSAtIHgwKVxyXG4gICAgICAgICAgICApIC8gX3N0YXJ0VG91Y2hEaXN0YW5jZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0aW9uOlxyXG4gICAgICAgICAgICB4MCA9IHN0YXJ0Lng7XHJcbiAgICAgICAgICAgIHkwID0gc3RhcnQueTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb246XHJcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gPSBfc3RhcnRDYW1lcmFSYXRpbyAvIGRSYXRpbztcclxuICAgICAgICAgICAgeDAgPSB4MCAqIGRSYXRpbztcclxuICAgICAgICAgICAgeTAgPSB5MCAqIGRSYXRpbztcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdGF0aW9uOlxyXG4gICAgICAgICAgICBuZXdTdGFnZUFuZ2xlID0gX3N0YXJ0Q2FtZXJhQW5nbGUgLSBkQW5nbGU7XHJcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKC1kQW5nbGUpO1xyXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbigtZEFuZ2xlKTtcclxuICAgICAgICAgICAgeDEgPSB4MCAqIGNvcyArIHkwICogc2luO1xyXG4gICAgICAgICAgICB5MSA9IHkwICogY29zIC0geDAgKiBzaW47XHJcbiAgICAgICAgICAgIHgwID0geDE7XHJcbiAgICAgICAgICAgIHkwID0geTE7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5hbGl6ZTpcclxuICAgICAgICAgICAgbmV3U3RhZ2VYID0geDAgLSBlbmQueCArIF9zdGFydENhbWVyYVg7XHJcbiAgICAgICAgICAgIG5ld1N0YWdlWSA9IHkwIC0gZW5kLnkgKyBfc3RhcnRDYW1lcmFZO1xyXG5cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gIT09IF9jYW1lcmEucmF0aW8gfHxcclxuICAgICAgICAgICAgICBuZXdTdGFnZUFuZ2xlICE9PSBfY2FtZXJhLmFuZ2xlIHx8XHJcbiAgICAgICAgICAgICAgbmV3U3RhZ2VYICE9PSBfY2FtZXJhLnggfHxcclxuICAgICAgICAgICAgICBuZXdTdGFnZVkgIT09IF9jYW1lcmEueVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XHJcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xyXG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUgPSBfY2FtZXJhLmFuZ2xlO1xyXG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8gPSBfY2FtZXJhLnJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xyXG4gICAgICAgICAgICAgICAgeDogbmV3U3RhZ2VYLFxyXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZLFxyXG4gICAgICAgICAgICAgICAgYW5nbGU6IG5ld1N0YWdlQW5nbGUsXHJcbiAgICAgICAgICAgICAgICByYXRpbzogbmV3U3RhZ2VSYXRpb1xyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSBkb3VibGUgdGFwIGN1c3RvbSBldmVudC4gSXQgd2lsbFxyXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZG91YmxlVGFwSGFuZGxlcihlKSB7XHJcbiAgICAgIHZhciBwb3MsXHJcbiAgICAgICAgICByYXRpbyxcclxuICAgICAgICAgIGFuaW1hdGlvbjtcclxuXHJcbiAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgX2RvdWJsZVRhcCA9IHRydWU7XHJcblxyXG4gICAgICAgIHJhdGlvID0gMSAvIF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29taW5nUmF0aW8nKTtcclxuXHJcbiAgICAgICAgcG9zID0gcG9zaXRpb24oZS50b3VjaGVzWzBdKTtcclxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVjbGljaycsXHJcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBwb3MueCwgcG9zLnkpKTtcclxuXHJcbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcclxuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXHJcbiAgICAgICAgICAgIHBvcy54IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXHJcbiAgICAgICAgICAgIHBvcy55IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXHJcbiAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgYW5pbWF0aW9uID0ge1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21EdXJhdGlvbicpLFxyXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBfZG91YmxlVGFwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgc2lnbWEudXRpbHMuem9vbVRvKF9jYW1lcmEsIHBvcy54LCBwb3MueSwgcmF0aW8sIGFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICBpZiAodHlwZW9mIGNvbnJhZCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcclxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5jYW52YXM6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIGlmICghKG9wdGlvbnMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxyXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xyXG5cclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgYSxcclxuICAgICAgICBmbixcclxuICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25yYWRJZCcsIHtcclxuICAgICAgdmFsdWU6IHNpZ21hLnV0aWxzLmlkKClcclxuICAgIH0pO1xyXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xyXG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB0aGlzLmNvbnRleHRzID0ge307XHJcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xyXG4gICAgdGhpcy5zZXR0aW5ncyA9IChcclxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXHJcbiAgICAgICkgP1xyXG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XHJcbiAgICAgICAgc2V0dGluZ3M7XHJcblxyXG4gICAgLy8gTm9kZSBpbmRleGVzOlxyXG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XHJcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcclxuXHJcbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxyXG4gICAgdGhpcy5qb2JzID0ge307XHJcblxyXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxyXG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9ICdyZW5kZXJlcicgKyB0aGlzLmNvbnJhZElkICsgJzonO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50czpcclxuICAgIGlmIChcclxuICAgICAgIXRoaXMuc2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJylcclxuICAgICkge1xyXG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xyXG4gICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcclxuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XHJcbiAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJyk7XHJcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ3NjZW5lJyk7XHJcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xyXG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcclxuICAgIHRoaXMuY29udGV4dHMuaG92ZXIgPSB0aGlzLmNvbnRleHRzLm1vdXNlO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcclxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xyXG4gICAgYSA9IHRoaXMub3B0aW9ucy5jYXB0b3JzIHx8IFtzaWdtYS5jYXB0b3JzLm1vdXNlLCBzaWdtYS5jYXB0b3JzLnRvdWNoXTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XHJcbiAgICAgIHRoaXMuY2FwdG9ycy5wdXNoKFxyXG4gICAgICAgIG5ldyBmbihcclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubW91c2UsXHJcbiAgICAgICAgICB0aGlzLmNhbWVyYSxcclxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVhbCB3aXRoIHNpZ21hIGV2ZW50czpcclxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblxyXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXRpYyBtZXRob2QgdG8gcmVuZGVyIGVkZ2VzIG9yIG5vZGVzIHdpdGggdGhlIGdpdmVuIHJlbmRlcmVyc1xyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBwYXJhbXMgICAgIFRoZSBwYXJhbWV0ZXJzIHBhc3NlZCBpbiBhbiBvYmplY3RcclxuICAgKiB7XHJcbiAgICogICByZW5kZXJlcnM6IHtvYmplY3R9ICAgICAgICAgICAgICBSZW5kZXJlcnMgaW5kZXhlZCBieSB0eXBlc1xyXG4gICAqICAgdHlwZTogICAgICB7c3RyaW5nfSAgICAgICAgICAgICAgXCJlZGdlc1wiIG9yIFwibm9kZXNcIlxyXG4gICAqICAgY3R4OiAgICAgICB7Q29udGV4dDJEfSAgICAgICAgICAgQ2FudmFzIENvbnRleHQgdG8gZHJhdyBvblxyXG4gICAqICAgc2V0dGluZ3M6ICB7b2JqZWN0fSAgICAgICAgICAgICAgU2V0dGluZ3Mgb2JqZWN0IHRvIHVzZVxyXG4gICAqICAgZWxlbWVudHM6ICB7YXJyYXl9ICAgICAgICAgICAgICAgRWxlbWVudHMgdG8gcmVuZGVyXHJcbiAgICogICBncmFwaD86ICAgIHtzaWdtYS5jbGFzc2VzLmdyYXBofSBHcmFwaCBvYmplY3RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbmx5IG5lY2Vzc2FyeSBmb3IgZWRnZSByZW5kZXJpbmcpXHJcbiAgICogICBzdGFydD86ICAgIHtpbnRlZ2VyfSAgICAgICAgICAgICBTdGFydGluZyBpbmRleCBvZiB0aGUgZWxlbWVudHMgdG8gcmVuZGVyXHJcbiAgICogICBlbmQ/OiAgICAgIHtpbnRlZ2VyfSAgICAgICAgICAgICBMYXN0IGluZGV4IG9mIHRoZSBlbGVtZW50cyB0byByZW5kZXJcclxuICAgKiB9XHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5hcHBseVJlbmRlcmVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgcmVuZGVyZXIsXHJcbiAgICAgICAgc3BlY2lhbGl6ZWRSZW5kZXJlcixcclxuICAgICAgICBkZWYsXHJcbiAgICAgICAgcmVuZGVyLFxyXG4gICAgICAgIGVscyA9IHBhcmFtcy5lbGVtZW50cyxcclxuICAgICAgICBjdHhfaW5mb3MgPSB7Zm9udDogcGFyYW1zLmN0eC5mb250fSxcclxuICAgICAgICBlbGVtZW50VHlwZSA9IChwYXJhbXMuZWxlbWVudHMgfHwgcGFyYW1zLnR5cGUgPT0gJ2VkZ2VzJyA/XHJcbiAgICAgICAgICAgICAgJ2RlZmF1bHRFZGdlVHlwZScgOiAnZGVmYXVsdE5vZGVUeXBlJyk7XHJcblxyXG4gICAgcGFyYW1zLnN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDA7XHJcbiAgICBwYXJhbXMuZW5kID0gcGFyYW1zLmVuZCB8fCBwYXJhbXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgcGFyYW1zLmVuZCA9IE1hdGgubWluKHBhcmFtcy5lbGVtZW50cy5sZW5ndGgsIHBhcmFtcy5lbmQpO1xyXG5cclxuICAgIHBhcmFtcy5jdHguc2F2ZSgpO1xyXG5cclxuICAgIGZvciAoaSA9IHBhcmFtcy5zdGFydDsgaSA8IHBhcmFtcy5lbmQ7IGkrKykge1xyXG4gICAgICBpZiAoIWVsc1tpXS5oaWRkZW4pIHtcclxuICAgICAgICBzcGVjaWFsaXplZFJlbmRlcmVyID0gcGFyYW1zLnJlbmRlcmVyc1tcclxuICAgICAgICAgIGVsc1tpXS50eXBlIHx8IHBhcmFtcy5zZXR0aW5ncyhlbGVtZW50VHlwZSlcclxuICAgICAgICBdO1xyXG4gICAgICAgIGRlZiA9IChzcGVjaWFsaXplZFJlbmRlcmVyIHx8IHBhcmFtcy5yZW5kZXJlcnMuZGVmKTtcclxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT0gJ2VkZ2VzJykge1xyXG4gICAgICAgICAgZGVmKFxyXG4gICAgICAgICAgICBlbHNbaV0sXHJcbiAgICAgICAgICAgIHBhcmFtcy5ncmFwaC5ub2RlcyhlbHNbaV0uc291cmNlKSxcclxuICAgICAgICAgICAgcGFyYW1zLmdyYXBoLm5vZGVzKGVsc1tpXS50YXJnZXQpLFxyXG4gICAgICAgICAgICBwYXJhbXMuY3R4LFxyXG4gICAgICAgICAgICBwYXJhbXMuc2V0dGluZ3MsXHJcbiAgICAgICAgICAgIHtjdHg6IGN0eF9pbmZvc31cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgZGVmKFxyXG4gICAgICAgICAgICBlbHNbaV0sXHJcbiAgICAgICAgICAgIHBhcmFtcy5jdHgsXHJcbiAgICAgICAgICAgIHBhcmFtcy5zZXR0aW5ncyxcclxuICAgICAgICAgICAge2N0eDogY3R4X2luZm9zfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwYXJhbXMuY3R4LnJlc3RvcmUoKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVyIGEgYmF0Y2ggb2YgZWRnZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgICB7aW50ZWdlcn0gICAgICBzdGFydCAgICBTdGFydGluZyBpbmRleCBvZiB0aGUgZWxlbWVudHMgdG8gcmVuZGVyXHJcbiAgICogQHBhcmFtICAgIHtpbnRlZ2VyfSAgICAgIGVuZCAgICAgIExhc3QgaW5kZXggb2YgdGhlIGVsZW1lbnRzIHRvIHJlbmRlclxyXG4gICAqIEBwYXJhbSAgICB7b2JqZWN0fSAgICAgICBzZXR0aW5ncyBTZXR0aW5ncyB0byB1c2VcclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZW5kZXJFZGdlcyA9XHJcbiAgICAgICAgICBmdW5jdGlvbihzdGFydCwgZW5kLCBzZXR0aW5ncykge1xyXG4gICAgdmFyIHJlbmRlclBhcmFtcyA9IHtcclxuICAgICAgcmVuZGVyZXJzOiBzaWdtYS5jYW52YXMuZWRnZXMsXHJcbiAgICAgIHR5cGU6ICdlZGdlcycsXHJcbiAgICAgIGVsZW1lbnRzOiB0aGlzLmVkZ2VzT25TY3JlZW4sXHJcbiAgICAgIGN0eDogdGhpcy5jb250ZXh0cy5lZGdlcyxcclxuICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICBlbmQ6IGVuZCxcclxuICAgICAgZ3JhcGg6IHRoaXMuZ3JhcGgsXHJcbiAgICAgIHNldHRpbmdzOiBzZXR0aW5nc1xyXG4gICAgfTtcclxuICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMuYXBwbHlSZW5kZXJlcnMocmVuZGVyUGFyYW1zKTtcclxuICAgIGlmIChzZXR0aW5ncygnZHJhd0VkZ2VMYWJlbHMnKSkge1xyXG4gICAgICByZW5kZXJQYXJhbXMucmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzLmxhYmVscztcclxuICAgICAgcmVuZGVyUGFyYW1zLmN0eCA9IHRoaXMuY29udGV4dHMubGFiZWxzO1xyXG4gICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLmFwcGx5UmVuZGVyZXJzKHJlbmRlclBhcmFtcyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGggb24gdGhlIGNhbnZhc2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnYmVmb3JlUmVuZGVyJyk7XHJcblxyXG4gICAgdmFyIGEsXHJcbiAgICAgICAgaSxcclxuICAgICAgICBrLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgbyxcclxuICAgICAgICBpZCxcclxuICAgICAgICBlbmQsXHJcbiAgICAgICAgam9iLFxyXG4gICAgICAgIHN0YXJ0LFxyXG4gICAgICAgIGVkZ2VzLFxyXG4gICAgICAgIGJhdGNoU2l6ZSxcclxuICAgICAgICB0ZW1wR0NPLFxyXG4gICAgICAgIGluZGV4ID0ge30sXHJcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxyXG4gICAgICAgIG5vZGVzID0gdGhpcy5ncmFwaC5ub2RlcyxcclxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxyXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxyXG4gICAgICAgIGRyYXdOb2RlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdOb2RlcycpLFxyXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXHJcbiAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMsIHtcclxuICAgICAgICAgIHByZWZpeDogdGhpcy5vcHRpb25zLnByZWZpeFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIC8vIENhbGwgdGhlIHJlc2l6ZSBmdW5jdGlvbjpcclxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcclxuXHJcbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcclxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdoaWRlRWRnZXNPbk1vdmUnKSlcclxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXHJcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XHJcblxyXG4gICAgLy8gQXBwbHkgdGhlIGNhbWVyYSdzIHZpZXc6XHJcbiAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXHJcbiAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgdGhpcy5vcHRpb25zLnByZWZpeCxcclxuICAgICAge1xyXG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDbGVhciBjYW52YXNlczpcclxuICAgIHRoaXMuY2xlYXIoKTtcclxuXHJcbiAgICAvLyBLaWxsIHJ1bm5pbmcgam9iczpcclxuICAgIGZvciAoayBpbiB0aGlzLmpvYnMpXHJcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxyXG4gICAgICAgIGNvbnJhZC5raWxsSm9iKGspO1xyXG5cclxuICAgIC8vIEZpbmQgd2hpY2ggbm9kZXMgYXJlIG9uIHNjcmVlbjpcclxuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IHRoaXMuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXHJcbiAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcclxuICAgICk7XHJcblxyXG4gICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICBpbmRleFthW2ldLmlkXSA9IGFbaV07XHJcblxyXG4gICAgLy8gRHJhdyBlZGdlczpcclxuICAgIC8vIC0gSWYgc2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJykgaXMgdHJ1ZSwgdGhlIGVkZ2VzIGFyZSBkaXNwbGF5ZWQgcGVyXHJcbiAgICAvLyAgIGJhdGNoZXMuIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lLlxyXG4gICAgaWYgKGRyYXdFZGdlcykge1xyXG4gICAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcclxuICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VzQ2xpcHBpbmdXaXRoTm9kZXMnKSkge1xyXG4gICAgICAgIC8vIElkZW50aWZ5IHdoaWNoIGVkZ2VzIHRvIGRyYXcgYnkga2VlcGluZyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXRcclxuICAgICAgICAvLyBsZWFzdCBvbmUgZXh0cmVtaXR5IGRpc3BsYXllZCBhY2NvcmRpbmcgdG8gdGhlIHF1YWR0cmVlIGFuZCB0aGVcclxuICAgICAgICAvLyBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW4gZWRnZXMuXHJcbiAgICAgICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgbyA9IGFbaV07XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIChpbmRleFtvLnNvdXJjZV0gfHwgaW5kZXhbby50YXJnZXRdKSAmJlxyXG4gICAgICAgICAgICAoIW8uaGlkZGVuICYmICFub2RlcyhvLnNvdXJjZSkuaGlkZGVuICYmICFub2RlcyhvLnRhcmdldCkuaGlkZGVuKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICAgICB0aGlzLmVkZ2VzT25TY3JlZW4ucHVzaChvKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuID0gdGhpcy5jYW1lcmEuZWRnZXF1YWR0cmVlLmFyZWEoXHJcbiAgICAgICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgdGhlIFwiYmF0Y2hFZGdlc0RyYXdpbmdcIiBzZXR0aW5ncyBpcyB0cnVlLCBlZGdlcyBhcmUgYmF0Y2hlZDpcclxuICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJykpIHtcclxuICAgICAgICBpZCA9ICdlZGdlc18nICsgdGhpcy5jb25yYWRJZDtcclxuICAgICAgICBiYXRjaFNpemUgPSBlbWJlZFNldHRpbmdzKCdjYW52YXNFZGdlc0JhdGNoU2l6ZScpO1xyXG5cclxuICAgICAgICBlZGdlcyA9IHRoaXMuZWRnZXNPblNjcmVlbjtcclxuICAgICAgICBsID0gZWRnZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZWRnZXMubGVuZ3RoLCBzdGFydCArIGJhdGNoU2l6ZSk7XHJcblxyXG4gICAgICAgIGpvYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdGVtcEdDTyA9IHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xyXG4gICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XHJcblxyXG4gICAgICAgICAgdGhpcy5yZW5kZXJFZGdlcyhzdGFydCwgZW5kLCBlbWJlZFNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjpcclxuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGVtcEdDTztcclxuXHJcbiAgICAgICAgICAvLyBDYXRjaCBqb2IncyBlbmQ6XHJcbiAgICAgICAgICBpZiAoZW5kID09PSBlZGdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuam9ic1tpZF07XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdGFydCA9IGVuZCArIDE7XHJcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGgsIHN0YXJ0ICsgYmF0Y2hTaXplKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuam9ic1tpZF0gPSBqb2I7XHJcbiAgICAgICAgY29ucmFkLmFkZEpvYihpZCwgam9iLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgLy8gSWYgbm90LCB0aGV5IGFyZSBkcmF3biBpbiBvbmUgZnJhbWU6XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJFZGdlcygwLCB0aGlzLmVkZ2VzT25TY3JlZW4ubGVuZ3RoLCBlbWJlZFNldHRpbmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERyYXcgbm9kZXM6XHJcbiAgICAvLyAtIE5vIGJhdGNoaW5nXHJcbiAgICBpZiAoZHJhd05vZGVzKSB7XHJcbiAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMuYXBwbHlSZW5kZXJlcnMoe1xyXG4gICAgICAgIHJlbmRlcmVyczogc2lnbWEuY2FudmFzLm5vZGVzLFxyXG4gICAgICAgIHR5cGU6ICdub2RlcycsXHJcbiAgICAgICAgY3R4OiB0aGlzLmNvbnRleHRzLm5vZGVzLFxyXG4gICAgICAgIGVsZW1lbnRzOiB0aGlzLm5vZGVzT25TY3JlZW4sXHJcbiAgICAgICAgc2V0dGluZ3M6IGVtYmVkU2V0dGluZ3NcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBsYWJlbHM6XHJcbiAgICAvLyAtIE5vIGJhdGNoaW5nXHJcbiAgICBpZiAoZHJhd0xhYmVscykge1xyXG4gICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLmFwcGx5UmVuZGVyZXJzKHtcclxuICAgICAgICByZW5kZXJlcnM6IHNpZ21hLmNhbnZhcy5sYWJlbHMsXHJcbiAgICAgICAgdHlwZTogJ25vZGVzJyxcclxuICAgICAgICBjdHg6IHRoaXMuY29udGV4dHMubGFiZWxzLFxyXG4gICAgICAgIGVsZW1lbnRzOiB0aGlzLm5vZGVzT25TY3JlZW4sXHJcbiAgICAgICAgc2V0dGluZ3M6IGVtYmVkU2V0dGluZ3NcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcclxuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXHJcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgIFRoZSBpZCBvZiB0aGUgZWxlbWVudCAodG8gc3RvcmUgaXQgaW4gXCJkb21FbGVtZW50c1wiKS5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCkge1xyXG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcclxuXHJcbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2lnbWEtJyArIGlkKTtcclxuXHJcbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcclxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XHJcblxyXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJylcclxuICAgICAgdGhpcy5jb250ZXh0c1tpZF0gPSBkb20uZ2V0Q29udGV4dCgnMmQnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XHJcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICB3aWR0aCAgVGhlIG5ldyB3aWR0aCBvZiB0aGUgY29udGFpbmVyLlxyXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xyXG4gICAgdmFyIGssXHJcbiAgICAgICAgb2xkV2lkdGggPSB0aGlzLndpZHRoLFxyXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgIHBpeGVsUmF0aW8gPSBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XHJcblxyXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHc7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgICB3ID0gdGhpcy53aWR0aDtcclxuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xyXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzW2tdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykgKyAncHgnKTtcclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XHJcblxyXG4gICAgICAgICAgaWYgKHBpeGVsUmF0aW8gIT09IDEpXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNba10uc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBrIGluIHRoaXMuY29udGV4dHMpIHtcclxuICAgICAgdGhpcy5jb250ZXh0c1trXS5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGNvbnRleHRzIGFuZCBvdGhlciBhdHRyaWJ1dGVzLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICAgIGNhcHRvcjtcclxuXHJcbiAgICAvLyBLaWxsIGNhcHRvcnM6XHJcbiAgICB3aGlsZSAoKGNhcHRvciA9IHRoaXMuY2FwdG9ycy5wb3AoKSkpXHJcbiAgICAgIGNhcHRvci5raWxsKCk7XHJcbiAgICBkZWxldGUgdGhpcy5jYXB0b3JzO1xyXG5cclxuICAgIC8vIEtpbGwgY29udGV4dHM6XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1trXSk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xyXG4gICAgICBkZWxldGUgdGhpcy5jb250ZXh0c1trXTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xyXG4gICAgZGVsZXRlIHRoaXMuY29udGV4dHM7XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGxhYmVscywgbm9kZXMgYW5kIGVkZ2VzIHJlbmRlcmVycyBhcmUgc3RvcmVkIGluIHRoZSB0aHJlZSBmb2xsb3dpbmdcclxuICAgKiBvYmplY3RzLiBXaGVuIGFuIGVsZW1lbnQgaXMgZHJhd24sIGl0cyB0eXBlIHdpbGwgYmUgY2hlY2tlZCBhbmQgaWYgYVxyXG4gICAqIHJlbmRlcmVyIHdpdGggdGhlIHNhbWUgbmFtZSBleGlzdHMsIGl0IHdpbGwgYmUgdXNlZC4gSWYgbm90IGZvdW5kLCB0aGVcclxuICAgKiBkZWZhdWx0IHJlbmRlcmVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAqXHJcbiAgICogVGhleSBhcmUgc3RvcmVkIGluIGRpZmZlcmVudCBmaWxlcywgaW4gdGhlIFwiLi9jYW52YXNcIiBmb2xkZXIuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmxhYmVscycpO1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxyXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLndlYmdsOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcclxuICAgICAgdGhyb3cgJ0NvbnRhaW5lciBub3QgZm91bmQuJztcclxuXHJcbiAgICB2YXIgayxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgYSxcclxuICAgICAgICBmbixcclxuICAgICAgICBfc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcclxuXHJcbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxyXG4gICAgdGhpcy5qb2JzID0ge307XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25yYWRJZCcsIHtcclxuICAgICAgdmFsdWU6IHNpZ21hLnV0aWxzLmlkKClcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxyXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xyXG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB0aGlzLmNvbnRleHRzID0ge307XHJcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xyXG4gICAgdGhpcy5zZXR0aW5ncyA9IChcclxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXHJcbiAgICAgICkgP1xyXG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XHJcbiAgICAgICAgc2V0dGluZ3M7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxyXG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9IHRoaXMuY2FtZXJhLnJlYWRQcmVmaXg7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBwcm9ncmFtcyBoYXNoXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25vZGVQcm9ncmFtcycsIHtcclxuICAgICAgdmFsdWU6IHt9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZVByb2dyYW1zJywge1xyXG4gICAgICB2YWx1ZToge31cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub2RlRmxvYXRBcnJheXMnLCB7XHJcbiAgICAgIHZhbHVlOiB7fVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VGbG9hdEFycmF5cycsIHtcclxuICAgICAgdmFsdWU6IHt9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZUluZGljZXNBcnJheXMnLCB7XHJcbiAgICAgIHZhbHVlOiB7fVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzOlxyXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpIHtcclxuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnZWRnZXMnLCB0cnVlKTtcclxuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbm9kZXMnLCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ3NjZW5lJywgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xyXG4gICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdsYWJlbHMnKTtcclxuICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ21vdXNlJyk7XHJcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGNhcHRvcnM6XHJcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcclxuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xyXG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcclxuICAgICAgICBuZXcgZm4oXHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxyXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXHJcbiAgICAgICAgICB0aGlzLnNldHRpbmdzXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XHJcbiAgICBzaWdtYS5taXNjLmJpbmRFdmVudHMuY2FsbCh0aGlzLCB0aGlzLmNhbWVyYS5wcmVmaXgpO1xyXG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcclxuXHJcbiAgICB0aGlzLnJlc2l6ZSgpO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgZ2VuZXJhdGUgdGhlIG5vZGVzIGFuZCBlZGdlcyBmbG9hdCBhcnJheXMuIFRoaXMgc3RlcCBpc1xyXG4gICAqIHNlcGFyYXRlZCBmcm9tIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYmVjYXVzZSB0byBrZWVwIFdlYkdMIGVmZmljaWVudCwgc2luY2VcclxuICAgKiBhbGwgdGhlIGNhbWVyYSBhbmQgbWlkZGxld2FyZXMgYXJlIG1vZGVsaXNlZCBhcyBtYXRyaWNlcyBhbmQgdGhleSBkbyBub3RcclxuICAgKiByZXF1aXJlIHRoZSBmbG9hdCBhcnJheXMgdG8gYmUgcmVnZW5lcmF0ZWQuXHJcbiAgICpcclxuICAgKiBCYXNpY2FsbHksIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIGNhbWVyYSBvciBhcHBsaWVzIHNvbWUgc3BlY2lmaWMgbGluZWFyXHJcbiAgICogdHJhbnNmb3JtYXRpb25zLCB0aGlzIHByb2Nlc3Mgc3RlcCB3aWxsIGJlIHNraXBwZWQsIGFuZCB0aGUgXCJyZW5kZXJcIlxyXG4gICAqIG1ldGhvZCB3aWxsIGVmZmljaWVudGx5IHJlZnJlc2ggdGhlIHJlbmRlcmluZy5cclxuICAgKlxyXG4gICAqIEFuZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIHRoZSBncmFwaCBjb2xvcnMgb3IgcG9zaXRpb25zIChhcHBseWluZyBhIG5ld1xyXG4gICAqIGxheW91dCBvciBmaWx0ZXJpbmcgdGhlIGNvbG9ycywgZm9yIGluc3RhbmNlKSwgdGhpcyBcInByb2Nlc3NcIiBzdGVwIHdpbGwgYmVcclxuICAgKiByZXF1aXJlZCB0byByZWdlbmVyYXRlIHRoZSBmbG9hdCBhcnJheXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBhLFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBrLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgcmVuZGVyZXIsXHJcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxyXG4gICAgICAgIG9wdGlvbnMgPSBzaWdtYS51dGlscy5leHRlbmQob3B0aW9ucywgdGhpcy5vcHRpb25zKSxcclxuICAgICAgICBkZWZhdWx0RWRnZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKTtcclxuXHJcbiAgICAvLyBFbXB0eSBmbG9hdCBhcnJheXM6XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpXHJcbiAgICAgIGRlbGV0ZSB0aGlzLm5vZGVGbG9hdEFycmF5c1trXTtcclxuXHJcbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpXHJcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXTtcclxuXHJcbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlSW5kaWNlc0FycmF5cylcclxuICAgICAgZGVsZXRlIHRoaXMuZWRnZUluZGljZXNBcnJheXNba107XHJcblxyXG4gICAgLy8gU29ydCBlZGdlcyBhbmQgbm9kZXMgcGVyIHR5cGVzOlxyXG4gICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB0eXBlID0gYVtpXS50eXBlIHx8IGRlZmF1bHRFZGdlVHlwZTtcclxuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLmVkZ2VzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcclxuXHJcbiAgICAgIGlmICghdGhpcy5lZGdlRmxvYXRBcnJheXNba10pXHJcbiAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10gPSB7XHJcbiAgICAgICAgICBlZGdlczogW11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uZWRnZXMucHVzaChhW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGEgPSBncmFwaC5ub2RlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHR5cGUgPSBhW2ldLnR5cGUgfHwgZGVmYXVsdE5vZGVUeXBlO1xyXG4gICAgICBrID0gKHR5cGUgJiYgc2lnbWEud2ViZ2wubm9kZXNbdHlwZV0pID8gdHlwZSA6ICdkZWYnO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLm5vZGVGbG9hdEFycmF5c1trXSlcclxuICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXSA9IHtcclxuICAgICAgICAgIG5vZGVzOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5ub2Rlcy5wdXNoKGFbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1c2ggZWRnZXM6XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcclxuICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1trXTtcclxuICAgICAgYSA9IHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmVkZ2VzO1xyXG5cclxuICAgICAgLy8gQ3JlYXRpbmcgdGhlIG5lY2Vzc2FyeSBhcnJheXNcclxuICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xyXG4gICAgICApO1xyXG5cclxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblxyXG4gICAgICAgIC8vIEp1c3QgY2hlY2sgdGhhdCB0aGUgZWRnZSBhbmQgYm90aCBpdHMgZXh0cmVtaXRpZXMgYXJlIHZpc2libGU6XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgIWFbaV0uaGlkZGVuICYmXHJcbiAgICAgICAgICAhZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLmhpZGRlbiAmJlxyXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KS5oaWRkZW5cclxuICAgICAgICApXHJcbiAgICAgICAgICByZW5kZXJlci5hZGRFZGdlKFxyXG4gICAgICAgICAgICBhW2ldLFxyXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSksXHJcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KSxcclxuICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXHJcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxyXG4gICAgICAgICAgICBvcHRpb25zLnByZWZpeCxcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1xyXG4gICAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlci5jb21wdXRlSW5kaWNlcyA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2tdID0gcmVuZGVyZXIuY29tcHV0ZUluZGljZXMoXHJcbiAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVzaCBub2RlczpcclxuICAgIGZvciAoayBpbiB0aGlzLm5vZGVGbG9hdEFycmF5cykge1xyXG4gICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLm5vZGVzW2tdO1xyXG4gICAgICBhID0gdGhpcy5ub2RlRmxvYXRBcnJheXNba10ubm9kZXM7XHJcblxyXG4gICAgICAvLyBDcmVhdGluZyB0aGUgbmVjZXNzYXJ5IGFycmF5c1xyXG4gICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXHJcbiAgICAgICAgYS5sZW5ndGggKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5KVxyXG4gICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEp1c3QgY2hlY2sgdGhhdCB0aGUgZWRnZSBhbmQgYm90aCBpdHMgZXh0cmVtaXRpZXMgYXJlIHZpc2libGU6XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgIWFbaV0uaGlkZGVuXHJcbiAgICAgICAgKVxyXG4gICAgICAgICAgcmVuZGVyZXIuYWRkTm9kZShcclxuICAgICAgICAgICAgYVtpXSxcclxuICAgICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXksXHJcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxyXG4gICAgICAgICAgICBvcHRpb25zLnByZWZpeCxcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1xyXG4gICAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoLiBJdCBiYXNpY2FsbHkgY2FsbHMgZWFjaCBwcm9ncmFtIChhbmRcclxuICAgKiBnZW5lcmF0ZSB0aGVtIGlmIHRoZXkgZG8gbm90IGV4aXN0IHlldCkgdG8gcmVuZGVyIG5vZGVzIGFuZCBlZGdlcywgYmF0Y2hlZFxyXG4gICAqIHBlciByZW5kZXJlci5cclxuICAgKlxyXG4gICAqIEFzIGluIHRoZSBjYW52YXMgcmVuZGVyZXIsIGl0IGlzIHBvc3NpYmxlIHRvIGRpc3BsYXkgZWRnZXMsIG5vZGVzIGFuZCAvIG9yXHJcbiAgICogbGFiZWxzIGluIGJhdGNoZXMsIHRvIG1ha2UgdGhlIHdob2xlIHRoaW5nIHdheSBtb3JlIHNjYWxhYmxlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICBwYXJhbXMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cclxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcclxuICAgIHZhciBhLFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBrLFxyXG4gICAgICAgIG8sXHJcbiAgICAgICAgcHJvZ3JhbSxcclxuICAgICAgICByZW5kZXJlcixcclxuICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXHJcbiAgICAgICAgbm9kZXNHbCA9IHRoaXMuY29udGV4dHMubm9kZXMsXHJcbiAgICAgICAgZWRnZXNHbCA9IHRoaXMuY29udGV4dHMuZWRnZXMsXHJcbiAgICAgICAgbWF0cml4ID0gdGhpcy5jYW1lcmEuZ2V0TWF0cml4KCksXHJcbiAgICAgICAgb3B0aW9ucyA9IHNpZ21hLnV0aWxzLmV4dGVuZChwYXJhbXMsIHRoaXMub3B0aW9ucyksXHJcbiAgICAgICAgZHJhd0xhYmVscyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdMYWJlbHMnKSxcclxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcclxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKTtcclxuXHJcbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XHJcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXHJcbiAgICAgIGlmICh0aGlzLmNhbWVyYS5pc0FuaW1hdGVkIHx8IHRoaXMuY2FtZXJhLmlzTW92aW5nKVxyXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIENsZWFyIGNhbnZhc2VzOlxyXG4gICAgdGhpcy5jbGVhcigpO1xyXG5cclxuICAgIC8vIFRyYW5zbGF0ZSBtYXRyaXggdG8gW3dpZHRoLzIsIGhlaWdodC8yXTpcclxuICAgIG1hdHJpeCA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxyXG4gICAgICBtYXRyaXgsXHJcbiAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnRyYW5zbGF0aW9uKHRoaXMud2lkdGggLyAyLCB0aGlzLmhlaWdodCAvIDIpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEtpbGwgcnVubmluZyBqb2JzOlxyXG4gICAgZm9yIChrIGluIHRoaXMuam9icylcclxuICAgICAgaWYgKGNvbnJhZC5oYXNKb2IoaykpXHJcbiAgICAgICAgY29ucmFkLmtpbGxKb2Ioayk7XHJcblxyXG4gICAgaWYgKGRyYXdFZGdlcykge1xyXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnYmF0Y2hFZGdlc0RyYXdpbmcnKSlcclxuICAgICAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgYSxcclxuICAgICAgICAgICAgICBrLFxyXG4gICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgam9iLFxyXG4gICAgICAgICAgICAgIGFycixcclxuICAgICAgICAgICAgICBlbmQsXHJcbiAgICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgICAgaW5kaWNlcyxcclxuICAgICAgICAgICAgICByZW5kZXJlcixcclxuICAgICAgICAgICAgICBiYXRjaFNpemUsXHJcbiAgICAgICAgICAgICAgY3VycmVudFByb2dyYW07XHJcblxyXG4gICAgICAgICAgaWQgPSAnZWRnZXNfJyArIHRoaXMuY29ucmFkSWQ7XHJcbiAgICAgICAgICBiYXRjaFNpemUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbEVkZ2VzQmF0Y2hTaXplJyk7XHJcbiAgICAgICAgICBhID0gT2JqZWN0LmtleXModGhpcy5lZGdlRmxvYXRBcnJheXMpO1xyXG5cclxuICAgICAgICAgIGlmICghYS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcclxuICAgICAgICAgIGFyciA9IHRoaXMuZWRnZUZsb2F0QXJyYXlzW2FbaV1dLmFycmF5O1xyXG4gICAgICAgICAgaW5kaWNlcyA9IHRoaXMuZWRnZUluZGljZXNBcnJheXNbYVtpXV07XHJcbiAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgc3RhcnQgKyBiYXRjaFNpemUgKiByZW5kZXJlci5QT0lOVFMsXHJcbiAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGpvYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRnZVByb2dyYW1zW2FbaV1dKVxyXG4gICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dID0gcmVuZGVyZXIuaW5pdFByb2dyYW0oZWRnZXNHbCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pO1xyXG4gICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcclxuICAgICAgICAgICAgICAgIGVkZ2VzR2wsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSxcclxuICAgICAgICAgICAgICAgIGFycixcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXHJcbiAgICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxyXG4gICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxyXG4gICAgICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMuc2V0dGluZ3MoXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbydcclxuICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICBjb3VudDogZW5kIC0gc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgIGluZGljZXNEYXRhOiBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2F0Y2ggam9iJ3MgZW5kOlxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgZW5kID49IGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTICYmXHJcbiAgICAgICAgICAgICAgaSA9PT0gYS5sZW5ndGggLSAxXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGVuZCA+PSBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFUykge1xyXG4gICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcclxuICAgICAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2FbaV1dO1xyXG4gICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxyXG4gICAgICAgICAgICAgICAgYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVNcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xyXG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgc3RhcnQgKyBiYXRjaFNpemUgKiByZW5kZXJlci5QT0lOVFMsXHJcbiAgICAgICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xyXG4gICAgICAgICAgY29ucmFkLmFkZEpvYihpZCwgam9iLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0pLmNhbGwodGhpcyk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAoayBpbiB0aGlzLmVkZ2VGbG9hdEFycmF5cykge1xyXG4gICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1trXTtcclxuXHJcbiAgICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxyXG4gICAgICAgICAgaWYgKCF0aGlzLmVkZ2VQcm9ncmFtc1trXSlcclxuICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShlZGdlc0dsKTtcclxuXHJcbiAgICAgICAgICAvLyBSZW5kZXJcclxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSkge1xyXG4gICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNba10pO1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXHJcbiAgICAgICAgICAgICAgZWRnZXNHbCxcclxuICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1trXSxcclxuICAgICAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxyXG4gICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzRGF0YTogdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZHJhd05vZGVzKSB7XHJcbiAgICAgIC8vIEVuYWJsZSBibGVuZGluZzpcclxuICAgICAgbm9kZXNHbC5ibGVuZEZ1bmMobm9kZXNHbC5TUkNfQUxQSEEsIG5vZGVzR2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcbiAgICAgIG5vZGVzR2wuZW5hYmxlKG5vZGVzR2wuQkxFTkQpO1xyXG5cclxuICAgICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKSB7XHJcbiAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5ub2Rlc1trXTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcclxuICAgICAgICBpZiAoIXRoaXMubm9kZVByb2dyYW1zW2tdKVxyXG4gICAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShub2Rlc0dsKTtcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyXHJcbiAgICAgICAgaWYgKHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdKSB7XHJcbiAgICAgICAgICBub2Rlc0dsLnVzZVByb2dyYW0odGhpcy5ub2RlUHJvZ3JhbXNba10pO1xyXG4gICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxyXG4gICAgICAgICAgICBub2Rlc0dsLFxyXG4gICAgICAgICAgICB0aGlzLm5vZGVQcm9ncmFtc1trXSxcclxuICAgICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXksXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcclxuICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcclxuICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChkcmF3TGFiZWxzKSB7XHJcbiAgICAgIGEgPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxyXG4gICAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IGNhbWVyYSB2aWV3IHRvIHRoZXNlIG5vZGVzOlxyXG4gICAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBub2RlczogYSxcclxuICAgICAgICAgIGVkZ2VzOiBbXSxcclxuICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIG8gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5zZXR0aW5ncyh7XHJcbiAgICAgICAgICBwcmVmaXg6IHNlbGYuY2FtZXJhLnByZWZpeFxyXG4gICAgICAgIH0sIGtleSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcclxuICAgICAgICAgIChcclxuICAgICAgICAgICAgc2lnbWEuY2FudmFzLmxhYmVsc1tcclxuICAgICAgICAgICAgICBhW2ldLnR5cGUgfHxcclxuICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxyXG4gICAgICAgICAgICBdIHx8IHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmXHJcbiAgICAgICAgICApKGFbaV0sIHRoaXMuY29udGV4dHMubGFiZWxzLCBvKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xyXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcclxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICB0YWcgICBUaGUgbGFiZWwgdGFnLlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBpZCAgICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFwiZG9tRWxlbWVudHNcIikuXHJcbiAgICogQHBhcmFtICB7P2Jvb2xlYW59IHdlYmdsIFdpbGwgaW5pdCB0aGUgV2ViR0wgY29udGV4dCBpZiB0cnVlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZywgaWQsIHdlYmdsKSB7XHJcbiAgICB2YXIgZ2wsXHJcbiAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdzaWdtYS0nICsgaWQpO1xyXG5cclxuICAgIHRoaXMuZG9tRWxlbWVudHNbaWRdID0gZG9tO1xyXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tKTtcclxuXHJcbiAgICBpZiAodGFnLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XHJcbiAgICAgIHRoaXMuY29udGV4dHNbaWRdID0gZG9tLmdldENvbnRleHQod2ViZ2wgPyAnZXhwZXJpbWVudGFsLXdlYmdsJyA6ICcyZCcsIHtcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBZGRpbmcgd2ViZ2wgY29udGV4dCBsb3NzIGxpc3RlbmVyc1xyXG4gICAgICBpZiAod2ViZ2wpIHtcclxuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIHNlbGYucmVuZGVyKCk7XHJcbiAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xyXG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICB3aWR0aCAgVGhlIG5ldyB3aWR0aCBvZiB0aGUgY29udGFpbmVyLlxyXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xyXG4gICAgdmFyIGssXHJcbiAgICAgICAgb2xkV2lkdGggPSB0aGlzLndpZHRoLFxyXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgIHBpeGVsUmF0aW8gPSBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XHJcblxyXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHc7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgICB3ID0gdGhpcy53aWR0aDtcclxuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xyXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzW2tdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcclxuICAgICAgICAgIC8vIElmIHNpbXBsZSAyRCBjYW52YXM6XHJcbiAgICAgICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykgKyAncHgnKTtcclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIChoICogcGl4ZWxSYXRpbykgKyAncHgnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKVxyXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dHNba10uc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgICAnd2lkdGgnLFxyXG4gICAgICAgICAgICAgICh3ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAgICAgICAgJ2hlaWdodCcsXHJcbiAgICAgICAgICAgICAgKGggKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJykpICsgJ3B4J1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNjYWxlOlxyXG4gICAgZm9yIChrIGluIHRoaXMuY29udGV4dHMpXHJcbiAgICAgIGlmICh0aGlzLmNvbnRleHRzW2tdICYmIHRoaXMuY29udGV4dHNba10udmlld3BvcnQpXHJcbiAgICAgICAgdGhpcy5jb250ZXh0c1trXS52aWV3cG9ydChcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgdGhpcy53aWR0aCAqIHRoaXMuc2V0dGluZ3MoJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKSxcclxuICAgICAgICAgIHRoaXMuaGVpZ2h0ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjbGVhcnMgZWFjaCBjYW52YXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmNvbnRleHRzLmxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgdGhpcy5jb250ZXh0cy5ub2Rlcy5jbGVhcih0aGlzLmNvbnRleHRzLm5vZGVzLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgdGhpcy5jb250ZXh0cy5lZGdlcy5jbGVhcih0aGlzLmNvbnRleHRzLmVkZ2VzLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGNvbnRleHRzIGFuZCBvdGhlciBhdHRyaWJ1dGVzLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGssXHJcbiAgICAgICAgY2FwdG9yO1xyXG5cclxuICAgIC8vIEtpbGwgY2FwdG9yczpcclxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcclxuICAgICAgY2FwdG9yLmtpbGwoKTtcclxuICAgIGRlbGV0ZSB0aGlzLmNhcHRvcnM7XHJcblxyXG4gICAgLy8gS2lsbCBjb250ZXh0czpcclxuICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcclxuICAgICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHNba107XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzW2tdO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHM7XHJcbiAgICBkZWxldGUgdGhpcy5jb250ZXh0cztcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wubm9kZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIG5vZGVcclxuICAgKiByZW5kZXJlcnMuIFRoZSBkZWZhdWx0IG9uZSBkcmF3IG5vZGVzIGFzIGRpc2NzLiBIZXJlIGFyZSB0aGUgYXR0cmlidXRlc1xyXG4gICAqIGFueSBub2RlIHJlbmRlcmVyIG11c3QgaGF2ZTpcclxuICAgKlxyXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhIG5vZGUuXHJcbiAgICoge251bWJlcn0gICBBVFRSSUJVVEVTICBUaGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgbmVlZGVkIHRvIGRyYXcgb25lIHBvaW50LlxyXG4gICAqIHtmdW5jdGlvbn0gYWRkTm9kZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYSBub2RlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGJ1ZmZlci4gSGVyZSBpcyB0aGUgYXJndW1lbnRzOlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBub2RlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtudW1iZXJ9ICAgICAgIGluZGV4ICAgVGhlIG5vZGUgaW5kZXggaW4gdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgYXJyYXkuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtGbG9hdDMyQXJyYXl9IGRhdGEgICAgVGhlIHN0YWNrLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cclxuICAgKiB7ZnVuY3Rpb259IHJlbmRlciAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZWZmZWN0aXZlbHkgcmVuZGVyIHRoZSBub2Rlc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgaW50byB0aGUgYnVmZmVyLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICBwcm9ncmFtXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtGbG9hdDMyQXJyYXl9IGRhdGEgICAgVGhlIHN0YWNrIHRvIGdpdmUgdG8gdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBwYXJhbXMgIEFuIG9iamVjdCBjb250YWluaW5nIHNvbWVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLCBsaWtlIHdpZHRoLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cclxuICAgKiB7ZnVuY3Rpb259IGluaXRQcm9ncmFtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgaW5pdGlhdGUgdGhlIHByb2dyYW0sIHdpdGhcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZWxldmFudCBzaGFkZXJzIGFuZCBwYXJhbWV0ZXJzLiBJdCBtdXN0IHJldHVyblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cclxuICAgKlxyXG4gICAqIENoZWNrIHNpZ21hLndlYmdsLm5vZGVzLmRlZiBvciBzaWdtYS53ZWJnbC5ub2Rlcy5mYXN0IHRvIHNlZSBob3cgaXRcclxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBvYmplY3QgXCJzaWdtYS53ZWJnbC5lZGdlc1wiIGNvbnRhaW5zIHRoZSBkaWZmZXJlbnQgV2ViR0wgZWRnZVxyXG4gICAqIHJlbmRlcmVycy4gVGhlIGRlZmF1bHQgb25lIGRyYXcgZWRnZXMgYXMgZGlyZWN0IGxpbmVzLiBIZXJlIGFyZSB0aGVcclxuICAgKiBhdHRyaWJ1dGVzIGFueSBlZGdlIHJlbmRlcmVyIG11c3QgaGF2ZTpcclxuICAgKlxyXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhbiBlZGdlLlxyXG4gICAqIHtudW1iZXJ9ICAgQVRUUklCVVRFUyAgVGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIG5lZWRlZCB0byBkcmF3IG9uZSBwb2ludC5cclxuICAgKiB7ZnVuY3Rpb259IGFkZEVkZ2UgICAgIEEgZnVuY3Rpb24gdGhhdCBhZGRzIGFuIGVkZ2UgdG8gdGhlIGRhdGEgc3RhY2sgdGhhdFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBnaXZlbiB0byB0aGUgYnVmZmVyLiBIZXJlIGlzIHRoZSBhcmd1bWVudHM6XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIGVkZ2VcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgc291cmNlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHRhcmdldFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjay5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgb3B0aW9ucyBTb21lIG9wdGlvbnMuXHJcbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgZWRnZXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGludG8gdGhlIGJ1ZmZlci5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjayB0byBnaXZlIHRvIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgbGlrZSB3aWR0aCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsIHRoZSBjYW1lcmEgcmF0aW8uXHJcbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVsZXZhbnQgc2hhZGVycyBhbmQgcGFyYW1ldGVycy4gSXQgbXVzdCByZXR1cm5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXdseSBjcmVhdGVkIHByb2dyYW0uXHJcbiAgICpcclxuICAgKiBDaGVjayBzaWdtYS53ZWJnbC5lZGdlcy5kZWYgb3Igc2lnbWEud2ViZ2wuZWRnZXMuZmFzdCB0byBzZWUgaG93IGl0XHJcbiAgICogd29ya3MgbW9yZSBwcmVjaXNlbHkuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEuY2FudmFzLmxhYmVsc1wiIGNvbnRhaW5zIHRoZSBkaWZmZXJlbnRcclxuICAgKiBsYWJlbCByZW5kZXJlcnMgZm9yIHRoZSBXZWJHTCByZW5kZXJlci4gU2luY2UgZGlzcGxheWluZyB0ZXh0cyBpbiBXZWJHTCBpc1xyXG4gICAqIGRlZmluaXRlbHkgcGFpbmZ1bCBhbmQgc2luY2UgdGhlcmUgYSB3YXkgbGVzcyBsYWJlbHMgdG8gZGlzcGxheSB0aGFuIG5vZGVzXHJcbiAgICogb3IgZWRnZXMsIHRoZSBkZWZhdWx0IHJlbmRlcmVyIHNpbXBseSByZW5kZXJzIHRoZW0gaW4gYSBjYW52YXMuXHJcbiAgICpcclxuICAgKiBBIGxhYmVscyByZW5kZXJlciBpcyBhIHNpbXBsZSBmdW5jdGlvbiwgdGFraW5nIGFzIGFyZ3VtZW50cyB0aGUgcmVsYXRlZFxyXG4gICAqIG5vZGUsIHRoZSByZW5kZXJlciBhbmQgYSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICBpZiAodHlwZW9mIGNvbnJhZCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIHN2ZyBzaWdtYSdzIHJlbmRlcmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcclxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5zdmc6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIGlmICghKG9wdGlvbnMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxyXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xyXG5cclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgYSxcclxuICAgICAgICBmbixcclxuICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxyXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xyXG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge1xyXG4gICAgICBncmFwaDogbnVsbCxcclxuICAgICAgZ3JvdXBzOiB7fSxcclxuICAgICAgbm9kZXM6IHt9LFxyXG4gICAgICBlZGdlczoge30sXHJcbiAgICAgIGxhYmVsczoge30sXHJcbiAgICAgIGVkZ2VsYWJlbHM6IHt9LFxyXG4gICAgICBob3ZlcnM6IHt9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5tZWFzdXJlbWVudENhbnZhcyA9IG51bGw7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xyXG4gICAgdGhpcy5zZXR0aW5ncyA9IChcclxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXHJcbiAgICAgICkgP1xyXG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XHJcbiAgICAgICAgc2V0dGluZ3M7XHJcblxyXG4gICAgLy8gSXMgdGhlIHJlbmRlcmVyIG1lYW50IHRvIGJlIGZyZWVzdHlsZT9cclxuICAgIHRoaXMuc2V0dGluZ3MoJ2ZyZWVTdHlsZScsICEhdGhpcy5vcHRpb25zLmZyZWVTdHlsZSk7XHJcblxyXG4gICAgLy8gU1ZHIHhtbG5zXHJcbiAgICB0aGlzLnNldHRpbmdzKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xyXG5cclxuICAgIC8vIEluZGV4ZXM6XHJcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSBbXTtcclxuICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IFtdO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcclxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSAncmVuZGVyZXInICsgc2lnbWEudXRpbHMuaWQoKSArICc6JztcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBET00gZWxlbWVudHNcclxuICAgIHRoaXMuaW5pdERPTSgnc3ZnJyk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxyXG4gICAgdGhpcy5jYXB0b3JzID0gW107XHJcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGZuID0gdHlwZW9mIGFbaV0gPT09ICdmdW5jdGlvbicgPyBhW2ldIDogc2lnbWEuY2FwdG9yc1thW2ldXTtcclxuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXHJcbiAgICAgICAgbmV3IGZuKFxyXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaCxcclxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxyXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCaW5kIHJlc2l6ZTpcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgc2VsZi5yZXNpemUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XHJcbiAgICAvLyBUT0RPOiBrZWVwIGFuIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgRE9NIGV2ZW50cz9cclxuICAgIHNpZ21hLm1pc2MuYmluZERPTUV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGgpO1xyXG4gICAgdGhpcy5iaW5kSG92ZXJzKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cclxuICAgIC8vIFJlc2l6ZVxyXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBzdmcgc2NlbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICAgICAgICAgICAgICBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IG9mIG9wdGlvbnMuXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdiZWZvcmVSZW5kZXInKTtcclxuXHJcbiAgICB2YXIgYSxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGssXHJcbiAgICAgICAgZSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIG8sXHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHRhcmdldCxcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBlZGdlcyxcclxuICAgICAgICByZW5kZXJlcnMsXHJcbiAgICAgICAgc3VicmVuZGVyZXJzLFxyXG4gICAgICAgIGluZGV4ID0ge30sXHJcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxyXG4gICAgICAgIG5vZGVzID0gdGhpcy5ncmFwaC5ub2RlcyxcclxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxyXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxyXG4gICAgICAgIGRyYXdOb2RlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdOb2RlcycpLFxyXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXHJcbiAgICAgICAgZHJhd0VkZ2VMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZUxhYmVscycpLFxyXG4gICAgICAgIGRlZmF1bHRFZGdlVHlwZSA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpLFxyXG4gICAgICAgIGVtYmVkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLCB7XHJcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXgsXHJcbiAgICAgICAgICBmb3JjZUxhYmVsczogdGhpcy5vcHRpb25zLmZvcmNlTGFiZWxzXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXHJcbiAgICAgIGlmICh0aGlzLmNhbWVyYS5pc0FuaW1hdGVkIHx8IHRoaXMuY2FtZXJhLmlzTW92aW5nKVxyXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEFwcGx5IHRoZSBjYW1lcmEncyB2aWV3OlxyXG4gICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgIHRoaXMub3B0aW9ucy5wcmVmaXgsXHJcbiAgICAgIHtcclxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gSGlkaW5nIGV2ZXJ5dGhpbmdcclxuICAgIC8vIFRPRE86IGZpbmQgYSBtb3JlIHNlbnNpYmxlIHdheSB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uXHJcbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLm5vZGVzKTtcclxuICAgIHRoaXMuaGlkZURPTUVsZW1lbnRzKHRoaXMuZG9tRWxlbWVudHMuZWRnZXMpO1xyXG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5sYWJlbHMpO1xyXG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5lZGdlbGFiZWxzKTtcclxuXHJcbiAgICAvLyBGaW5kIHdoaWNoIG5vZGVzIGFyZSBvbiBzY3JlZW5cclxuICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IFtdO1xyXG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcclxuICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBOb2RlIGluZGV4XHJcbiAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGluZGV4W2FbaV0uaWRdID0gYVtpXTtcclxuXHJcbiAgICAvLyBGaW5kIHdoaWNoIGVkZ2VzIGFyZSBvbiBzY3JlZW5cclxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgbyA9IGFbaV07XHJcbiAgICAgIGlmIChcclxuICAgICAgICAoaW5kZXhbby5zb3VyY2VdIHx8IGluZGV4W28udGFyZ2V0XSkgJiZcclxuICAgICAgICAoIW8uaGlkZGVuICYmICFub2RlcyhvLnNvdXJjZSkuaGlkZGVuICYmICFub2RlcyhvLnRhcmdldCkuaGlkZGVuKVxyXG4gICAgICApXHJcbiAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuLnB1c2gobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGxheSBub2Rlc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cclxuICAgIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5ub2RlcztcclxuICAgIHN1YnJlbmRlcmVycyA9IHNpZ21hLnN2Zy5sYWJlbHM7XHJcblxyXG4gICAgLy8tLSBGaXJzdCB3ZSBjcmVhdGUgdGhlIG5vZGVzIHdoaWNoIGFyZSBub3QgYWxyZWFkeSBjcmVhdGVkXHJcbiAgICBpZiAoZHJhd05vZGVzKVxyXG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuICYmICF0aGlzLmRvbUVsZW1lbnRzLm5vZGVzW2FbaV0uaWRdKSB7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZVxyXG4gICAgICAgICAgZSA9IChyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS5jcmVhdGUoXHJcbiAgICAgICAgICAgIGFbaV0sXHJcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSA9IGU7XHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5ub2Rlcy5hcHBlbmRDaGlsZChlKTtcclxuXHJcbiAgICAgICAgICAvLyBMYWJlbFxyXG4gICAgICAgICAgaWYgKGRyYXdMYWJlbHMpIHtcclxuICAgICAgICAgICAgZSA9IChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCBzdWJyZW5kZXJlcnMuZGVmKS5jcmVhdGUoXHJcbiAgICAgICAgICAgICAgYVtpXSxcclxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmxhYmVsc1thW2ldLmlkXSA9IGU7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmxhYmVscy5hcHBlbmRDaGlsZChlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAvLy0tIFNlY29uZCB3ZSB1cGRhdGUgdGhlIG5vZGVzXHJcbiAgICBpZiAoZHJhd05vZGVzKVxyXG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHJcbiAgICAgICAgaWYgKGFbaV0uaGlkZGVuKVxyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIC8vIE5vZGVcclxuICAgICAgICAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikudXBkYXRlKFxyXG4gICAgICAgICAgYVtpXSxcclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0sXHJcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gTGFiZWxcclxuICAgICAgICBpZiAoZHJhd0xhYmVscykge1xyXG4gICAgICAgICAgKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHN1YnJlbmRlcmVycy5kZWYpLnVwZGF0ZShcclxuICAgICAgICAgICAgYVtpXSxcclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5sYWJlbHNbYVtpXS5pZF0sXHJcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgLy8gRGlzcGxheSBlZGdlc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cclxuICAgIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5lZGdlcztcclxuICAgIHN1YnJlbmRlcmVycyA9IHNpZ21hLnN2Zy5lZGdlcy5sYWJlbHM7XHJcblxyXG4gICAgLy8tLSBGaXJzdCB3ZSBjcmVhdGUgdGhlIGVkZ2VzIHdoaWNoIGFyZSBub3QgYWxyZWFkeSBjcmVhdGVkXHJcbiAgICBpZiAoZHJhd0VkZ2VzKVxyXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0pIHtcclxuICAgICAgICAgIHNvdXJjZSA9IG5vZGVzKGFbaV0uc291cmNlKTtcclxuICAgICAgICAgIHRhcmdldCA9IG5vZGVzKGFbaV0udGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8XHJcbiAgICAgICAgICAgIHJlbmRlcmVyc1tkZWZhdWx0RWRnZVR5cGVdIHx8XHJcbiAgICAgICAgICAgIHJlbmRlcmVycy5kZWZcclxuICAgICAgICAgICkuY3JlYXRlKFxyXG4gICAgICAgICAgICBhW2ldLFxyXG4gICAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzW2FbaV0uaWRdID0gZTtcclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmVkZ2VzLmFwcGVuZENoaWxkKGUpO1xyXG5cclxuICAgICAgICAgIC8vIExhYmVsXHJcbiAgICAgICAgICBpZiAoZHJhd0VkZ2VMYWJlbHMpIHtcclxuXHJcbiAgICAgICAgICAgIGUgPSAoc3VicmVuZGVyZXJzW2FbaV0udHlwZV0gfHxcclxuICAgICAgICAgICAgICBzdWJyZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSAgfHxcclxuICAgICAgICAgICAgICBzdWJyZW5kZXJlcnMuZGVmXHJcbiAgICAgICAgICAgICkuY3JlYXRlKFxyXG4gICAgICAgICAgICAgIGFbaV0sXHJcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmVkZ2VsYWJlbHNbYVtpXS5pZF0gPSBlO1xyXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5lZGdlbGFiZWxzLmFwcGVuZENoaWxkKGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAvLy0tIFNlY29uZCB3ZSB1cGRhdGUgdGhlIGVkZ2VzXHJcbiAgICBpZiAoZHJhd0VkZ2VzKVxyXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBzb3VyY2UgPSBub2RlcyhhW2ldLnNvdXJjZSk7XHJcbiAgICAgICAgdGFyZ2V0ID0gbm9kZXMoYVtpXS50YXJnZXQpO1xyXG5cclxuICAgICAgICAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHxcclxuICAgICAgICAgIHJlbmRlcmVyc1tkZWZhdWx0RWRnZVR5cGVdIHx8XHJcbiAgICAgICAgICByZW5kZXJlcnMuZGVmXHJcbiAgICAgICAgKS51cGRhdGUoXHJcbiAgICAgICAgICBhW2ldLFxyXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSxcclxuICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBMYWJlbFxyXG4gICAgICAgIGlmIChkcmF3RWRnZUxhYmVscykge1xyXG4gICAgICAgICAgKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8XHJcbiAgICAgICAgICAgIHN1YnJlbmRlcmVyc1tkZWZhdWx0RWRnZVR5cGVdIHx8XHJcbiAgICAgICAgICAgIHN1YnJlbmRlcmVycy5kZWZcclxuICAgICAgICAgICkudXBkYXRlKFxyXG4gICAgICAgICAgICBhW2ldLFxyXG4gICAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlbGFiZWxzW2FbaV0uaWRdLFxyXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xyXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcclxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnIFRoZSBsYWJlbCB0YWcuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpbiBcImRvbUVsZW1lbnRzXCIpLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmluaXRET00gPSBmdW5jdGlvbih0YWcpIHtcclxuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgdGFnKSxcclxuICAgICAgICBjID0gdGhpcy5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSxcclxuICAgICAgICBnLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgaTtcclxuXHJcbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjICsgJy1zdmcnKTtcclxuXHJcbiAgICAvLyBTZXR0aW5nIFNWRyBuYW1lc3BhY2VcclxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgdGhpcy5zZXR0aW5ncygneG1sbnMnKSk7XHJcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XHJcbiAgICBkb20uc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywgJzEuMScpO1xyXG5cclxuICAgIC8vIENyZWF0aW5nIHRoZSBtZWFzdXJlbWVudCBjYW52YXNcclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctbWVhc3VyZW1lbnQtY2FudmFzJyk7XHJcblxyXG4gICAgLy8gQXBwZW5kaW5nIGVsZW1lbnRzXHJcbiAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoID0gdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tKTtcclxuXHJcbiAgICAvLyBDcmVhdGluZyBncm91cHNcclxuICAgIHZhciBncm91cHMgPSBbJ2VkZ2VzJywgJ25vZGVzJywgJ2VkZ2VsYWJlbHMnLCAnbGFiZWxzJywgJ2hvdmVycyddO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLnNldHRpbmdzKCd4bWxucycpLCAnZycpO1xyXG5cclxuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCBjICsgJy1ncm91cC0nICsgZ3JvdXBzW2ldKTtcclxuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBjICsgJy1ncm91cCcpO1xyXG5cclxuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHNbZ3JvdXBzW2ldXSA9XHJcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5hcHBlbmRDaGlsZChnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBlbmRpbmcgbWVhc3VyZW1lbnQgY2FudmFzXHJcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xyXG4gICAgdGhpcy5tZWFzdXJlbWVudENhbnZhcyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGhpZGVzIGEgYmF0Y2ggb2YgU1ZHIERPTSBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2FycmF5fSAgICAgICAgICAgICAgICAgIGVsZW1lbnRzICBBbiBhcnJheSBvZiBlbGVtZW50cyB0byBoaWRlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIHJlbmRlcmVyICBUaGUgcmVuZGVyZXIgdG8gdXNlLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuaGlkZURPTUVsZW1lbnRzID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcclxuICAgIHZhciBvLFxyXG4gICAgICAgIGk7XHJcblxyXG4gICAgZm9yIChpIGluIGVsZW1lbnRzKSB7XHJcbiAgICAgIG8gPSBlbGVtZW50c1tpXTtcclxuICAgICAgc2lnbWEuc3ZnLnV0aWxzLmhpZGUobyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgYmluZHMgdGhlIGhvdmVyIGV2ZW50cyB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHByZWZpeCBUaGUgcmVuZGVyZXIgcHJlZml4LlxyXG4gICAqL1xyXG4gIC8vIFRPRE86IGFkZCBvcHRpb24gYWJvdXQgd2hldGhlciB0byBkaXNwbGF5IGhvdmVycyBvciBub3RcclxuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5iaW5kSG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICB2YXIgcmVuZGVyZXJzID0gc2lnbWEuc3ZnLmhvdmVycyxcclxuICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICBob3ZlcmVkTm9kZTtcclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVIb3ZlcnMoZSkge1xyXG4gICAgICB2YXIgbm9kZSxcclxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XHJcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoZS5kYXRhLmVudGVyLm5vZGVzLmxlbmd0aCA+IDApIHsgLy8gb3ZlclxyXG4gICAgICAgIG5vZGUgPSBlLmRhdGEuZW50ZXIubm9kZXNbMF07XHJcbiAgICAgICAgdmFyIGhvdmVyID0gKHJlbmRlcmVyc1tub2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcclxuICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLm5vZGVzW25vZGUuaWRdLFxyXG4gICAgICAgICAgc2VsZi5tZWFzdXJlbWVudENhbnZhcyxcclxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tub2RlLmlkXSA9IGhvdmVyO1xyXG5cclxuICAgICAgICAvLyBJbnNlcnRpbmcgdGhlIGhvdmVyIGluIHRoZSBkb21cclxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xyXG4gICAgICAgIGhvdmVyZWROb2RlID0gbm9kZTtcclxuICAgICAgfSBlbHNlIGlmIChlLmRhdGEubGVhdmUubm9kZXMubGVuZ3RoID4gMCkgeyAvLyBvdXRcclxuICAgICAgICBub2RlID0gZS5kYXRhLmxlYXZlLm5vZGVzWzBdO1xyXG5cclxuICAgICAgICAvLyBEZWxldGluZyBlbGVtZW50XHJcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLnJlbW92ZUNoaWxkKFxyXG4gICAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF1cclxuICAgICAgICApO1xyXG4gICAgICAgIGhvdmVyZWROb2RlID0gbnVsbDtcclxuICAgICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF07XHJcblxyXG4gICAgICAgIC8vIFJlaW5zdGF0ZVxyXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLm5vZGVzLmFwcGVuZENoaWxkKFxyXG4gICAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBPUFRJTUlaRTogcGVyZm9ybSBhIHJlYWwgdXBkYXRlIHJhdGhlciB0aGFuIGEgZGVsZXRpb25cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuICAgICAgaWYgKCFob3ZlcmVkTm9kZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB2YXIgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcclxuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gRGVsZXRpbmcgZWxlbWVudCBiZWZvcmUgdXBkYXRlXHJcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5yZW1vdmVDaGlsZChcclxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF1cclxuICAgICAgKTtcclxuICAgICAgZGVsZXRlIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW2hvdmVyZWROb2RlLmlkXTtcclxuXHJcbiAgICAgIHZhciBob3ZlciA9IChyZW5kZXJlcnNbaG92ZXJlZE5vZGUudHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxyXG4gICAgICAgIGhvdmVyZWROb2RlLFxyXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbaG92ZXJlZE5vZGUuaWRdLFxyXG4gICAgICAgIHNlbGYubWVhc3VyZW1lbnRDYW52YXMsXHJcbiAgICAgICAgZW1iZWRTZXR0aW5nc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdID0gaG92ZXI7XHJcblxyXG4gICAgICAvLyBJbnNlcnRpbmcgdGhlIGhvdmVyIGluIHRoZSBkb21cclxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLmFwcGVuZENoaWxkKGhvdmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCaW5kaW5nIGV2ZW50c1xyXG4gICAgdGhpcy5iaW5kKCdob3ZlcnMnLCB1cGRhdGVIb3ZlcnMpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBvbiByZW5kZXJcclxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgdXBkYXRlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XHJcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICB3aWR0aCAgVGhlIG5ldyB3aWR0aCBvZiB0aGUgY29udGFpbmVyLlxyXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xyXG4gICAgdmFyIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcclxuICAgICAgICBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICBpZiAodyAhPT0gdW5kZWZpbmVkICYmIGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLndpZHRoID0gdztcclxuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBsYWJlbHMsIG5vZGVzIGFuZCBlZGdlcyByZW5kZXJlcnMgYXJlIHN0b3JlZCBpbiB0aGUgdGhyZWUgZm9sbG93aW5nXHJcbiAgICogb2JqZWN0cy4gV2hlbiBhbiBlbGVtZW50IGlzIGRyYXduLCBpdHMgdHlwZSB3aWxsIGJlIGNoZWNrZWQgYW5kIGlmIGFcclxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXHJcbiAgICogZGVmYXVsdCByZW5kZXJlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgKlxyXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vc3ZnXCIgZm9sZGVyLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLm5vZGVzJyk7XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5sYWJlbHMnKTtcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlbGFiZWxzJyk7XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnJlbmRlcmVycycpO1xyXG5cclxuICAvLyBDb3B5IHRoZSBnb29kIHJlbmRlcmVyOlxyXG4gIHNpZ21hLnJlbmRlcmVycy5kZWYgPSBzaWdtYS51dGlscy5pc1dlYkdMU3VwcG9ydGVkKCkgP1xyXG4gICAgc2lnbWEucmVuZGVyZXJzLndlYmdsIDpcclxuICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXM7XHJcbn0pKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBhcyBkaXNjcywgc2hhcGVkIGluIHRyaWFuZ2xlcyB3aXRoXHJcbiAgICogdGhlIGdsLlRSSUFOR0xFUyBkaXNwbGF5IG1vZGUuIFNvLCB0byBiZSBtb3JlIHByZWNpc2UsIHRvIGRyYXcgb25lIG5vZGUsXHJcbiAgICogaXQgd2lsbCBzdG9yZSB0aHJlZSB0aW1lcyB0aGUgY2VudGVyIG9mIG5vZGUsIHdpdGggdGhlIGNvbG9yIGFuZCB0aGUgc2l6ZSxcclxuICAgKiBhbmQgYW4gYW5nbGUgaW5kaWNhdGluZyB3aGljaCBcImNvcm5lclwiIG9mIHRoZSB0cmlhbmdsZSB0byBkcmF3LlxyXG4gICAqXHJcbiAgICogVGhlIGZyYWdtZW50IHNoYWRlciBkb2VzIG5vdCBkZWFsIHdpdGggYW50aS1hbGlhc2luZywgc28gbWFrZSBzdXJlIHRoYXRcclxuICAgKiB5b3UgZGVhbCB3aXRoIGl0IHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIChieSBkZWZhdWx0LCB0aGUgV2ViR0xcclxuICAgKiByZW5kZXJlciB3aWxsIG92ZXJzYW1wbGUgdGhlIHJlbmRlcmluZyB0aHJvdWdoIHRoZSB3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvXHJcbiAgICogdmFsdWUpLlxyXG4gICAqL1xyXG4gIHNpZ21hLndlYmdsLm5vZGVzLmRlZiA9IHtcclxuICAgIFBPSU5UUzogMyxcclxuICAgIEFUVFJJQlVURVM6IDUsXHJcbiAgICBhZGROb2RlOiBmdW5jdGlvbihub2RlLCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoXHJcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuICAgICAgZGF0YVtpKytdID0gMDtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG4gICAgICBkYXRhW2krK10gPSAyICogTWF0aC5QSSAvIDM7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuICAgICAgZGF0YVtpKytdID0gNCAqIE1hdGguUEkgLyAzO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xyXG4gICAgICB2YXIgYnVmZmVyO1xyXG5cclxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XHJcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcclxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3NpemUnKSxcclxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxyXG4gICAgICAgICAgYW5nbGVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2FuZ2xlJyksXHJcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxyXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXHJcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXHJcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XHJcblxyXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xyXG5cclxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcclxuICAgICAgZ2wudW5pZm9ybTFmKFxyXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXHJcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcclxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xyXG5cclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhbmdsZUxvY2F0aW9uKTtcclxuXHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcclxuICAgICAgICAyLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAwXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgc2l6ZUxvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDhcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICBjb2xvckxvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDEyXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgYW5nbGVMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAxNlxyXG4gICAgICApO1xyXG5cclxuICAgICAgZ2wuZHJhd0FycmF5cyhcclxuICAgICAgICBnbC5UUklBTkdMRVMsXHJcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXHJcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcclxuICAgICAgKTtcclxuICAgIH0sXHJcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcclxuICAgICAgdmFyIHZlcnRleFNoYWRlcixcclxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxyXG4gICAgICAgICAgcHJvZ3JhbTtcclxuXHJcbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXHJcbiAgICAgICAgZ2wsXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9zaXplOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTsnLFxyXG5cclxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXHJcblxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcclxuICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHJhZGl1czsnLFxyXG5cclxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XHJcbiAgICAgICAgICAgICdyYWRpdXMgPSBhX3NpemUgKiB1X3JhdGlvOycsXHJcblxyXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxyXG4gICAgICAgICAgICAndmVjMiBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5OycsXHJcbiAgICAgICAgICAgIC8vICdjZW50ZXIgPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSk7JyxcclxuICAgICAgICAgICAgJ2NlbnRlciA9IHBvc2l0aW9uICogdV9zY2FsZTsnLFxyXG4gICAgICAgICAgICAnY2VudGVyID0gdmVjMihjZW50ZXIueCwgdV9zY2FsZSAqIHVfcmVzb2x1dGlvbi55IC0gY2VudGVyLnkpOycsXHJcblxyXG4gICAgICAgICAgICAncG9zaXRpb24gPSBwb3NpdGlvbiArJyxcclxuICAgICAgICAgICAgICAnMi4wICogcmFkaXVzICogdmVjMihjb3MoYV9hbmdsZSksIHNpbihhX2FuZ2xlKSk7JyxcclxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gKHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpOycsXHJcblxyXG4gICAgICAgICAgICAncmFkaXVzID0gcmFkaXVzICogdV9zY2FsZTsnLFxyXG5cclxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMCwgMSk7JyxcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxyXG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxyXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXHJcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcclxuICAgICAgICBnbCxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuXHJcbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXHJcbiAgICAgICAgICAndmFyeWluZyB2ZWMyIGNlbnRlcjsnLFxyXG4gICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgcmFkaXVzOycsXHJcblxyXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcclxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXHJcblxyXG4gICAgICAgICAgICAndmVjMiBtID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gY2VudGVyOycsXHJcbiAgICAgICAgICAgICdmbG9hdCBkaWZmID0gcmFkaXVzIC0gc3FydChtLnggKiBtLnggKyBtLnkgKiBtLnkpOycsXHJcblxyXG4gICAgICAgICAgICAvLyBIZXJlIGlzIGhvdyB3ZSBkcmF3IGEgZGlzYyBpbnN0ZWFkIG9mIGEgc3F1YXJlOlxyXG4gICAgICAgICAgICAnaWYgKGRpZmYgPiAwLjApJyxcclxuICAgICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcclxuICAgICAgICAgICAgJ2Vsc2UnLFxyXG4gICAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjA7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XHJcblxyXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBpbiB0aGUgZmFzdGVzdCB3YXk6IE5vZGVzIGFyZSBiYXNpY1xyXG4gICAqIHNxdWFyZXMsIGRyYXduIHRocm91Z2ggdGhlIGdsLlBPSU5UUyBkcmF3aW5nIG1ldGhvZC4gVGhlIHNpemUgb2YgdGhlIG5vZGVzXHJcbiAgICogYXJlIHJlcHJlc2VudGVkIHdpdGggdGhlIFwiZ2xfUG9pbnRTaXplXCIgdmFsdWUgaW4gdGhlIHZlcnRleCBzaGFkZXIuXHJcbiAgICpcclxuICAgKiBJdCBpcyB0aGUgZmFzdGVzdCBub2RlIHJlbmRlcmVyIGhlcmUgc2luY2UgdGhlIGJ1ZmZlciBqdXN0IHRha2VzIG9uZSBsaW5lXHJcbiAgICogdG8gZHJhdyBlYWNoIG5vZGUgKHdpdGggYXR0cmlidXRlcyBcInhcIiwgXCJ5XCIsIFwic2l6ZVwiIGFuZCBcImNvbG9yXCIpLlxyXG4gICAqXHJcbiAgICogTmV2ZXJ0aGVsZXNzLCB0aGlzIG1ldGhvZCBoYXMgc29tZSBwcm9ibGVtcywgZXNwZWNpYWxseSBkdWUgdG8gc29tZSBpc3N1ZXNcclxuICAgKiB3aXRoIHRoZSBnbC5QT0lOVFM6XHJcbiAgICogIC0gRmlyc3QsIGlmIHRoZSBjZW50ZXIgb2YgYSBub2RlIGlzIG91dHNpZGUgdGhlIHNjZW5lLCB0aGUgcG9pbnQgd2lsbCBub3RcclxuICAgKiAgICBiZSBkcmF3biwgZXZlbiBpZiBpdCBzaG91bGQgYmUgcGFydGx5IG9uIHNjcmVlbi5cclxuICAgKiAgLSBJIHRyaWVkIGFwcGx5aW5nIGEgZnJhZ21lbnQgc2hhZGVyIHNpbWlsYXIgdG8gdGhlIG9uZSBpbiB0aGUgZGVmYXVsdFxyXG4gICAqICAgIG5vZGUgcmVuZGVyZXIgdG8gZGlzcGxheSB0aGVtIGFzIGRpc2NzLCBidXQgaXQgZGlkIG5vdCB3b3JrIGZpbmUgb25cclxuICAgKiAgICBzb21lIGNvbXB1dGVycyBzZXR0aW5ncywgZmlsbGluZyB0aGUgZGlzY3Mgd2l0aCB3ZWlyZCBncmFkaWVudHMgbm90XHJcbiAgICogICAgZGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgY29sb3IuXHJcbiAgICovXHJcbiAgc2lnbWEud2ViZ2wubm9kZXMuZmFzdCA9IHtcclxuICAgIFBPSU5UUzogMSxcclxuICAgIEFUVFJJQlVURVM6IDQsXHJcbiAgICBhZGROb2RlOiBmdW5jdGlvbihub2RlLCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XHJcbiAgICAgIGRhdGFbaSsrXSA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoXHJcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XHJcbiAgICAgIHZhciBidWZmZXI7XHJcblxyXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcclxuICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxyXG4gICAgICAgICAgc2l6ZUxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2Ffc2l6ZScpLFxyXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXHJcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxyXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXHJcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXHJcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XHJcblxyXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xyXG5cclxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcclxuICAgICAgZ2wudW5pZm9ybTFmKFxyXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXHJcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcclxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xyXG5cclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xyXG5cclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICBwb3NpdGlvbkxvY2F0aW9uLFxyXG4gICAgICAgIDIsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDBcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICBzaXplTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgOFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG4gICAgICAgIGNvbG9yTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMTJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGdsLmRyYXdBcnJheXMoXHJcbiAgICAgICAgZ2wuUE9JTlRTLFxyXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxyXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XHJcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcclxuICAgICAgICAgIHByb2dyYW07XHJcblxyXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcclxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcclxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcclxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcclxuXHJcbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxyXG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXHJcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSAvJyxcclxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcclxuICAgICAgICAgICAgICAnMCwnLFxyXG4gICAgICAgICAgICAgICcxJyxcclxuICAgICAgICAgICAgJyk7JyxcclxuXHJcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxyXG4gICAgICAgICAgICAvLyAgLSB4IFNDQUxJTkdfUkFUSU8gdG8gY29ycmVjdCB0aGUgY2FudmFzIHNjYWxpbmdcclxuICAgICAgICAgICAgLy8gIC0geCAyIHRvIGNvcnJlY3QgdGhlIGZvcm11bGFlXHJcbiAgICAgICAgICAgICdnbF9Qb2ludFNpemUgPSBhX3NpemUgKiB1X3JhdGlvICogdV9zY2FsZSAqIDIuMDsnLFxyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XHJcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxyXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxyXG4gICAgICAgICAgICAnZmxvYXQgYm9yZGVyID0gMC4wMTsnLFxyXG4gICAgICAgICAgICAnZmxvYXQgcmFkaXVzID0gMC41OycsXHJcblxyXG4gICAgICAgICAgICAndmVjNCBjb2xvcjAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7JyxcclxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTsnLFxyXG4gICAgICAgICAgICAnZmxvYXQgZGlzdCA9IHJhZGl1cyAtIHNxcnQobS54ICogbS54ICsgbS55ICogbS55KTsnLFxyXG5cclxuICAgICAgICAgICAgJ2Zsb2F0IHQgPSAwLjA7JyxcclxuICAgICAgICAgICAgJ2lmIChkaXN0ID4gYm9yZGVyKScsXHJcbiAgICAgICAgICAgICAgJ3QgPSAxLjA7JyxcclxuICAgICAgICAgICAgJ2Vsc2UgaWYgKGRpc3QgPiAwLjApJyxcclxuICAgICAgICAgICAgICAndCA9IGRpc3QgLyBib3JkZXI7JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IwLCBjb2xvciwgdCk7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XHJcblxyXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBsaW5lcyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxyXG4gICAqIHRvIHRoZSB0YXJnZXQgbm9kZS4gVG8gZGVhbCB3aXRoIGVkZ2UgdGhpY2tuZXNzZXMsIHRoZSBsaW5lcyBhcmUgbWFkZSBvZlxyXG4gICAqIHR3byB0cmlhbmdsZXMgZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZyBtb2RlLlxyXG4gICAqXHJcbiAgICogSXQgaXMgZXhwZW5zaXZlLCBzaW5jZSBkcmF3aW5nIGEgc2luZ2xlIGVkZ2UgcmVxdWlyZXMgNiBwb2ludHMsIGVhY2hcclxuICAgKiBoYXZpbmcgNyBhdHRyaWJ1dGVzIChzb3VyY2UgcG9zaXRpb24sIHRhcmdldCBwb3NpdGlvbiwgdGhpY2tuZXNzLCBjb2xvclxyXG4gICAqIGFuZCBhIGZsYWcgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlIG9mIHRoZSByZWN0YW5nbGUgaXQgaXMpLlxyXG4gICAqL1xyXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmRlZiA9IHtcclxuICAgIFBPSU5UUzogNixcclxuICAgIEFUVFJJQlVURVM6IDcsXHJcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgdyA9IChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSkgLyAyLFxyXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICB4MiA9IHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcclxuXHJcbiAgICAgIGlmICghY29sb3IpXHJcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcclxuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcclxuICAgICAgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcclxuICAgICAgdmFyIGJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxyXG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXHJcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMSA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uMScpLFxyXG4gICAgICAgICAgcG9zaXRpb25Mb2NhdGlvbjIgPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjInKSxcclxuICAgICAgICAgIHRoaWNrbmVzc0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGhpY2tuZXNzJyksXHJcbiAgICAgICAgICBtaW51c0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcclxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXHJcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcclxuICAgICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxyXG4gICAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGlNaW51cycpLFxyXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxyXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xyXG5cclxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcclxuICAgICAgZ2wudW5pZm9ybTFmKFxyXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXHJcbiAgICAgICAgcGFyYW1zLnJhdGlvIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSlcclxuICAgICAgKTtcclxuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xyXG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXHJcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oTWF0aC5QSSAvIDIsIHRydWUpXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXHJcbiAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbixcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbigtTWF0aC5QSSAvIDIsIHRydWUpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjEpO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaWNrbmVzc0xvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobWludXNMb2NhdGlvbik7XHJcblxyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24xLFxyXG4gICAgICAgIDIsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDBcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMixcclxuICAgICAgICAyLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICA4XHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMTZcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihtaW51c0xvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDIwXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAyNFxyXG4gICAgICApO1xyXG5cclxuICAgICAgZ2wuZHJhd0FycmF5cyhcclxuICAgICAgICBnbC5UUklBTkdMRVMsXHJcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXHJcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcclxuICAgICAgKTtcclxuICAgIH0sXHJcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcclxuICAgICAgdmFyIHZlcnRleFNoYWRlcixcclxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxyXG4gICAgICAgICAgcHJvZ3JhbTtcclxuXHJcbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXHJcbiAgICAgICAgZ2wsXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24xOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjI7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90aGlja25lc3M7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcclxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcclxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcclxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcclxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcclxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGlNaW51czsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XHJcbiAgICAgICAgICAgICd2ZWMyIHBvc2l0aW9uID0gYV90aGlja25lc3MgKiB1X3JhdGlvIConLFxyXG4gICAgICAgICAgICAgICdub3JtYWxpemUoYV9wb3NpdGlvbjIgLSBhX3Bvc2l0aW9uMSk7JyxcclxuXHJcbiAgICAgICAgICAgICdtYXQyIG1hdHJpeCA9IGFfbWludXMgKiB1X21hdHJpeEhhbGZQaU1pbnVzICsnLFxyXG4gICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaTsnLFxyXG5cclxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gbWF0cml4ICogcG9zaXRpb24gKyBhX3Bvc2l0aW9uMTsnLFxyXG5cclxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcclxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxyXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5IC8nLFxyXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxyXG4gICAgICAgICAgICAgICcwLCcsXHJcbiAgICAgICAgICAgICAgJzEnLFxyXG4gICAgICAgICAgICAnKTsnLFxyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XHJcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxyXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxyXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XHJcblxyXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBsaW5lcyB3aXRoIHRoZSBnbC5MSU5FUyBkaXNwbGF5XHJcbiAgICogbW9kZS4gU2luY2UgdGhpcyBtb2RlIGRvZXMgbm90IHN1cHBvcnQgd2VsbCB0aGlja25lc3MsIGVkZ2VzIGFyZSBhbGwgZHJhd25cclxuICAgKiB3aXRoIHRoZSBzYW1lIHRoaWNrbmVzcyAoM3B4KSwgaW5kZXBlbmRhbnRseSBvZiB0aGUgZWRnZSBhdHRyaWJ1dGVzIG9yIHRoZVxyXG4gICAqIHpvb21pbmcgcmF0aW8uXHJcbiAgICovXHJcbiAgc2lnbWEud2ViZ2wuZWRnZXMuZmFzdCA9IHtcclxuICAgIFBPSU5UUzogMixcclxuICAgIEFUVFJJQlVURVM6IDMsXHJcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgdyA9IChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSkgLyAyLFxyXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICB4MiA9IHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcclxuXHJcbiAgICAgIGlmICghY29sb3IpXHJcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcclxuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcclxuICAgICAgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xyXG4gICAgICB2YXIgYnVmZmVyO1xyXG5cclxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XHJcbiAgICAgIHZhciBjb2xvckxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcclxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxyXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcclxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpO1xyXG5cclxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcclxuXHJcbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcclxuXHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcclxuXHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbixcclxuICAgICAgICAyLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAwXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICA4XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBnbC5saW5lV2lkdGgoMyk7XHJcbiAgICAgIGdsLmRyYXdBcnJheXMoXHJcbiAgICAgICAgZ2wuTElORVMsXHJcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXHJcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcclxuICAgICAgKTtcclxuICAgIH0sXHJcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcclxuICAgICAgdmFyIHZlcnRleFNoYWRlcixcclxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxyXG4gICAgICAgICAgcHJvZ3JhbTtcclxuXHJcbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXHJcbiAgICAgICAgZ2wsXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXHJcblxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcclxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxyXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHkgLycsXHJcbiAgICAgICAgICAgICAgICAndV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpLCcsXHJcbiAgICAgICAgICAgICAgJzAsJyxcclxuICAgICAgICAgICAgICAnMScsXHJcbiAgICAgICAgICAgICcpOycsXHJcblxyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcclxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXHJcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxyXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxyXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxyXG4gICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcclxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXHJcbiAgICAgICAgZ2wsXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcblxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXHJcbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjsnLFxyXG4gICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcclxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcclxuXHJcbiAgICAgIHJldHVybiBwcm9ncmFtO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGFycm93cyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxyXG4gICAqIHRvIHRoZSB0YXJnZXQgbm9kZS4gVG8gZGVhbCB3aXRoIGVkZ2UgdGhpY2tuZXNzZXMsIHRoZSBsaW5lcyBhcmUgbWFkZSBvZlxyXG4gICAqIHRocmVlIHRyaWFuZ2xlczogdHdvIGZvcm1pbmcgcmVjdGFuZ2xlcywgd2l0aCB0aGUgZ2wuVFJJQU5HTEVTIGRyYXdpbmdcclxuICAgKiBtb2RlLlxyXG4gICAqXHJcbiAgICogSXQgaXMgZXhwZW5zaXZlLCBzaW5jZSBkcmF3aW5nIGEgc2luZ2xlIGVkZ2UgcmVxdWlyZXMgOSBwb2ludHMsIGVhY2hcclxuICAgKiBoYXZpbmcgYSBsb3Qgb2YgYXR0cmlidXRlcy5cclxuICAgKi9cclxuICBzaWdtYS53ZWJnbC5lZGdlcy5hcnJvdyA9IHtcclxuICAgIFBPSU5UUzogOSxcclxuICAgIEFUVFJJQlVURVM6IDExLFxyXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcclxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICB0YXJnZXRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XHJcblxyXG4gICAgICBpZiAoIWNvbG9yKVxyXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XHJcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XHJcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcclxuICAgICAgZGF0YVtpKytdID0gMS4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICAvLyBBcnJvdyBoZWFkOlxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcclxuICAgICAgZGF0YVtpKytdID0gMS4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gLTEuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcclxuICAgICAgZGF0YVtpKytdID0gMS4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMS4wO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xyXG4gICAgICB2YXIgYnVmZmVyO1xyXG5cclxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XHJcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uMSA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczEnKSxcclxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24yID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zMicpLFxyXG4gICAgICAgICAgdGhpY2tuZXNzTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90aGlja25lc3MnKSxcclxuICAgICAgICAgIHRhcmdldFNpemVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RTaXplJyksXHJcbiAgICAgICAgICBkZWxheUxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfZGVsYXknKSxcclxuICAgICAgICAgIG1pbnVzTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9taW51cycpLFxyXG4gICAgICAgICAgaGVhZExvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZCcpLFxyXG4gICAgICAgICAgaGVhZFBvc2l0aW9uTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9oZWFkUG9zaXRpb24nKSxcclxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxyXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcclxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxyXG4gICAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpJyksXHJcbiAgICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaU1pbnVzJyksXHJcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXHJcbiAgICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9ub2RlUmF0aW8nKSxcclxuICAgICAgICAgIGFycm93SGVhZExvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2Fycm93SGVhZCcpLFxyXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xyXG5cclxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcclxuICAgICAgZ2wudW5pZm9ybTFmKFxyXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXHJcbiAgICAgICAgcGFyYW1zLnJhdGlvIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSlcclxuICAgICAgKTtcclxuICAgICAgZ2wudW5pZm9ybTFmKFxyXG4gICAgICAgIG5vZGVSYXRpb0xvY2F0aW9uLFxyXG4gICAgICAgIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpIC9cclxuICAgICAgICBwYXJhbXMucmF0aW9cclxuICAgICAgKTtcclxuICAgICAgZ2wudW5pZm9ybTFmKGFycm93SGVhZExvY2F0aW9uLCA1LjApO1xyXG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcclxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcclxuICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbixcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcclxuICAgICAgKTtcclxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcclxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKC1NYXRoLlBJIC8gMiwgdHJ1ZSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24xKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjIpO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRhcmdldFNpemVMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbGF5TG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShtaW51c0xvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaGVhZExvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaGVhZFBvc2l0aW9uTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcclxuXHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjEsXHJcbiAgICAgICAgMixcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24yLFxyXG4gICAgICAgIDIsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDhcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlja25lc3NMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAxNlxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRhcmdldFNpemVMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAyMFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGRlbGF5TG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMjRcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihtaW51c0xvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDI4XHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZExvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDMyXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZFBvc2l0aW9uTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMzZcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDQwXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBnbC5kcmF3QXJyYXlzKFxyXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcclxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcclxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxyXG4gICAgICApO1xyXG4gICAgfSxcclxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xyXG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXHJcbiAgICAgICAgICBwcm9ncmFtO1xyXG5cclxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcclxuICAgICAgICBnbCxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MxOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MyOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdGhpY2tuZXNzOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdFNpemU7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9kZWxheTsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX21pbnVzOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfaGVhZDsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2hlYWRQb3NpdGlvbjsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcclxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcclxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfbm9kZVJhdGlvOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X2Fycm93SGVhZDsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaTsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaU1pbnVzOycsXHJcblxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZ29vZCBwb2ludDpcclxuICAgICAgICAgICAgJ3ZlYzIgcG9zID0gbm9ybWFsaXplKGFfcG9zMiAtIGFfcG9zMSk7JyxcclxuXHJcbiAgICAgICAgICAgICdtYXQyIG1hdHJpeCA9ICgxLjAgLSBhX2hlYWQpIConLFxyXG4gICAgICAgICAgICAgICcoJyxcclxuICAgICAgICAgICAgICAgICdhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcclxuICAgICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaScsXHJcbiAgICAgICAgICAgICAgJykgKyBhX2hlYWQgKiAoJyxcclxuICAgICAgICAgICAgICAgICdhX2hlYWRQb3NpdGlvbiAqIHVfbWF0cml4SGFsZlBpTWludXMgKiAwLjYgKycsXHJcbiAgICAgICAgICAgICAgICAnKGFfaGVhZFBvc2l0aW9uICogYV9oZWFkUG9zaXRpb24gLSAxLjApICogbWF0MigxLjApJyxcclxuICAgICAgICAgICAgICAnKTsnLFxyXG5cclxuICAgICAgICAgICAgJ3BvcyA9IGFfcG9zMSArICgnLFxyXG4gICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBib2R5OlxyXG4gICAgICAgICAgICAgICcoMS4wIC0gYV9oZWFkKSAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcclxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggaGVhZDpcclxuICAgICAgICAgICAgICAnYV9oZWFkICogdV9hcnJvd0hlYWQgKiBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKiBtYXRyaXggKiBwb3MgKycsXHJcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGRlbGF5OlxyXG4gICAgICAgICAgICAgICdhX2RlbGF5ICogcG9zICogKCcsXHJcbiAgICAgICAgICAgICAgICAnYV90U2l6ZSAvIHVfbm9kZVJhdGlvICsnLFxyXG4gICAgICAgICAgICAgICAgJ3VfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvJyxcclxuICAgICAgICAgICAgICAnKScsXHJcbiAgICAgICAgICAgICcpOycsXHJcblxyXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxyXG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXHJcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKHBvcywgMSkpLnh5IC8nLFxyXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxyXG4gICAgICAgICAgICAgICcwLCcsXHJcbiAgICAgICAgICAgICAgJzEnLFxyXG4gICAgICAgICAgICAnKTsnLFxyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XHJcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxyXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxyXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XHJcblxyXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbGFiZWwgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBsYWJlbCBvZiB0aGUgbm9kZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtICB7b2JqZWN0P30gICAgICAgICAgICAgICAgICBpbmZvcyAgICBUaGUgYmF0Y2ggaW5mb3MuXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLmxhYmVscy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncywgaW5mb3MpIHtcclxuICAgIHZhciBmb250U2l6ZSxcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdmb250U3R5bGUnKSxcclxuICAgICAgICBib3JkZXJTaXplID0gc2V0dGluZ3MoJ25vZGVCb3JkZXJTaXplJyksXHJcbiAgICAgICAgbGFiZWxXaWR0aCxcclxuICAgICAgICBsYWJlbE9mZnNldFgsXHJcbiAgICAgICAgbGFiZWxPZmZzZXRZLFxyXG4gICAgICAgIGFsaWdubWVudCA9IHNldHRpbmdzKCdsYWJlbEFsaWdubWVudCcpLFxyXG4gICAgICAgIG1heExpbmVMZW5ndGggPSBzZXR0aW5ncygnbWF4Tm9kZUxhYmVsTGluZUxlbmd0aCcpIHx8IDA7XHJcblxyXG4gICAgaWYgKHNpemUgPD0gc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBpZiAoIW5vZGUubGFiZWwgfHwgdHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XHJcbiAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxyXG4gICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XHJcblxyXG4gICAgdmFyIG5ld19mb250ID0gKGZvbnRTdHlsZSA/IGZvbnRTdHlsZSArICcgJyA6ICcnKSArXHJcbiAgICAgIGZvbnRTaXplICsgJ3B4ICcgK1xyXG4gICAgICAobm9kZS5hY3RpdmUgP1xyXG4gICAgICAgIHNldHRpbmdzKCdhY3RpdmVGb250JykgfHwgc2V0dGluZ3MoJ2ZvbnQnKSA6XHJcbiAgICAgICAgc2V0dGluZ3MoJ2ZvbnQnKSk7XHJcblxyXG4gICAgaWYgKGluZm9zICYmIGluZm9zLmN0eC5mb250ICE9IG5ld19mb250KSB7IC8vdXNlIGZvbnQgdmFsdWUgY2FjaGluZ1xyXG4gICAgICBjb250ZXh0LmZvbnQgPSBuZXdfZm9udDtcclxuICAgICAgaW5mb3MuY3R4LmZvbnQgPSBuZXdfZm9udDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRleHQuZm9udCA9IG5ld19mb250O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID1cclxuICAgICAgICAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XHJcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpIDpcclxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcclxuXHJcbiAgICBsYWJlbE9mZnNldFggPSAwO1xyXG4gICAgbGFiZWxPZmZzZXRZID0gZm9udFNpemUgLyAzO1xyXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuXHJcbiAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xyXG4gICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgIGxhYmVsT2Zmc2V0WSA9ICsgc2l6ZSArIDQgKiBmb250U2l6ZSAvIDM7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICBsYWJlbE9mZnNldFggPSAtIHNpemUgLSBib3JkZXJTaXplIC0gMztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICBsYWJlbE9mZnNldFkgPSAtIHNpemUgLSAyICogZm9udFNpemUgLyAzO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdpbnNpZGUnOlxyXG4gICAgICAgIGxhYmVsV2lkdGggPSBzaWdtYS51dGlscy5jYW52YXMuZ2V0VGV4dFdpZHRoKGNvbnRleHQsIHNldHRpbmdzKCdhcHByb3hpbWF0ZUxhYmVsV2lkdGgnKSwgZm9udFNpemUsIG5vZGUubGFiZWwpO1xyXG4gICAgICAgIGlmIChsYWJlbFdpZHRoIDw9IChzaXplICsgZm9udFNpemUgLyAzKSAqIDIpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCovXHJcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCovXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgbGFiZWxPZmZzZXRYID0gc2l6ZSArIGJvcmRlclNpemUgKyAzO1xyXG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsaW5lcyA9IGdldExpbmVzKG5vZGUubGFiZWwsIG1heExpbmVMZW5ndGgpLFxyXG4gICAgICAgIGJhc2VYID0gbm9kZVtwcmVmaXggKyAneCddICsgbGFiZWxPZmZzZXRYLFxyXG4gICAgICAgIGJhc2VZID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBsYWJlbE9mZnNldFkpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgYmFzZVgsIGJhc2VZICsgaSAqIChmb250U2l6ZSArIDEpKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTcGxpdCBhIHRleHQgaW50byBzZXZlcmFsIGxpbmVzLiBFYWNoIGxpbmUgd29uJ3QgYmUgbG9uZ2VyIHRoYW4gdGhlIHNwZWNpZmllZCBtYXhpbXVtIGxlbmd0aC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgICAgICAgICAgICBUZXh0IHRvIHNwbGl0XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBtYXhMaW5lTGVuZ3RoICAgTWF4aW11bSBsZW5ndGggb2YgYSBsaW5lLiBBIHZhbHVlIDw9IDEgd2lsbCBiZSB0cmVhdGVkIGFzIFwiaW5maW5pdHlcIi5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gICAgICAgICBMaXN0IG9mIGxpbmVzXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0TGluZXModGV4dCwgbWF4TGluZUxlbmd0aCkge1xyXG4gICAgaWYgKG1heExpbmVMZW5ndGggPD0gMSkge1xyXG4gICAgICByZXR1cm4gW3RleHRdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKSxcclxuICAgICAgICBsaW5lcyA9IFtdLFxyXG4gICAgICAgIGxpbmVMZW5ndGggPSAwLFxyXG4gICAgICAgIGxpbmVJbmRleCA9IC0xLFxyXG4gICAgICAgIGxpbmVMaXN0ID0gW10sXHJcbiAgICAgICAgbGluZUZ1bGwgPSB0cnVlO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgaWYgKGxpbmVGdWxsKSB7XHJcbiAgICAgICAgaWYgKHdvcmRzW2ldLmxlbmd0aCA+IG1heExpbmVMZW5ndGgpIHtcclxuICAgICAgICAgIHZhciBwYXJ0cyA9IHNwbGl0V29yZCh3b3Jkc1tpXSwgbWF4TGluZUxlbmd0aCk7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goW3BhcnRzW2pdXSk7XHJcbiAgICAgICAgICAgICsrbGluZUluZGV4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGluZUxlbmd0aCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGluZXMucHVzaChbd29yZHNbaV1cclxuICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgKytsaW5lSW5kZXg7XHJcbiAgICAgICAgICBsaW5lTGVuZ3RoID0gd29yZHNbaV0ubGVuZ3RoICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGluZUZ1bGwgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmIChsaW5lTGVuZ3RoICsgd29yZHNbaV0ubGVuZ3RoIDw9IG1heExpbmVMZW5ndGgpIHtcclxuICAgICAgICBsaW5lc1tsaW5lSW5kZXhdLnB1c2god29yZHNbaV0pO1xyXG4gICAgICAgIGxpbmVMZW5ndGggKz0gd29yZHNbaV0ubGVuZ3RoICsgMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsaW5lRnVsbCA9IHRydWU7XHJcbiAgICAgICAgLS1pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGxpbmVMaXN0LnB1c2gobGluZXNbaV0uam9pbignICcpKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsaW5lTGlzdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwbGl0IGEgd29yZCBpbnRvIHNldmVyYWwgbGluZXMgKHdpdGggYSAnLScgYXQgdGhlIGVuZCBvZiBlYWNoIGxpbmUgYnV0IHRoZSBsYXN0KS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gd29yZCAgICAgICBXb3JkIHRvIHNwbGl0XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aCAgTWF4aW11bSBsZW5ndGggb2YgYSBsaW5lXHJcbiAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59ICAgTGlzdCBvZiBsaW5lc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNwbGl0V29yZCh3b3JkLCBtYXhMZW5ndGgpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZC5sZW5ndGg7IGkgKz0gbWF4TGVuZ3RoIC0gMSkge1xyXG4gICAgICBwYXJ0cy5wdXNoKHdvcmQuc3Vic3RyKGksIG1heExlbmd0aCAtIDEpICsgJy0nKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGFzdFBhcnRMZW4gPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5sZW5ndGg7XHJcbiAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnN1YnN0cigwLCBsYXN0UGFydExlbiAtIDEpICsgJyAnO1xyXG5cclxuICAgIHJldHVybiBwYXJ0cztcclxuICB9XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ob3ZlcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGJhc2ljYWxseSBkaXNwbGF5IHRoZSBsYWJlbCB3aXRoIGEgYmFja2dyb3VuZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhbnZhcy5ob3ZlcnMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgIHZhciB4LFxyXG4gICAgICAgIHksXHJcbiAgICAgICAgdyxcclxuICAgICAgICBoLFxyXG4gICAgICAgIGUsXHJcbiAgICAgICAgbGFiZWxYLFxyXG4gICAgICAgIGxhYmVsWSxcclxuICAgICAgICBsaW5lcyxcclxuICAgICAgICBiYXNlWCxcclxuICAgICAgICBiYXNlWSxcclxuICAgICAgICBib3JkZXJTaXplID0gc2V0dGluZ3MoJ25vZGVCb3JkZXJTaXplJyksXHJcbiAgICAgICAgYWxpZ25tZW50ID0gc2V0dGluZ3MoJ2xhYmVsQWxpZ25tZW50JyksXHJcbiAgICAgICAgZm9udFN0eWxlID0gc2V0dGluZ3MoJ2hvdmVyRm9udFN0eWxlJykgfHwgc2V0dGluZ3MoJ2ZvbnRTdHlsZScpLFxyXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAgIG1heExpbmVMZW5ndGggPSBzZXR0aW5ncygnbWF4Tm9kZUxhYmVsTGluZUxlbmd0aCcpIHx8IDAsXHJcbiAgICAgICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XHJcbiAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcclxuICAgICAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcclxuXHJcblxyXG4gICAgLy8gTGFiZWwgYmFja2dyb3VuZDpcclxuICAgIGNvbnRleHQuZm9udCA9IChmb250U3R5bGUgPyBmb250U3R5bGUgKyAnICcgOiAnJykgK1xyXG4gICAgICBmb250U2l6ZSArICdweCAnICsgKHNldHRpbmdzKCdob3ZlckZvbnQnKSB8fCBzZXR0aW5ncygnZm9udCcpKTtcclxuXHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbGFiZWxIb3ZlckJHQ29sb3InKSA9PT0gJ25vZGUnID9cclxuICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxyXG4gICAgICBzZXR0aW5ncygnZGVmYXVsdEhvdmVyTGFiZWxCR0NvbG9yJyk7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzKCdsYWJlbEhvdmVyU2hhZG93JykpIHtcclxuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcclxuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcclxuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gODtcclxuICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHNldHRpbmdzKCdsYWJlbEhvdmVyU2hhZG93Q29sb3InKTtcclxuICAgIH1cclxuXHJcbiAgICBsaW5lcyA9IGdldExpbmVzKG5vZGUubGFiZWwsIG1heExpbmVMZW5ndGgpO1xyXG4gICAgZHJhd0hvdmVyQm9yZGVyKGFsaWdubWVudCwgY29udGV4dCwgZm9udFNpemUsIG5vZGUsIGxpbmVzLCBtYXhMaW5lTGVuZ3RoKTtcclxuXHJcbiAgICAvLyBOb2RlIGJvcmRlcjpcclxuICAgIGlmIChib3JkZXJTaXplID4gMCkge1xyXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdub2RlQm9yZGVyQ29sb3InKSA9PT0gJ25vZGUnID9cclxuICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XHJcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQm9yZGVyQ29sb3InKTtcclxuICAgICAgY29udGV4dC5hcmMoXHJcbiAgICAgICAgbm9kZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICBzaXplICsgYm9yZGVyU2l6ZSxcclxuICAgICAgICAwLFxyXG4gICAgICAgIE1hdGguUEkgKiAyLFxyXG4gICAgICAgIHRydWVcclxuICAgICAgKTtcclxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9kZTpcclxuICAgIHZhciBub2RlUmVuZGVyZXIgPSBzaWdtYS5jYW52YXMubm9kZXNbbm9kZS50eXBlXSB8fCBzaWdtYS5jYW52YXMubm9kZXMuZGVmO1xyXG4gICAgbm9kZVJlbmRlcmVyKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKTtcclxuXHJcbiAgICAvLyBEaXNwbGF5IHRoZSBsYWJlbDpcclxuICAgIGlmIChub2RlLmxhYmVsICYmIHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xyXG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcclxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xyXG4gICAgICB2YXIgbGFiZWxXaWR0aCA9IHNpZ21hLnV0aWxzLmNhbnZhcy5nZXRUZXh0V2lkdGgoY29udGV4dCxcclxuICAgICAgICAgICAgc2V0dGluZ3MoJ2FwcHJveGltYXRlTGFiZWxXaWR0aCcpLCBmb250U2l6ZSwgbm9kZS5sYWJlbCksXHJcbiAgICAgICAgICBsYWJlbE9mZnNldFggPSAtIGxhYmVsV2lkdGggLyAyLFxyXG4gICAgICAgICAgbGFiZWxPZmZzZXRZID0gZm9udFNpemUgLyAzO1xyXG5cclxuICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcclxuICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgbGFiZWxPZmZzZXRZID0gKyBzaXplICsgNCAqIGZvbnRTaXplIC8gMztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgIGxhYmVsT2Zmc2V0WCA9IC0gc2l6ZSAtIGJvcmRlclNpemUgLSAzIC0gbGFiZWxXaWR0aDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICBsYWJlbE9mZnNldFkgPSAtIHNpemUgLSAyICogZm9udFNpemUgLyAzO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaW5zaWRlJzpcclxuICAgICAgICAgIGlmIChsYWJlbFdpZHRoIDw9IChzaXplICsgZm9udFNpemUgLyAzKSAqIDIpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCovXHJcbiAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2gqL1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBsYWJlbE9mZnNldFggPSBzaXplICsgYm9yZGVyU2l6ZSArIDM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgYmFzZVggPSBub2RlW3ByZWZpeCArICd4J10gKyBsYWJlbE9mZnNldFg7XHJcbiAgICAgIGJhc2VZID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBsYWJlbE9mZnNldFkpO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIGJhc2VYLCBiYXNlWSArIGkgKiAoZm9udFNpemUgKyAxKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3SG92ZXJCb3JkZXIoYWxpZ25tZW50LCBjb250ZXh0LCBmb250U2l6ZSwgbm9kZSwgbGluZXMsIG1heExpbmVMZW5ndGgpIHtcclxuICAgICAgdmFyIGxhYmVsV2lkdGggPVxyXG4gICAgICAgIChtYXhMaW5lTGVuZ3RoID4gMSAmJiBsaW5lcy5sZW5ndGggPiAxKSA/XHJcbiAgICAgICAgMC42ICogbWF4TGluZUxlbmd0aCAqIGZvbnRTaXplIDpcclxuICAgICAgICBzaWdtYS51dGlscy5jYW52YXMuZ2V0VGV4dFdpZHRoKFxyXG4gICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgIHNldHRpbmdzKCdhcHByb3hpbWF0ZUxhYmVsV2lkdGgnKSxcclxuICAgICAgICAgIGZvbnRTaXplLFxyXG4gICAgICAgICAgbGluZXNbMF1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgdmFyIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSksXHJcbiAgICAgICAgICB5ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10pLFxyXG4gICAgICAgICAgaCA9ICgoZm9udFNpemUgKyAxKSAqIGxpbmVzLmxlbmd0aCkgKyA0LFxyXG4gICAgICAgICAgZSA9IE1hdGgucm91bmQoc2l6ZSArIGZvbnRTaXplIC8gNCksXHJcbiAgICAgICAgICB3ID0gTWF0aC5yb3VuZChsYWJlbFdpZHRoICsgc2l6ZSArIDEuNSArIGZvbnRTaXplIC8gMyk7XHJcblxyXG4gICAgICBpZiAobm9kZS5sYWJlbCAmJiB0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBkcmF3IGEgcmVjdGFuZ2xlIGZvciB0aGUgbGFiZWxcclxuICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xyXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgZm9udFNpemUgLyAyICsgMik7XHJcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSArIGUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFyY1RvKHgsIHksIHggLSBlLCB5LCBlKTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCAtIHcgLSBib3JkZXJTaXplIC0gZSwgeSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHggLSB3IC0gYm9yZGVyU2l6ZSAtIGUsIHkgKyBoKTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCAtIGUsIHkgKyBoKTtcclxuICAgICAgICAgICAgY29udGV4dC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSBlLCBlKTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSArIGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVjdCh4IC0gdyAvIDIsIHkgLSBlIC0gaCwgdywgaCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgY29udGV4dC5yZWN0KHggLSB3IC8gMiwgeSArIGUsIHcsIGgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XHJcbiAgICAgICAgICAgIGlmIChsYWJlbFdpZHRoIDw9IGUgKiAyKSB7XHJcbiAgICAgICAgICAgICAgLy8gZG9uJ3QgZHJhdyBhbnl0aGluZ1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVzZSBkZWZhdWx0IHNldHRpbmcsIGZhbGxpbmcgdGhyb3VnaFxyXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCovXHJcbiAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoKi9cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xyXG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkgKyBlKTtcclxuICAgICAgICAgICAgY29udGV4dC5hcmNUbyh4LCB5LCB4ICsgZSwgeSwgZSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHggKyB3ICsgYm9yZGVyU2l6ZSArIGUsIHkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgdyArIGJvcmRlclNpemUgKyBlLCB5ICsgaCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHggKyBlLCB5ICsgaCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gZSwgZSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkgKyBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICBjb250ZXh0LmZpbGwoKTtcclxuXHJcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XHJcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGxpdCBhIHRleHQgaW50byBzZXZlcmFsIGxpbmVzLiBFYWNoIGxpbmUgd29uJ3QgYmUgbG9uZ2VyIHRoYW4gdGhlIHNwZWNpZmllZCBtYXhpbXVtIGxlbmd0aC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgdGV4dCAgICAgICAgICAgIFRleHQgdG8gc3BsaXRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgbWF4TGluZUxlbmd0aCAgIE1heGltdW0gbGVuZ3RoIG9mIGEgbGluZS4gQSB2YWx1ZSA8PSAxIHdpbGwgYmUgdHJlYXRlZCBhcyBcImluZmluaXR5XCIuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gICAgICAgICBMaXN0IG9mIGxpbmVzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldExpbmVzKHRleHQsIG1heExpbmVMZW5ndGgpIHtcclxuICAgICAgaWYgKG1heExpbmVMZW5ndGggPD0gMSkge1xyXG4gICAgICAgIHJldHVybiBbdGV4dF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKSxcclxuICAgICAgICBsaW5lcyA9IFtdLFxyXG4gICAgICAgIGxpbmVMZW5ndGggPSAwLFxyXG4gICAgICAgIGxpbmVJbmRleCA9IC0xLFxyXG4gICAgICAgIGxpbmVMaXN0ID0gW10sXHJcbiAgICAgICAgbGluZUZ1bGwgPSB0cnVlO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChsaW5lRnVsbCkge1xyXG4gICAgICAgICAgaWYgKHdvcmRzW2ldLmxlbmd0aCA+IG1heExpbmVMZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gc3BsaXRXb3JkKHdvcmRzW2ldLCBtYXhMaW5lTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgIGxpbmVzLnB1c2goW3BhcnRzW2pdXSk7XHJcbiAgICAgICAgICAgICAgKytsaW5lSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGluZUxlbmd0aCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goW3dvcmRzW2ldXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICArK2xpbmVJbmRleDtcclxuICAgICAgICAgICAgbGluZUxlbmd0aCA9IHdvcmRzW2ldLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsaW5lRnVsbCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGluZUxlbmd0aCArIHdvcmRzW2ldLmxlbmd0aCA8PSBtYXhMaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgICBsaW5lc1tsaW5lSW5kZXhdLnB1c2god29yZHNbaV0pO1xyXG4gICAgICAgICAgbGluZUxlbmd0aCArPSB3b3Jkc1tpXS5sZW5ndGggKyAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsaW5lRnVsbCA9IHRydWU7XHJcbiAgICAgICAgICAtLWk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBsaW5lTGlzdC5wdXNoKGxpbmVzW2ldLmpvaW4oJyAnKSlcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGxpbmVMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3BsaXQgYSB3b3JkIGludG8gc2V2ZXJhbCBsaW5lcyAod2l0aCBhICctJyBhdCB0aGUgZW5kIG9mIGVhY2ggbGluZSBidXQgdGhlIGxhc3QpLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdvcmQgICAgICAgV29yZCB0byBzcGxpdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aCAgTWF4aW11bSBsZW5ndGggb2YgYSBsaW5lXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gICBMaXN0IG9mIGxpbmVzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNwbGl0V29yZCh3b3JkLCBtYXhMZW5ndGgpIHtcclxuICAgICAgdmFyIHBhcnRzID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmQubGVuZ3RoOyBpICs9IG1heExlbmd0aCAtIDEpIHtcclxuICAgICAgICBwYXJ0cy5wdXNoKHdvcmQuc3Vic3RyKGksIG1heExlbmd0aCAtIDEpICsgJy0nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxhc3RQYXJ0TGVuID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xyXG4gICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnN1YnN0cigwLCBsYXN0UGFydExlbiAtIDEpICsgJyAnO1xyXG5cclxuICAgICAgcmV0dXJuIHBhcnRzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZiA9IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xyXG5cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQuYXJjKFxyXG4gICAgICBub2RlW3ByZWZpeCArICd4J10sXHJcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcclxuICAgICAgbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAwLFxyXG4gICAgICBNYXRoLlBJICogMixcclxuICAgICAgdHJ1ZVxyXG4gICAgKTtcclxuXHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGVmYXVsdCBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBlZGdlIGFzIGEgc2ltcGxlIGxpbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZWRnZXMuZGVmID0gZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXHJcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xyXG5cclxuICAgIGlmICghY29sb3IpXHJcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XHJcbiAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyhcclxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddXHJcbiAgICApO1xyXG4gICAgY29udGV4dC5saW5lVG8oXHJcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXVxyXG4gICAgKTtcclxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGN1cnZlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5jdXJ2ZSA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcclxuICAgICAgICBjcCA9IHt9LFxyXG4gICAgICAgIHNTaXplID0gc291cmNlW3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXTtcclxuXHJcbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xyXG4gICAgICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCBzU2l6ZSkgOlxyXG4gICAgICBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoc1gsIHNZLCB0WCwgdFksIGVkZ2UuY2MpO1xyXG5cclxuICAgIGlmICghY29sb3IpXHJcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XHJcbiAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xyXG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MSwgY3AueTEsIGNwLngyLCBjcC55MiwgdFgsIHRZKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjcC54LCBjcC55LCB0WCwgdFkpO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgYXJyb3dzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZWRnZXMuYXJyb3cgPSBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXHJcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcclxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXHJcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIGFTaXplID0gTWF0aC5tYXgoc2l6ZSAqIDIuNSwgc2V0dGluZ3MoJ21pbkFycm93U2l6ZScpKSxcclxuICAgICAgICBkID0gTWF0aC5zcXJ0KCh0WCAtIHNYKSAqICh0WCAtIHNYKSArICh0WSAtIHNZKSAqICh0WSAtIHNZKSksXHJcbiAgICAgICAgYVggPSBzWCArICh0WCAtIHNYKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxyXG4gICAgICAgIGFZID0gc1kgKyAodFkgLSBzWSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcclxuICAgICAgICB2WCA9ICh0WCAtIHNYKSAqIGFTaXplIC8gZCxcclxuICAgICAgICB2WSA9ICh0WSAtIHNZKSAqIGFTaXplIC8gZDtcclxuXHJcbiAgICBpZiAoIWNvbG9yKVxyXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcclxuICAgIGNvbnRleHQubGluZVRvKFxyXG4gICAgICBhWCxcclxuICAgICAgYVlcclxuICAgICk7XHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYIC0gdlkgKiAwLjYsIGFZICsgdlggKiAwLjYpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGN1cnZlcyB3aXRoIGFycm93IGhlYWRpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZWRnZXMuY3VydmVkQXJyb3cgPVxyXG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXHJcbiAgICAgICAgY3AgPSB7fSxcclxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXHJcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIGFTaXplID0gTWF0aC5tYXgoc2l6ZSAqIDIuNSwgc2V0dGluZ3MoJ21pbkFycm93U2l6ZScpKSxcclxuICAgICAgICBkLFxyXG4gICAgICAgIGFYLFxyXG4gICAgICAgIGFZLFxyXG4gICAgICAgIHZYLFxyXG4gICAgICAgIHZZO1xyXG5cclxuICAgIGNwID0gKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSA/XHJcbiAgICAgIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhzWCwgc1ksIHRTaXplKSA6XHJcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSwgZWRnZS5jYyk7XHJcblxyXG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgIGQgPSBNYXRoLnNxcnQoKHRYIC0gY3AueDEpICogKHRYIC0gY3AueDEpICsgKHRZIC0gY3AueTEpICogKHRZIC0gY3AueTEpKTtcclxuICAgICAgYVggPSBjcC54MSArICh0WCAtIGNwLngxKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xyXG4gICAgICBhWSA9IGNwLnkxICsgKHRZIC0gY3AueTEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XHJcbiAgICAgIHZYID0gKHRYIC0gY3AueDEpICogYVNpemUgLyBkO1xyXG4gICAgICB2WSA9ICh0WSAtIGNwLnkxKSAqIGFTaXplIC8gZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBkID0gTWF0aC5zcXJ0KCh0WCAtIGNwLngpICogKHRYIC0gY3AueCkgKyAodFkgLSBjcC55KSAqICh0WSAtIGNwLnkpKTtcclxuICAgICAgYVggPSBjcC54ICsgKHRYIC0gY3AueCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcclxuICAgICAgYVkgPSBjcC55ICsgKHRZIC0gY3AueSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcclxuICAgICAgdlggPSAodFggLSBjcC54KSAqIGFTaXplIC8gZDtcclxuICAgICAgdlkgPSAodFkgLSBjcC55KSAqIGFTaXplIC8gZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbG9yKVxyXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcclxuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xyXG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3AueDIsIGNwLnkyLCBjcC54MSwgY3AueTEsIGFYLCBhWSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AueCwgY3AueSwgYVgsIGFZKTtcclxuICAgIH1cclxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlkgKiAwLjYsIGFZIC0gdlggKiAwLjYpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcclxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICBjb250ZXh0LmZpbGwoKTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuZGVmID1cclxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXHJcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xyXG5cclxuICAgIGlmICghY29sb3IpXHJcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XHJcbiAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XHJcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XHJcbiAgICB9XHJcbiAgICBzaXplICo9IHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKTtcclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oXHJcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxyXG4gICAgKTtcclxuICAgIGNvbnRleHQubGluZVRvKFxyXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J11cclxuICAgICk7XHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZSA9XHJcbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXHJcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxyXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcclxuICAgICAgICBjcCA9IHt9LFxyXG4gICAgICAgIHNTaXplID0gc291cmNlW3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXTtcclxuXHJcbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xyXG4gICAgICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCBzU2l6ZSkgOlxyXG4gICAgICBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoc1gsIHNZLCB0WCwgdFksIGVkZ2UuY2MpO1xyXG5cclxuICAgIGlmICghY29sb3IpXHJcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XHJcbiAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XHJcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XHJcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNwLngxLCBjcC55MSwgY3AueDIsIGNwLnkyLCB0WCwgdFkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIHRYLCB0WSk7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5hcnJvdyA9XHJcbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXHJcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcclxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXHJcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddO1xyXG5cclxuICAgIHNpemUgPSAoZWRnZS5ob3ZlcikgP1xyXG4gICAgICBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiBzaXplIDogc2l6ZTtcclxuICAgIHZhciBhU2l6ZSA9IE1hdGgubWF4KHNpemUgKiAyLjUsIHNldHRpbmdzKCdtaW5BcnJvd1NpemUnKSksXHJcbiAgICAgICAgZCA9IE1hdGguc3FydCgodFggLSBzWCkgKiAodFggLSBzWCkgKyAodFkgLSBzWSkgKiAodFkgLSBzWSkpLFxyXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcclxuICAgICAgICBhWSA9IHNZICsgKHRZIC0gc1kpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXHJcbiAgICAgICAgdlggPSAodFggLSBzWCkgKiBhU2l6ZSAvIGQsXHJcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XHJcblxyXG4gICAgaWYgKCFjb2xvcilcclxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcclxuICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcclxuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcclxuICAgIGNvbnRleHQubGluZVRvKFxyXG4gICAgICBhWCxcclxuICAgICAgYVlcclxuICAgICk7XHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYIC0gdlkgKiAwLjYsIGFZICsgdlggKiAwLjYpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmN1cnZlZEFycm93ID1cclxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxyXG4gICAgICAgIGNwID0ge30sXHJcbiAgICAgICAgc2l6ZSA9IHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSksXHJcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIGQsXHJcbiAgICAgICAgYVNpemUsXHJcbiAgICAgICAgYVgsXHJcbiAgICAgICAgYVksXHJcbiAgICAgICAgdlgsXHJcbiAgICAgICAgdlk7XHJcblxyXG4gICAgY3AgPSAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpID9cclxuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgdFNpemUpIDpcclxuICAgICAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZLCBlZGdlLmNjKTtcclxuXHJcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgZCA9IE1hdGguc3FydCgodFggLSBjcC54MSkgKiAodFggLSBjcC54MSkgKyAodFkgLSBjcC55MSkgKiAodFkgLSBjcC55MSkpO1xyXG4gICAgICBhU2l6ZSA9IE1hdGgubWF4KHNpemUgKiAyLjUsIHNldHRpbmdzKCdtaW5BcnJvd1NpemUnKSk7XHJcbiAgICAgIGFYID0gY3AueDEgKyAodFggLSBjcC54MSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcclxuICAgICAgYVkgPSBjcC55MSArICh0WSAtIGNwLnkxKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xyXG4gICAgICB2WCA9ICh0WCAtIGNwLngxKSAqIGFTaXplIC8gZDtcclxuICAgICAgdlkgPSAodFkgLSBjcC55MSkgKiBhU2l6ZSAvIGQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgZCA9IE1hdGguc3FydCgodFggLSBjcC54KSAqICh0WCAtIGNwLngpICsgKHRZIC0gY3AueSkgKiAodFkgLSBjcC55KSk7XHJcbiAgICAgIGFTaXplID0gc2l6ZSAqIDIuNTtcclxuICAgICAgYVggPSBjcC54ICsgKHRYIC0gY3AueCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcclxuICAgICAgYVkgPSBjcC55ICsgKHRZIC0gY3AueSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcclxuICAgICAgdlggPSAodFggLSBjcC54KSAqIGFTaXplIC8gZDtcclxuICAgICAgdlkgPSAodFkgLSBjcC55KSAqIGFTaXplIC8gZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbG9yKVxyXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xyXG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xyXG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MiwgY3AueTIsIGNwLngxLCBjcC55MSwgYVgsIGFZKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjcC54LCBjcC55LCBhWCwgYVkpO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKGFYICsgdlgsIGFZICsgdlkpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlgsIGFZICsgdlkpO1xyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5leHRyZW1pdGllcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlciBmb3IgaG92ZXJlZCBlZGdlIGV4dHJlbWl0aWVzLiBJdCByZW5kZXJzIHRoZSBlZGdlXHJcbiAgICogZXh0cmVtaXRpZXMgYXMgaG92ZXJlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcy5kZWYgPVxyXG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICAvLyBTb3VyY2UgTm9kZTpcclxuICAgIChcclxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVyc1tzb3VyY2UudHlwZV0gfHxcclxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWZcclxuICAgICkgKFxyXG4gICAgICBzb3VyY2UsIGNvbnRleHQsIHNldHRpbmdzXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRhcmdldCBOb2RlOlxyXG4gICAgKFxyXG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzW3RhcmdldC50eXBlXSB8fFxyXG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZlxyXG4gICAgKSAoXHJcbiAgICAgIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3NcclxuICAgICk7XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy51dGlscycpO1xyXG5cclxuICAvKipcclxuICAgKiBTb21lIHVzZWZ1bCBmdW5jdGlvbnMgdXNlZCBieSBzaWdtYSdzIFNWRyByZW5kZXJlci5cclxuICAgKi9cclxuICBzaWdtYS5zdmcudXRpbHMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCBzaG93LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBzaG93LlxyXG4gICAgICovXHJcbiAgICBzaG93OiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCBoaWRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBoaWRlLlxyXG4gICAgICovXHJcbiAgICBoaWRlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5ub2RlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGVmYXVsdCBub2RlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGRpc2MuXHJcbiAgICovXHJcbiAgc2lnbWEuc3ZnLm5vZGVzLmRlZiA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICAgIGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2NpcmNsZScpO1xyXG5cclxuICAgICAgLy8gRGVmaW5pbmcgdGhlIG5vZGUncyBjaXJjbGVcclxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLW5vZGUtaWQnLCBub2RlLmlkKTtcclxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ub2RlJyk7XHJcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcclxuICAgICAgICBudWxsLCAnZmlsbCcsIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSk7XHJcblxyXG4gICAgICAvLyBSZXR1cm5pbmcgdGhlIERPTSBFbGVtZW50XHJcbiAgICAgIHJldHVybiBjaXJjbGU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBjaXJjbGUgICBUaGUgbm9kZSBET00gZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG5vZGUsIGNpcmNsZSwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcclxuXHJcbiAgICAgIC8vIEFwcGx5aW5nIGNoYW5nZXNcclxuICAgICAgLy8gVE9ETzogb3B0aW1pemUgLSBjaGVjayBpZiBuZWNlc3NhcnlcclxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeCcsIG5vZGVbcHJlZml4ICsgJ3gnXSk7XHJcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3knLCBub2RlW3ByZWZpeCArICd5J10pO1xyXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCBub2RlW3ByZWZpeCArICdzaXplJ10pO1xyXG5cclxuICAgICAgLy8gVXBkYXRpbmcgb25seSBpZiBub3QgZnJlZXN0eWxlXHJcbiAgICAgIGlmICghc2V0dGluZ3MoJ2ZyZWVTdHlsZScpKVxyXG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcclxuICAgICAgICAgIG51bGwsICdmaWxsJywgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKTtcclxuXHJcbiAgICAgIC8vIFNob3dpbmdcclxuICAgICAgY2lyY2xlLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBsaW5lLlxyXG4gICAqL1xyXG4gIHNpZ21hLnN2Zy5lZGdlcy5kZWYgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXHJcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXHJcbiAgICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xyXG5cclxuICAgICAgaWYgKCFjb2xvcilcclxuICAgICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdsaW5lJyk7XHJcblxyXG4gICAgICAvLyBBdHRyaWJ1dGVzXHJcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtZWRnZS1pZCcsIGVkZ2UuaWQpO1xyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XHJcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIGNvbG9yKTtcclxuXHJcbiAgICAgIHJldHVybiBsaW5lO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBsaW5lICAgICAgIFRoZSBsaW5lIERPTSBFbGVtZW50LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgbGluZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XHJcblxyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XHJcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gxJywgc291cmNlW3ByZWZpeCArICd4J10pO1xyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MScsIHNvdXJjZVtwcmVmaXggKyAneSddKTtcclxuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneDInLCB0YXJnZXRbcHJlZml4ICsgJ3gnXSk7XHJcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kyJywgdGFyZ2V0W3ByZWZpeCArICd5J10pO1xyXG5cclxuICAgICAgLy8gU2hvd2luZ1xyXG4gICAgICBsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGN1cnZlIGVkZ2UgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGVkZ2UgYXMgYSBiZXppZXIgY3VydmUuXHJcbiAgICovXHJcbiAgc2lnbWEuc3ZnLmVkZ2VzLmN1cnZlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxyXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcclxuXHJcbiAgICAgIGlmICghY29sb3IpXHJcbiAgICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcclxuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAncGF0aCcpO1xyXG5cclxuICAgICAgLy8gQXR0cmlidXRlc1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWVkZ2UtaWQnLCBlZGdlLmlkKTtcclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XHJcblxyXG4gICAgICByZXR1cm4gcGF0aDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgcGF0aCAgICAgICBUaGUgcGF0aCBET00gRWxlbWVudC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVkZ2UsIHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgICAgc1NpemUgPSBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICBjcCxcclxuICAgICAgICAgIHA7XHJcblxyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XHJcblxyXG4gICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhzWCwgc1ksIHNTaXplKTtcclxuICAgICAgICAvLyBQYXRoXHJcbiAgICAgICAgcCA9ICdNJyArIHNYICsgJywnICsgc1kgKyAnICcgK1xyXG4gICAgICAgICAgICAnQycgKyBjcC54MSArICcsJyArIGNwLnkxICsgJyAnICtcclxuICAgICAgICAgICAgY3AueDIgKyAnLCcgKyBjcC55MiArICcgJyArXHJcbiAgICAgICAgICAgIHRYICsgJywnICsgdFk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoc1gsIHNZLCB0WCwgdFksIGVkZ2UuY2MpO1xyXG4gICAgICAgIC8vIFBhdGhcclxuICAgICAgICBwID0gJ00nICsgc1ggKyAnLCcgKyBzWSArICcgJyArXHJcbiAgICAgICAgICAgICdRJyArIGNwLnggKyAnLCcgKyBjcC55ICsgJyAnICtcclxuICAgICAgICAgICAgdFggKyAnLCcgKyB0WTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRpbmcgYXR0cmlidXRlc1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcCk7XHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnbm9uZScpO1xyXG5cclxuICAgICAgLy8gU2hvd2luZ1xyXG4gICAgICBwYXRoLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVE9ETyBhZGQgYXJyb3dcclxuICAgKi9cclxuICBzaWdtYS5zdmcuZWRnZXMuY3VydmVkQXJyb3cgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXHJcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXHJcbiAgICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xyXG5cclxuICAgICAgaWYgKCFjb2xvcilcclxuICAgICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgdmFyIHBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdwYXRoJyk7XHJcblxyXG4gICAgICAvLyBBdHRyaWJ1dGVzXHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtZWRnZS1pZCcsIGVkZ2UuaWQpO1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIGNvbG9yKTtcclxuXHJcbiAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBwYXRoICAgICAgIFRoZSBwYXRoIERPTSBFbGVtZW50LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2UgICAgIFRoZSBzb3VyY2Ugbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgcGF0aCwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgICBzU2l6ZSA9IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgIGNwLFxyXG4gICAgICAgICAgcDtcclxuXHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZS13aWR0aCcsIGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKTtcclxuXHJcbiAgICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xyXG4gICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgc1NpemUpO1xyXG4gICAgICAgIC8vIFBhdGhcclxuICAgICAgICBwID0gJ00nICsgc1ggKyAnLCcgKyBzWSArICcgJyArXHJcbiAgICAgICAgICAgICdDJyArIGNwLngxICsgJywnICsgY3AueTEgKyAnICcgK1xyXG4gICAgICAgICAgICBjcC54MiArICcsJyArIGNwLnkyICsgJyAnICtcclxuICAgICAgICAgICAgdFggKyAnLCcgKyB0WTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSwgZWRnZS5jYyk7XHJcbiAgICAgICAgLy8gUGF0aFxyXG4gICAgICAgIHAgPSAnTScgKyBzWCArICcsJyArIHNZICsgJyAnICtcclxuICAgICAgICAgICAgJ1EnICsgY3AueCArICcsJyArIGNwLnkgKyAnICcgK1xyXG4gICAgICAgICAgICB0WCArICcsJyArIHRZO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGluZyBhdHRyaWJ1dGVzXHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwKTtcclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICdub25lJyk7XHJcblxyXG4gICAgICAvLyBTaG93aW5nXHJcbiAgICAgIHBhdGguc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmxhYmVscycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGVmYXVsdCBsYWJlbCByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbGFiZWwgYXMgYSBzaW1wbGUgdGV4dC5cclxuICAgKi9cclxuICBzaWdtYS5zdmcubGFiZWxzLmRlZiA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgICBUaGUgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3RleHQnKTtcclxuXHJcbiAgICAgIHZhciBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cclxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcclxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XHJcblxyXG4gICAgICB2YXIgZm9udENvbG9yID0gKHNldHRpbmdzKCdsYWJlbENvbG9yJykgPT09ICdub2RlJykgP1xyXG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcclxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcclxuXHJcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbGFiZWwtdGFyZ2V0Jywgbm9kZS5pZCk7XHJcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWxhYmVsJyk7XHJcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcclxuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1mYW1pbHknLCBzZXR0aW5ncygnZm9udCcpKTtcclxuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIGZvbnRDb2xvcik7XHJcblxyXG4gICAgICB0ZXh0LmlubmVySFRNTCA9IG5vZGUubGFiZWw7XHJcbiAgICAgIHRleHQudGV4dENvbnRlbnQgPSBub2RlLmxhYmVsO1xyXG5cclxuICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICB0ZXh0ICAgICBUaGUgbGFiZWwgRE9NIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbihub2RlLCB0ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcclxuXHJcbiAgICAgIHZhciBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cclxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcclxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XHJcblxyXG4gICAgICAvLyBDYXNlIHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IHRoZSBsYWJlbFxyXG4gICAgICBpZiAoIXNldHRpbmdzKCdmb3JjZUxhYmVscycpICYmIHNpemUgPCBzZXR0aW5ncygnbGFiZWxUaHJlc2hvbGQnKSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIFVwZGF0aW5nXHJcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLFxyXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpKTtcclxuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsXHJcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpKTtcclxuXHJcbiAgICAgIC8vIFNob3dpbmdcclxuICAgICAgdGV4dC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuaG92ZXJzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBkZWZhdWx0IGhvdmVyIHJlbmRlcmVyLlxyXG4gICAqL1xyXG4gIHNpZ21hLnN2Zy5ob3ZlcnMuZGVmID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgbm9kZSAgICAgICAgICAgICAgIFRoZSBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge0NhbnZhc0VsZW1lbnR9ICAgIG1lYXN1cmVtZW50Q2FudmFzICBBIGZha2UgY2FudmFzIGhhbmRsZWQgYnlcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdmcgdG8gcGVyZm9ybSBzb21lIG1lYXN1cmVtZW50cyBhbmRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZCBieSB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICBub2RlQ2lyY2xlICAgICAgICAgVGhlIG5vZGUgRE9NIEVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICBzZXR0aW5ncyAgICAgICAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIG5vZGVDaXJjbGUsIG1lYXN1cmVtZW50Q2FudmFzLCBzZXR0aW5ncykge1xyXG5cclxuICAgICAgLy8gRGVmaW5pbmcgdmlzdWFsIHByb3BlcnRpZXNcclxuICAgICAgdmFyIHgsXHJcbiAgICAgICAgICB5LFxyXG4gICAgICAgICAgdyxcclxuICAgICAgICAgIGgsXHJcbiAgICAgICAgICBlLFxyXG4gICAgICAgICAgZCxcclxuICAgICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcclxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cclxuICAgICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XHJcbiAgICAgICAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZSxcclxuICAgICAgICAgIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxIb3ZlckNvbG9yJyk7XHJcblxyXG4gICAgICAvLyBDcmVhdGluZyBlbGVtZW50c1xyXG4gICAgICB2YXIgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdnJyksXHJcbiAgICAgICAgICByZWN0YW5nbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdyZWN0JyksXHJcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKSxcclxuICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICd0ZXh0Jyk7XHJcblxyXG4gICAgICAvLyBEZWZpbmluZyBwcm9wZXJ0aWVzXHJcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3ZlcicpO1xyXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG5vZGUubGFiZWwgPT09ICdzdHJpbmcnKSB7XHJcblxyXG4gICAgICAgIC8vIFRleHRcclxuICAgICAgICB0ZXh0LmlubmVySFRNTCA9IG5vZGUubGFiZWw7XHJcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IG5vZGUubGFiZWw7XHJcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgJ2NsYXNzJyxcclxuICAgICAgICAgICAgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyLWxhYmVsJyk7XHJcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1zaXplJywgZm9udFNpemUpO1xyXG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtZmFtaWx5Jywgc2V0dGluZ3MoJ2ZvbnQnKSk7XHJcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIGZvbnRDb2xvcik7XHJcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsXHJcbiAgICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSk7XHJcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsXHJcbiAgICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMykpO1xyXG5cclxuICAgICAgICAvLyBNZWFzdXJlc1xyXG4gICAgICAgIC8vIE9QVElNSVpFOiBGaW5kIGEgYmV0dGVyIHdheSB0aGFuIGEgbWVhc3VyZW1lbnQgY2FudmFzXHJcbiAgICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddIC0gZm9udFNpemUgLyAyIC0gMik7XHJcbiAgICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XHJcbiAgICAgICAgdyA9IE1hdGgucm91bmQoXHJcbiAgICAgICAgICBtZWFzdXJlbWVudENhbnZhcy5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArXHJcbiAgICAgICAgICAgIGZvbnRTaXplIC8gMiArIHNpemUgKyA5XHJcbiAgICAgICAgKTtcclxuICAgICAgICBoID0gTWF0aC5yb3VuZChmb250U2l6ZSArIDQpO1xyXG4gICAgICAgIGUgPSBNYXRoLnJvdW5kKGZvbnRTaXplIC8gMiArIDIpO1xyXG5cclxuICAgICAgICAvLyBDaXJjbGVcclxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICdjbGFzcycsXHJcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1hcmVhJyk7XHJcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyNmZmYnKTtcclxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4Jywgbm9kZVtwcmVmaXggKyAneCddKTtcclxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5Jywgbm9kZVtwcmVmaXggKyAneSddKTtcclxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCBlKTtcclxuXHJcbiAgICAgICAgLy8gUmVjdGFuZ2xlXHJcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAnY2xhc3MnLFxyXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItYXJlYScpO1xyXG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XHJcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4Jywgbm9kZVtwcmVmaXggKyAneCddICsgZSAvIDQpO1xyXG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsIG5vZGVbcHJlZml4ICsgJ3knXSAtIGUpO1xyXG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB3KTtcclxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBcHBlbmRpbmcgY2hpbGRzXHJcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGNpcmNsZSk7XHJcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHJlY3RhbmdsZSk7XHJcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICBncm91cC5hcHBlbmRDaGlsZChub2RlQ2lyY2xlKTtcclxuXHJcbiAgICAgIHJldHVybiBncm91cDtcclxuICAgIH1cclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taWRkbGV3YXJlcycpO1xyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEudXRpbHMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtaWRkbGV3YXJlIHdpbGwgcmVzY2FsZSB0aGUgZ3JhcGggc3VjaCB0aGF0IGl0IHRha2VzIGFuIG9wdGltYWwgc3BhY2VcclxuICAgKiBvbiB0aGUgcmVuZGVyZXIuXHJcbiAgICpcclxuICAgKiBBcyBlYWNoIG1pZGRsZXdhcmUsIHRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBzaWdtYVxyXG4gICAqIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHs/c3RyaW5nfSByZWFkUHJlZml4ICBUaGUgcmVhZCBwcmVmaXguXHJcbiAgICogQHBhcmFtIHs/c3RyaW5nfSB3cml0ZVByZWZpeCBUaGUgd3JpdGUgcHJlZml4LlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgICAgVGhlIHBhcmFtZXRlcnMuXHJcbiAgICovXHJcbiAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZSA9IGZ1bmN0aW9uKHJlYWRQcmVmaXgsIHdyaXRlUHJlZml4LCBvcHRpb25zKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgYixcclxuICAgICAgICBjLFxyXG4gICAgICAgIGQsXHJcbiAgICAgICAgc2NhbGUsXHJcbiAgICAgICAgbWFyZ2luLFxyXG4gICAgICAgIG4gPSB0aGlzLmdyYXBoLm5vZGVzKCksXHJcbiAgICAgICAgZSA9IHRoaXMuZ3JhcGguZWRnZXMoKSxcclxuICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMgfHwge30pLFxyXG4gICAgICAgIGJvdW5kcyA9IHNldHRpbmdzKCdib3VuZHMnKSB8fCBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxyXG4gICAgICAgICAgdGhpcy5ncmFwaCxcclxuICAgICAgICAgIHJlYWRQcmVmaXgsXHJcbiAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKSxcclxuICAgICAgICBtaW5YID0gYm91bmRzLm1pblgsXHJcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxyXG4gICAgICAgIG1heFggPSBib3VuZHMubWF4WCxcclxuICAgICAgICBtYXhZID0gYm91bmRzLm1heFksXHJcbiAgICAgICAgc2l6ZU1heCA9IGJvdW5kcy5zaXplTWF4LFxyXG4gICAgICAgIHdlaWdodE1heCA9IGJvdW5kcy53ZWlnaHRNYXgsXHJcbiAgICAgICAgdyA9IHNldHRpbmdzKCd3aWR0aCcpIHx8IDEsXHJcbiAgICAgICAgaCA9IHNldHRpbmdzKCdoZWlnaHQnKSB8fCAxLFxyXG4gICAgICAgIHJlc2NhbGVTZXR0aW5ncyA9IHNldHRpbmdzKCdhdXRvUmVzY2FsZScpLFxyXG4gICAgICAgIHZhbGlkU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICBub2RlUG9zaXRpb246IDEsXHJcbiAgICAgICAgICBub2RlU2l6ZTogMSxcclxuICAgICAgICAgIGVkZ2VTaXplOiAxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoYXQgZWxlbWVudHMgc2hvdWxkIHdlIHJlc2NhbGU/XHJcbiAgICAgKi9cclxuICAgIGlmICghKHJlc2NhbGVTZXR0aW5ncyBpbnN0YW5jZW9mIEFycmF5KSlcclxuICAgICAgcmVzY2FsZVNldHRpbmdzID0gWydub2RlUG9zaXRpb24nLCAnbm9kZVNpemUnLCAnZWRnZVNpemUnXTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsID0gcmVzY2FsZVNldHRpbmdzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgaWYgKCF2YWxpZFNldHRpbmdzW3Jlc2NhbGVTZXR0aW5nc1tpXV0pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgJ1RoZSByZXNjYWxlIHNldHRpbmcgXCInICsgcmVzY2FsZVNldHRpbmdzW2ldICsgJ1wiIGlzIG5vdCByZWNvZ25pemVkLidcclxuICAgICAgICApO1xyXG5cclxuICAgIHZhciBucCA9IH5yZXNjYWxlU2V0dGluZ3MuaW5kZXhPZignbm9kZVBvc2l0aW9uJyksXHJcbiAgICAgICAgbnMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVTaXplJyksXHJcbiAgICAgICAgZXMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ2VkZ2VTaXplJyk7XHJcblxyXG4gICAgaWYgKG5wKSB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaXJzdCwgd2UgY29tcHV0ZSB0aGUgc2NhbGluZyByYXRpbywgd2l0aG91dCBjb25zaWRlcmluZyB0aGUgc2l6ZXNcclxuICAgICAgICogb2YgdGhlIG5vZGVzIDogRWFjaCBub2RlIHdpbGwgaGF2ZSBpdHMgY2VudGVyIGluIHRoZSBjYW52YXMsIGJ1dCBtaWdodFxyXG4gICAgICAgKiBiZSBwYXJ0aWFsbHkgb3V0IG9mIGl0LlxyXG4gICAgICAgKi9cclxuICAgICAgc2NhbGUgPSBzZXR0aW5ncygnc2NhbGluZ01vZGUnKSA9PT0gJ291dHNpZGUnID9cclxuICAgICAgICBNYXRoLm1heChcclxuICAgICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXHJcbiAgICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXHJcbiAgICAgICAgKSA6XHJcbiAgICAgICAgTWF0aC5taW4oXHJcbiAgICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxyXG4gICAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogVGhlbiwgd2UgY29ycmVjdCB0aGF0IHNjYWxpbmcgcmF0aW8gY29uc2lkZXJpbmcgYSBtYXJnaW4sIHdoaWNoIGlzXHJcbiAgICAgICAqIGJhc2ljYWxseSB0aGUgc2l6ZSBvZiB0aGUgYmlnZ2VzdCBub2RlLlxyXG4gICAgICAgKiBUaGlzIGhhcyB0byBiZSBkb25lIGFzIGEgY29ycmVjdGlvbiBzaW5jZSB0byBjb21wYXJlIHRoZSBzaXplIG9mIHRoZVxyXG4gICAgICAgKiBiaWdnZXN0IG5vZGUgdG8gdGhlIFggYW5kIFkgdmFsdWVzLCB3ZSBoYXZlIHRvIGZpcnN0IGdldCBhblxyXG4gICAgICAgKiBhcHByb3hpbWF0aW9uIG9mIHRoZSBzY2FsaW5nIHJhdGlvLlxyXG4gICAgICAgKiovXHJcbiAgICAgIG1hcmdpbiA9XHJcbiAgICAgICAgKFxyXG4gICAgICAgICAgc2V0dGluZ3MoJ3Jlc2NhbGVJZ25vcmVTaXplJykgP1xyXG4gICAgICAgICAgICAwIDpcclxuICAgICAgICAgICAgKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpIHx8IHNpemVNYXgpIC8gc2NhbGVcclxuICAgICAgICApICtcclxuICAgICAgICAoc2V0dGluZ3MoJ3NpZGVNYXJnaW4nKSB8fCAwKTtcclxuICAgICAgbWF4WCArPSBtYXJnaW47XHJcbiAgICAgIG1pblggLT0gbWFyZ2luO1xyXG4gICAgICBtYXhZICs9IG1hcmdpbjtcclxuICAgICAgbWluWSAtPSBtYXJnaW47XHJcblxyXG4gICAgICAvLyBGaXggdGhlIHNjYWxpbmcgd2l0aCB0aGUgbmV3IGV4dHJlbWE6XHJcbiAgICAgIHNjYWxlID0gc2V0dGluZ3MoJ3NjYWxpbmdNb2RlJykgPT09ICdvdXRzaWRlJyA/XHJcbiAgICAgICAgTWF0aC5tYXgoXHJcbiAgICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxyXG4gICAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxyXG4gICAgICAgICkgOlxyXG4gICAgICAgIE1hdGgubWluKFxyXG4gICAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcclxuICAgICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpemUgaG9tb3RoZXRpYyBwYXJhbWV0ZXJzOlxyXG4gICAgaWYgKCFzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSAmJiAhc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIHtcclxuICAgICAgYSA9IDE7XHJcbiAgICAgIGIgPSAwO1xyXG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSA9PT0gc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIHtcclxuICAgICAgYSA9IDA7XHJcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21heE5vZGVTaXplJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhID0gKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIC8gc2l6ZU1heDtcclxuICAgICAgYiA9ICtzZXR0aW5ncygnbWluTm9kZVNpemUnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNldHRpbmdzKCdtYXhFZGdlU2l6ZScpICYmICFzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xyXG4gICAgICBjID0gMTtcclxuICAgICAgZCA9IDA7XHJcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpID09PSBzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xyXG4gICAgICBjID0gMDtcclxuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGMgPSAoc2V0dGluZ3MoJ21heEVkZ2VTaXplJykgLSBzZXR0aW5ncygnbWluRWRnZVNpemUnKSkgLyB3ZWlnaHRNYXg7XHJcbiAgICAgIGQgPSArc2V0dGluZ3MoJ21pbkVkZ2VTaXplJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzY2FsZSB0aGUgbm9kZXMgYW5kIGVkZ2VzOlxyXG4gICAgZm9yIChpID0gMCwgbCA9IGUubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICBlW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9XHJcbiAgICAgICAgZVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXSAqIChlcyA/IGMgOiAxKSArIChlcyA/IGQgOiAwKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsID0gbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgbltpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxyXG4gICAgICAgIG5baV1bcmVhZFByZWZpeCArICdzaXplJ10gKiAobnMgPyBhIDogMSkgKyAobnMgPyBiIDogMCk7XHJcblxyXG4gICAgICBpZiAobnApIHtcclxuICAgICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3gnXSA9XHJcbiAgICAgICAgICAobltpXVtyZWFkUHJlZml4ICsgJ3gnXSAtIChtYXhYICsgbWluWCkgLyAyKSAqIHNjYWxlO1xyXG4gICAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAneSddID1cclxuICAgICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneSddIC0gKG1heFkgKyBtaW5ZKSAvIDIpICogc2NhbGU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbltpXVt3cml0ZVByZWZpeCArICd4J10gPSBuW2ldW3JlYWRQcmVmaXggKyAneCddO1xyXG4gICAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAneSddID0gbltpXVtyZWFkUHJlZml4ICsgJ3knXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMgPSBmdW5jdGlvbihncmFwaCwgcHJlZml4LCBkb0VkZ2VzKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGUgPSBncmFwaC5lZGdlcygpLFxyXG4gICAgICAgIG4gPSBncmFwaC5ub2RlcygpLFxyXG4gICAgICAgIHdlaWdodE1heCA9IC1JbmZpbml0eSxcclxuICAgICAgICBzaXplTWF4ID0gLUluZmluaXR5LFxyXG4gICAgICAgIG1pblggPSBJbmZpbml0eSxcclxuICAgICAgICBtaW5ZID0gSW5maW5pdHksXHJcbiAgICAgICAgbWF4WCA9IC1JbmZpbml0eSxcclxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xyXG5cclxuICAgIGlmIChkb0VkZ2VzKVxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgd2VpZ2h0TWF4ID0gTWF0aC5tYXgoZVtpXVtwcmVmaXggKyAnc2l6ZSddLCB3ZWlnaHRNYXgpO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBzaXplTWF4ID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAnc2l6ZSddLCBzaXplTWF4KTtcclxuICAgICAgbWF4WCA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3gnXSwgbWF4WCk7XHJcbiAgICAgIG1pblggPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd4J10sIG1pblgpO1xyXG4gICAgICBtYXhZID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneSddLCBtYXhZKTtcclxuICAgICAgbWluWSA9IE1hdGgubWluKG5baV1bcHJlZml4ICsgJ3knXSwgbWluWSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2VpZ2h0TWF4ID0gd2VpZ2h0TWF4IHx8IDE7XHJcbiAgICBzaXplTWF4ID0gc2l6ZU1heCB8fCAxO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdlaWdodE1heDogd2VpZ2h0TWF4LFxyXG4gICAgICBzaXplTWF4OiBzaXplTWF4LFxyXG4gICAgICBtaW5YOiBtaW5YLFxyXG4gICAgICBtaW5ZOiBtaW5ZLFxyXG4gICAgICBtYXhYOiBtYXhYLFxyXG4gICAgICBtYXhZOiBtYXhZXHJcbiAgICB9O1xyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pZGRsZXdhcmVzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWlkZGxld2FyZSB3aWxsIGp1c3QgY29weSB0aGUgZ3JhcGhpYyBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHs/c3RyaW5nfSByZWFkUHJlZml4ICBUaGUgcmVhZCBwcmVmaXguXHJcbiAgICogQHBhcmFtIHs/c3RyaW5nfSB3cml0ZVByZWZpeCBUaGUgd3JpdGUgcHJlZml4LlxyXG4gICAqL1xyXG4gIHNpZ21hLm1pZGRsZXdhcmVzLmNvcHkgPSBmdW5jdGlvbihyZWFkUHJlZml4LCB3cml0ZVByZWZpeCkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBhO1xyXG5cclxuICAgIGlmICh3cml0ZVByZWZpeCArICcnID09PSByZWFkUHJlZml4ICsgJycpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBhID0gdGhpcy5ncmFwaC5ub2RlcygpO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGFbaV1bd3JpdGVQcmVmaXggKyAneCddID0gYVtpXVtyZWFkUHJlZml4ICsgJ3gnXTtcclxuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd5J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneSddO1xyXG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9IGFbaV1bcmVhZFByZWZpeCArICdzaXplJ107XHJcbiAgICB9XHJcblxyXG4gICAgYSA9IHRoaXMuZ3JhcGguZWRnZXMoKTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmcnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElEIGZvciB0aGUgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBuZXcgSUQuXHJcbiAgICovXHJcbiAgdmFyIF9nZXRJRCA9IChmdW5jdGlvbigpIHtcclxuICAgIHZhciBpZCA9IDA7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAnJyArICgrK2lkKTtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBhbmltYXRlcyBhIGNhbWVyYS4gSXQgaGFzIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjYW1lcmEgdG9cclxuICAgKiBhbmltYXRlLCB0aGUgdmFsdWVzIG9mIHRoZSBjb29yZGluYXRlcyB0byByZWFjaCBhbmQgZXZlbnR1YWxseSBzb21lXHJcbiAgICogb3B0aW9ucy4gSXQgcmV0dXJucyBhIG51bWJlciBpZCwgdGhhdCB5b3UgY2FuIHVzZSB0byBraWxsIHRoZSBhbmltYXRpb24sXHJcbiAgICogd2l0aCB0aGUgbWV0aG9kIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGwoaWQpLlxyXG4gICAqXHJcbiAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcclxuICAgKlxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uTmV3RnJhbWUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRlciBhIG5ldyBmcmFtZS5cclxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBjb21wbGV0ZWQgb3Iga2lsbGVkLlxyXG4gICAqICAgez8oc3RyaW5nfGZ1bmN0aW9uKX0gZWFzaW5nICAgICBUaGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGZyb20gdGhlIHBhY2thZ2VcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncywgb3IgYSBjdXN0b20gZWFzaW5nXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgY2FtZXJhICBUaGUgY2FtZXJhIHRvIGFuaW1hdGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgdGFyZ2V0ICBUaGUgY29vcmRpbmF0ZXMgdG8gcmVhY2guXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCB0byBzcGVjaWZ5IHNvbWUgb3B0aW9ucyB0b1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZ1bmN0aW9uLiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50ZWQgaW4gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgIFRoZSBhbmltYXRpb24gaWQsIHRvIG1ha2UgaXQgZWFzeSB0byBraWxsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdWdoIHRoZSBtZXRob2QgXCJzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsXCIuXHJcbiAgICovXHJcbiAgc2lnbWEubWlzYy5hbmltYXRpb24uY2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhLCB2YWwsIG9wdGlvbnMpIHtcclxuICAgIGlmIChcclxuICAgICAgIShjYW1lcmEgaW5zdGFuY2VvZiBzaWdtYS5jbGFzc2VzLmNhbWVyYSkgfHxcclxuICAgICAgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgIXZhbFxyXG4gICAgKVxyXG4gICAgICB0aHJvdyAnYW5pbWF0aW9uLmNhbWVyYTogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgdmFsLnggIT09ICdudW1iZXInICYmXHJcbiAgICAgIHR5cGVvZiB2YWwueSAhPT0gJ251bWJlcicgJiZcclxuICAgICAgdHlwZW9mIHZhbC5yYXRpbyAhPT0gJ251bWJlcicgJiZcclxuICAgICAgdHlwZW9mIHZhbC5hbmdsZSAhPT0gJ251bWJlcidcclxuICAgIClcclxuICAgICAgdGhyb3cgJ1RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIHZhbGlkIGNvb3JkaW5hdGUgaW4gdGhlIGdpdmVuIHZhbC4nO1xyXG5cclxuICAgIHZhciBmbixcclxuICAgICAgICBpZCxcclxuICAgICAgICBhbmltLFxyXG4gICAgICAgIGVhc2luZyxcclxuICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICBpbml0aWFsVmFsLFxyXG4gICAgICAgIG8gPSBvcHRpb25zIHx8IHt9LFxyXG4gICAgICAgIHN0YXJ0ID0gc2lnbWEudXRpbHMuZGF0ZU5vdygpO1xyXG5cclxuICAgIC8vIFN0b3JlIGluaXRpYWwgdmFsdWVzOlxyXG4gICAgaW5pdGlhbFZhbCA9IHtcclxuICAgICAgeDogY2FtZXJhLngsXHJcbiAgICAgIHk6IGNhbWVyYS55LFxyXG4gICAgICByYXRpbzogY2FtZXJhLnJhdGlvLFxyXG4gICAgICBhbmdsZTogY2FtZXJhLmFuZ2xlXHJcbiAgICB9O1xyXG5cclxuICAgIGR1cmF0aW9uID0gby5kdXJhdGlvbjtcclxuICAgIGVhc2luZyA9IHR5cGVvZiBvLmVhc2luZyAhPT0gJ2Z1bmN0aW9uJyA/XHJcbiAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3Nbby5lYXNpbmcgfHwgJ3F1YWRyYXRpY0luT3V0J10gOlxyXG4gICAgICBvLmVhc2luZztcclxuXHJcbiAgICBmbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgY29lZixcclxuICAgICAgICAgIHQgPSBvLmR1cmF0aW9uID8gKHNpZ21hLnV0aWxzLmRhdGVOb3coKSAtIHN0YXJ0KSAvIG8uZHVyYXRpb24gOiAxO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGFuaW1hdGlvbiBpcyBvdmVyOlxyXG4gICAgICBpZiAodCA+PSAxKSB7XHJcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSBmYWxzZTtcclxuICAgICAgICBjYW1lcmEuZ29Ubyh7XHJcbiAgICAgICAgICB4OiB2YWwueCAhPT0gdW5kZWZpbmVkID8gdmFsLnggOiBpbml0aWFsVmFsLngsXHJcbiAgICAgICAgICB5OiB2YWwueSAhPT0gdW5kZWZpbmVkID8gdmFsLnkgOiBpbml0aWFsVmFsLnksXHJcbiAgICAgICAgICByYXRpbzogdmFsLnJhdGlvICE9PSB1bmRlZmluZWQgPyB2YWwucmF0aW8gOiBpbml0aWFsVmFsLnJhdGlvLFxyXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID8gdmFsLmFuZ2xlIDogaW5pdGlhbFZhbC5hbmdsZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XHJcbiAgICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICBvLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICAgIC8vIEVsc2UsIGxldCdzIGtlZXAgZ29pbmc6XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29lZiA9IGVhc2luZyh0KTtcclxuICAgICAgICBjYW1lcmEuaXNBbmltYXRlZCA9IHRydWU7XHJcbiAgICAgICAgY2FtZXJhLmdvVG8oe1xyXG4gICAgICAgICAgeDogdmFsLnggIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgIGluaXRpYWxWYWwueCArICh2YWwueCAtIGluaXRpYWxWYWwueCkgKiBjb2VmIDpcclxuICAgICAgICAgICAgaW5pdGlhbFZhbC54LFxyXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgIGluaXRpYWxWYWwueSArICh2YWwueSAtIGluaXRpYWxWYWwueSkgKiBjb2VmIDpcclxuICAgICAgICAgICAgaW5pdGlhbFZhbC55LFxyXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgaW5pdGlhbFZhbC5yYXRpbyArICh2YWwucmF0aW8gLSBpbml0aWFsVmFsLnJhdGlvKSAqIGNvZWYgOlxyXG4gICAgICAgICAgICBpbml0aWFsVmFsLnJhdGlvLFxyXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgaW5pdGlhbFZhbC5hbmdsZSArICh2YWwuYW5nbGUgLSBpbml0aWFsVmFsLmFuZ2xlKSAqIGNvZWYgOlxyXG4gICAgICAgICAgICBpbml0aWFsVmFsLmFuZ2xlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcclxuICAgICAgICBpZiAodHlwZW9mIG8ub25OZXdGcmFtZSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgIG8ub25OZXdGcmFtZSgpO1xyXG5cclxuICAgICAgICBhbmltLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlkID0gX2dldElEKCk7XHJcbiAgICBhbmltID0ge1xyXG4gICAgICBmcmFtZUlkOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pLFxyXG4gICAgICB0YXJnZXQ6IGNhbWVyYSxcclxuICAgICAgdHlwZTogJ2NhbWVyYScsXHJcbiAgICAgIG9wdGlvbnM6IG8sXHJcbiAgICAgIGZuOiBmblxyXG4gICAgfTtcclxuICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdID0gYW5pbTtcclxuXHJcbiAgICByZXR1cm4gaWQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogS2lsbHMgYSBydW5uaW5nIGFuaW1hdGlvbi4gSXQgdHJpZ2dlcnMgdGhlIGV2ZW50dWFsIG9uQ29tcGxldGUgY2FsbGJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkICBUaGUgaWQgb2YgdGhlIGFuaW1hdGlvbiB0byBraWxsLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFJldHVybnMgdGhlIHNpZ21hLm1pc2MuYW5pbWF0aW9uIHBhY2thZ2UuXHJcbiAgICovXHJcbiAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgaWQgIT09ICdudW1iZXInKVxyXG4gICAgICB0aHJvdyAnYW5pbWF0aW9uLmtpbGw6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIHZhciBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XHJcblxyXG4gICAgaWYgKG8pIHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xyXG4gICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tvLmZyYW1lSWRdO1xyXG5cclxuICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXHJcbiAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxyXG4gICAgICBpZiAodHlwZW9mIChvLm9wdGlvbnMgfHwge30pLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgby5vcHRpb25zLm9uQ29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nIGFuaW1hdGlvbnMsIG9yIG9ubHkgdGhlIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZSxcclxuICAgKiBpZiBhIHN0cmluZyBwYXJhbWV0ZXIgaXMgZ2l2ZW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xvYmplY3QpfSBmaWx0ZXIgQSBzdHJpbmcgdG8gZmlsdGVyIHRoZSBhbmltYXRpb25zIHRvIGtpbGxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB0byBmaWx0ZXIgb24gdGhlaXIgdGFyZ2V0LlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYW5pbWF0aW9ucyBraWxsZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB3YXkuXHJcbiAgICovXHJcbiAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbCA9IGZ1bmN0aW9uKGZpbHRlcikge1xyXG4gICAgdmFyIG8sXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgY291bnQgPSAwLFxyXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0ID0gdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyBmaWx0ZXIgOiBudWxsLFxyXG4gICAgICAgIHJ1bm5pbmcgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nO1xyXG5cclxuICAgIGZvciAoaWQgaW4gcnVubmluZylcclxuICAgICAgaWYgKFxyXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxyXG4gICAgICAgICghdGFyZ2V0IHx8IHJ1bm5pbmdbaWRdLnRhcmdldCA9PT0gdGFyZ2V0KVxyXG4gICAgICApIHtcclxuICAgICAgICBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoby5mcmFtZUlkKTtcclxuICAgICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XHJcblxyXG4gICAgICAgIGlmIChvLnR5cGUgPT09ICdjYW1lcmEnKVxyXG4gICAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBJbmNyZW1lbnQgY291bnRlcjpcclxuICAgICAgICBjb3VudCsrO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgby5vcHRpb25zLm9uQ29tcGxldGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgIHJldHVybiBjb3VudDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBhbmltYXRpb24gdGhhdCBpcyBjdXJyZW50bHkgc3RpbGwgcnVubmluZyBtYXRjaGVzXHJcbiAgICogdGhlIGZpbHRlciBnaXZlbiB0byB0aGUgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSBmaWx0ZXIgQSBzdHJpbmcgdG8gZmlsdGVyIHRoZSBhbmltYXRpb25zIHRvIGtpbGxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB0byBmaWx0ZXIgb24gdGhlaXIgdGFyZ2V0LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgICAgICBSZXR1cm5zIHRydWUgaWYgYW55IHJ1bm5pbmcgYW5pbWF0aW9uXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuXHJcbiAgICovXHJcbiAgc2lnbWEubWlzYy5hbmltYXRpb24uaGFzID0gZnVuY3Rpb24oZmlsdGVyKSB7XHJcbiAgICB2YXIgaWQsXHJcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnID8gZmlsdGVyIDogbnVsbCxcclxuICAgICAgICB0YXJnZXQgPSB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IGZpbHRlciA6IG51bGwsXHJcbiAgICAgICAgcnVubmluZyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmc7XHJcblxyXG4gICAgZm9yIChpZCBpbiBydW5uaW5nKVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKCF0eXBlIHx8IHJ1bm5pbmdbaWRdLnR5cGUgPT09IHR5cGUpICYmXHJcbiAgICAgICAgKCF0YXJnZXQgfHwgcnVubmluZ1tpZF0udGFyZ2V0ID09PSB0YXJnZXQpXHJcbiAgICAgIClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGhlbHBlciB3aWxsIGJpbmQgYW55IG5vLURPTSByZW5kZXJlciAoZm9yIGluc3RhbmNlIGNhbnZhcyBvciBXZWJHTClcclxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxyXG4gICAqIHRvIG1hbmFnZSBjbGlja2luZywgaG92ZXJpbmcgZXRjLi4uXHJcbiAgICpcclxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cclxuICAgKi9cclxuICBzaWdtYS5taXNjLmJpbmRFdmVudHMgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgbVgsXHJcbiAgICAgICAgbVksXHJcbiAgICAgICAgY2FwdG9yLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldE5vZGVzKGUpIHtcclxuICAgICAgaWYgKGUpIHtcclxuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xyXG4gICAgICAgIG1ZID0gJ3knIGluIGUuZGF0YSA/IGUuZGF0YS55IDogbVk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpLFxyXG4gICAgICAgICAgaixcclxuICAgICAgICAgIGwsXHJcbiAgICAgICAgICBuLFxyXG4gICAgICAgICAgeCxcclxuICAgICAgICAgIHksXHJcbiAgICAgICAgICBzLFxyXG4gICAgICAgICAgaW5zZXJ0ZWQsXHJcbiAgICAgICAgICBzZWxlY3RlZCA9IFtdLFxyXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcclxuICAgICAgICAgIG1vZGlmaWVkWSA9IG1ZICsgc2VsZi5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgcG9pbnQgPSBzZWxmLmNhbWVyYS5jYW1lcmFQb3NpdGlvbihcclxuICAgICAgICAgICAgbVgsXHJcbiAgICAgICAgICAgIG1ZXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgbm9kZXMgPSBzZWxmLmNhbWVyYS5xdWFkdHJlZS5wb2ludChcclxuICAgICAgICAgICAgcG9pbnQueCxcclxuICAgICAgICAgICAgcG9pbnQueVxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChub2Rlcy5sZW5ndGgpXHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgeCA9IG5bcHJlZml4ICsgJ3gnXTtcclxuICAgICAgICAgIHkgPSBuW3ByZWZpeCArICd5J107XHJcbiAgICAgICAgICBzID0gbltwcmVmaXggKyAnc2l6ZSddO1xyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgIW4uaGlkZGVuICYmXHJcbiAgICAgICAgICAgIG1vZGlmaWVkWCA+IHggLSBzICYmXHJcbiAgICAgICAgICAgIG1vZGlmaWVkWCA8IHggKyBzICYmXHJcbiAgICAgICAgICAgIG1vZGlmaWVkWSA+IHkgLSBzICYmXHJcbiAgICAgICAgICAgIG1vZGlmaWVkWSA8IHkgKyBzICYmXHJcbiAgICAgICAgICAgIE1hdGguc3FydChcclxuICAgICAgICAgICAgICAobW9kaWZpZWRYIC0geCkgKiAobW9kaWZpZWRYIC0geCkgK1xyXG4gICAgICAgICAgICAgIChtb2RpZmllZFkgLSB5KSAqIChtb2RpZmllZFkgLSB5KVxyXG4gICAgICAgICAgICApIDwgc1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZTpcclxuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzZWxlY3RlZC5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICBpZiAobi5zaXplID4gc2VsZWN0ZWRbal0uc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGosIDAsIG4pO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFpbnNlcnRlZClcclxuICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKG4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RWRnZXMoZSkge1xyXG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpKSB7XHJcbiAgICAgICAgLy8gTm8gZXZlbnQgaWYgdGhlIHNldHRpbmcgaXMgb2ZmOlxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGlzQ2FudmFzID0gKFxyXG4gICAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgJiYgc2VsZiBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy5jYW52YXMpO1xyXG5cclxuICAgICAgaWYgKCFpc0NhbnZhcykge1xyXG4gICAgICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIGZlYXR1cmVcclxuICAgICAgICAvLyB3aXRoIHRoZSBXZWJHTCByZW5kZXJlciAod2hpY2ggaXMgbm90IGdvb2QgZW5vdWdoIGF0IHRoZSBtb21lbnQpOlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICdUaGUgZWRnZSBldmVudHMgZmVhdHVyZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBXZWJHTCByZW5kZXJlcidcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZSkge1xyXG4gICAgICAgIG1YID0gJ3gnIGluIGUuZGF0YSA/IGUuZGF0YS54IDogbVg7XHJcbiAgICAgICAgbVkgPSAneScgaW4gZS5kYXRhID8gZS5kYXRhLnkgOiBtWTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgICBqLFxyXG4gICAgICAgICAgbCxcclxuICAgICAgICAgIGEsXHJcbiAgICAgICAgICBlZGdlLFxyXG4gICAgICAgICAgcyxcclxuICAgICAgICAgIG1heEVwc2lsb24gPSBzZWxmLnNldHRpbmdzKCdlZGdlSG92ZXJQcmVjaXNpb24nKSxcclxuICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgIGNwLFxyXG4gICAgICAgICAgbm9kZUluZGV4ID0ge30sXHJcbiAgICAgICAgICBpbnNlcnRlZCxcclxuICAgICAgICAgIHNlbGVjdGVkID0gW10sXHJcbiAgICAgICAgICBtb2RpZmllZFggPSBtWCArIHNlbGYud2lkdGggLyAyLFxyXG4gICAgICAgICAgbW9kaWZpZWRZID0gbVkgKyBzZWxmLmhlaWdodCAvIDIsXHJcbiAgICAgICAgICBwb2ludCA9IHNlbGYuY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxyXG4gICAgICAgICAgICBtWCxcclxuICAgICAgICAgICAgbVlcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICBlZGdlcyA9IFtdO1xyXG5cclxuICAgICAgaWYgKGlzQ2FudmFzKSB7XHJcbiAgICAgICAgdmFyIG5vZGVzT25TY3JlZW4gPSBzZWxmLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxyXG4gICAgICAgICAgc2VsZi5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0KVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZm9yIChhID0gbm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgIG5vZGVJbmRleFthW2ldLmlkXSA9IGFbaV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWxmLmNhbWVyYS5lZGdlcXVhZHRyZWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGVkZ2VzID0gc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlLnBvaW50KFxyXG4gICAgICAgICAgcG9pbnQueCxcclxuICAgICAgICAgIHBvaW50LnlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKSB7XHJcbiAgICAgICAgaW5zZXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlbGVjdGVkLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgaWYgKGVkZ2Uuc2l6ZSA+IHNlbGVjdGVkW2pdLnNpemUpIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGosIDAsIGVkZ2UpO1xyXG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWluc2VydGVkKVxyXG4gICAgICAgICAgc2VsZWN0ZWQucHVzaChlZGdlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVkZ2VzLmxlbmd0aClcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICBlZGdlID0gZWRnZXNbaV07XHJcbiAgICAgICAgICBzb3VyY2UgPSBzZWxmLmdyYXBoLm5vZGVzKGVkZ2Uuc291cmNlKTtcclxuICAgICAgICAgIHRhcmdldCA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpO1xyXG4gICAgICAgICAgLy8gKEhBQ0spIHdlIGNhbid0IGdldCBlZGdlW3ByZWZpeCArICdzaXplJ10gb24gV2ViR0wgcmVuZGVyZXI6XHJcbiAgICAgICAgICBzID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8XHJcbiAgICAgICAgICAgICAgZWRnZVsncmVhZF8nICsgcHJlZml4ICsgJ3NpemUnXTtcclxuXHJcbiAgICAgICAgICAvLyBGaXJzdCwgbGV0J3MgaWRlbnRpZnkgd2hpY2ggZWRnZXMgYXJlIGRyYXduLiBUbyBkbyB0aGlzLCB3ZSBrZWVwXHJcbiAgICAgICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXHJcbiAgICAgICAgICAvLyB0aGUgcXVhZHRyZWUgYW5kIHRoZSBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW5cclxuICAgICAgICAgIC8vIGVkZ2VzLlxyXG4gICAgICAgICAgLy8gVGhlbiwgbGV0J3MgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIG9uIHRoZSBlZGdlICh3ZSBzdXBwb3NlIHRoYXQgaXRcclxuICAgICAgICAgIC8vIGlzIGEgbGluZSBzZWdtZW50KS5cclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICFlZGdlLmhpZGRlbiAmJlxyXG4gICAgICAgICAgICAhc291cmNlLmhpZGRlbiAmJiAhdGFyZ2V0LmhpZGRlbiAmJlxyXG4gICAgICAgICAgICAoIWlzQ2FudmFzIHx8XHJcbiAgICAgICAgICAgICAgKG5vZGVJbmRleFtlZGdlLnNvdXJjZV0gfHwgbm9kZUluZGV4W2VkZ2UudGFyZ2V0XSkpICYmXHJcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKFxyXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgIG1vZGlmaWVkWCxcclxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gc291cmNlW3ByZWZpeCArICdzaXplJ10gJiZcclxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoXHJcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgbW9kaWZpZWRYLFxyXG4gICAgICAgICAgICAgIG1vZGlmaWVkWSkgPiB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmIChlZGdlLnR5cGUgPT0gJ2N1cnZlJyB8fCBlZGdlLnR5cGUgPT0gJ2N1cnZlZEFycm93Jykge1xyXG4gICAgICAgICAgICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xyXG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICdzaXplJ11cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlKFxyXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFgsXHJcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcclxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgICAgIGNwLngxLFxyXG4gICAgICAgICAgICAgICAgICBjcC55MSxcclxuICAgICAgICAgICAgICAgICAgY3AueDIsXHJcbiAgICAgICAgICAgICAgICAgIGNwLnkyLFxyXG4gICAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChcclxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgICAgIGVkZ2UuY2MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5pc1BvaW50T25RdWFkcmF0aWNDdXJ2ZShcclxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxyXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFksXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgICAgICBjcC54LFxyXG4gICAgICAgICAgICAgICAgICBjcC55LFxyXG4gICAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5pc1BvaW50T25TZWdtZW50KFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxyXG4gICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxyXG4gICAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYmluZENhcHRvcihjYXB0b3IpIHtcclxuICAgICAgdmFyIG5vZGVzLFxyXG4gICAgICAgICAgZWRnZXMsXHJcbiAgICAgICAgICBvdmVyTm9kZXMgPSB7fSxcclxuICAgICAgICAgIG92ZXJFZGdlcyA9IHt9O1xyXG5cclxuICAgICAgZnVuY3Rpb24gb25DbGljayhlKSB7XHJcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBlLmRhdGEpO1xyXG5cclxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xyXG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XHJcblxyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xyXG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGVzJywge1xyXG4gICAgICAgICAgICBub2RlOiBub2RlcyxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZScsIHtcclxuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tFZGdlcycsIHtcclxuICAgICAgICAgICAgZWRnZTogZWRnZXMsXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrKGUpIHtcclxuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGljaycsIGUuZGF0YSk7XHJcblxyXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XHJcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGUnLCB7XHJcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzWzBdLFxyXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrTm9kZXMnLCB7XHJcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxyXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tFZGdlJywge1xyXG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja0VkZ2VzJywge1xyXG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIG9uUmlnaHRDbGljayhlKSB7XHJcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGljaycsIGUuZGF0YSk7XHJcblxyXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XHJcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrTm9kZScsIHtcclxuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGVzJywge1xyXG4gICAgICAgICAgICBub2RlOiBub2RlcyxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tFZGdlJywge1xyXG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZXMnLCB7XHJcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxyXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBvbk91dChlKSB7XHJcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBrLFxyXG4gICAgICAgICAgICBldmVudCA9IHtcclxuICAgICAgICAgICAgICBjdXJyZW50OiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdLCB9LFxyXG4gICAgICAgICAgICAgIGVudGVyOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdLCB9LFxyXG4gICAgICAgICAgICAgIGxlYXZlOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdLCB9LFxyXG4gICAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxlYXZlID0gZXZlbnQubGVhdmU7XHJcblxyXG4gICAgICAgIGZvciAoayBpbiBvdmVyTm9kZXMpXHJcbiAgICAgICAgICBsZWF2ZS5ub2Rlcy5wdXNoKG92ZXJOb2Rlc1trXSk7XHJcblxyXG4gICAgICAgIGZvciAoayBpbiBvdmVyRWRnZXMpXHJcbiAgICAgICAgICBsZWF2ZS5lZGdlcy5wdXNoKG92ZXJFZGdlc1trXSk7XHJcblxyXG4gICAgICAgIG92ZXJOb2RlcyA9IHt9O1xyXG4gICAgICAgIG92ZXJFZGdlcyA9IHt9O1xyXG5cclxuICAgICAgICBpZiAobGVhdmUubm9kZXMubGVuZ3RoIHx8IGxlYXZlLmVkZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdob3ZlcnMnLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBvbk1vdmUoZSkge1xyXG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xyXG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XHJcblxyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBrLFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBlZGdlLFxyXG4gICAgICAgICAgICBuZXdPdXROb2RlcyA9IFtdLFxyXG4gICAgICAgICAgICBuZXdPdmVyTm9kZXMgPSBbXSxcclxuICAgICAgICAgICAgY3VycmVudE92ZXJOb2RlcyA9IHt9LFxyXG4gICAgICAgICAgICBuZXdPdXRFZGdlcyA9IFtdLFxyXG4gICAgICAgICAgICBuZXdPdmVyRWRnZXMgPSBbXSxcclxuICAgICAgICAgICAgY3VycmVudE92ZXJFZGdlcyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBDaGVjayBuZXdseSBvdmVycmVkIG5vZGVzOlxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgY3VycmVudE92ZXJOb2Rlc1tub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICBpZiAoIW92ZXJOb2Rlc1tub2RlLmlkXSkge1xyXG4gICAgICAgICAgICBuZXdPdmVyTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgb3Zlck5vZGVzW25vZGUuaWRdID0gbm9kZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBub2RlczpcclxuICAgICAgICBmb3IgKGsgaW4gb3Zlck5vZGVzKVxyXG4gICAgICAgICAgaWYgKCFjdXJyZW50T3Zlck5vZGVzW2tdKSB7XHJcbiAgICAgICAgICAgIG5ld091dE5vZGVzLnB1c2gob3Zlck5vZGVzW2tdKTtcclxuICAgICAgICAgICAgZGVsZXRlIG92ZXJOb2Rlc1trXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgbmV3bHkgb3ZlcnJlZCBlZGdlczpcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tpXTtcclxuICAgICAgICAgIGN1cnJlbnRPdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xyXG4gICAgICAgICAgaWYgKCFvdmVyRWRnZXNbZWRnZS5pZF0pIHtcclxuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzLnB1c2goZWRnZSk7XHJcbiAgICAgICAgICAgIG92ZXJFZGdlc1tlZGdlLmlkXSA9IGVkZ2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBubyBtb3JlIG92ZXJyZWQgZWRnZXM6XHJcbiAgICAgICAgZm9yIChrIGluIG92ZXJFZGdlcylcclxuICAgICAgICAgIGlmICghY3VycmVudE92ZXJFZGdlc1trXSkge1xyXG4gICAgICAgICAgICBuZXdPdXRFZGdlcy5wdXNoKG92ZXJFZGdlc1trXSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyRWRnZXNba107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdPdXRFZGdlcy5sZW5ndGggfHwgbmV3T3ZlckVkZ2VzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICAgbmV3T3V0Tm9kZXMubGVuZ3RoIHx8IG5ld092ZXJOb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnaG92ZXJzJywge1xyXG4gICAgICAgICAgICBjdXJyZW50OiB7XHJcbiAgICAgICAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgICAgICAgIGVkZ2VzOiBlZGdlcyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW50ZXI6IHtcclxuICAgICAgICAgICAgICBub2RlczogbmV3T3Zlck5vZGVzLFxyXG4gICAgICAgICAgICAgIGVkZ2VzOiBuZXdPdmVyRWRnZXMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxlYXZlOiB7XHJcbiAgICAgICAgICAgICAgbm9kZXM6IG5ld091dE5vZGVzLFxyXG4gICAgICAgICAgICAgIGVkZ2VzOiBuZXdPdXRFZGdlcyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQmluZCBldmVudHM6XHJcbiAgICAgIGNhcHRvci5iaW5kKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gICAgICBjYXB0b3IuYmluZCgnbW91c2Vkb3duJywgb25Nb3ZlKTtcclxuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNldXAnLCBvbk1vdmUpO1xyXG4gICAgICBjYXB0b3IuYmluZCgnbW91c2Vtb3ZlJywgb25Nb3ZlKTtcclxuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlb3V0Jywgb25PdXQpO1xyXG4gICAgICBjYXB0b3IuYmluZCgnZG91YmxlY2xpY2snLCBvbkRvdWJsZUNsaWNrKTtcclxuICAgICAgY2FwdG9yLmJpbmQoJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNhcHRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICBiaW5kQ2FwdG9yKHRoaXMuY2FwdG9yc1tpXSk7XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGhlbHBlciB3aWxsIGJpbmQgYW55IERPTSByZW5kZXJlciAoZm9yIGluc3RhbmNlIHN2ZylcclxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxyXG4gICAqIHRvIG1hbmFnZSBjbGlja2luZywgaG92ZXJpbmcgZXRjLi4uXHJcbiAgICpcclxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cclxuICAgKi9cclxuICBzaWdtYS5taXNjLmJpbmRET01FdmVudHMgPSBmdW5jdGlvbihjb250YWluZXIpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXHJcbiAgICAgICAgaG92ZXJlZCA9IHtub2RlczogW10sIGVkZ2VzOiBbXX07XHJcblxyXG4gICAgLy8gRE9NRWxlbWVudCBhYnN0cmFjdGlvblxyXG4gICAgZnVuY3Rpb24gRWxlbWVudChkb21FbGVtZW50KSB7XHJcblxyXG4gICAgICAvLyBIZWxwZXJzXHJcbiAgICAgIHRoaXMuYXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnVsbCwgYXR0ck5hbWUpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUHJvcGVydGllc1xyXG4gICAgICB0aGlzLnRhZyA9IGRvbUVsZW1lbnQudGFnTmFtZTtcclxuICAgICAgdGhpcy5jbGFzcyA9IHRoaXMuYXR0cignY2xhc3MnKTtcclxuICAgICAgdGhpcy5pZCA9IHRoaXMuYXR0cignaWQnKTtcclxuXHJcbiAgICAgIC8vIE1ldGhvZHNcclxuICAgICAgdGhpcy5pc05vZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuaXNFZGdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmlzSG92ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyJyk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xpY2tcclxuICAgIGZ1bmN0aW9uIGNsaWNrKGUpIHtcclxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gR2VuZXJpYyBldmVudFxyXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xyXG5cclxuICAgICAgLy8gQXJlIHdlIG9uIGEgbm9kZT9cclxuICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgRWxlbWVudChlLnRhcmdldCk7XHJcblxyXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSlcclxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrTm9kZScsIHtcclxuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrU3RhZ2UnKTtcclxuXHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEb3VibGUgY2xpY2tcclxuICAgIGZ1bmN0aW9uIGRvdWJsZUNsaWNrKGUpIHtcclxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gR2VuZXJpYyBldmVudFxyXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrJywgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xyXG5cclxuICAgICAgLy8gQXJlIHdlIG9uIGEgbm9kZT9cclxuICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgRWxlbWVudChlLnRhcmdldCk7XHJcblxyXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSlcclxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrTm9kZScsIHtcclxuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrU3RhZ2UnKTtcclxuXHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbiBvdmVyXHJcbiAgICBmdW5jdGlvbiBvbk92ZXIoZSkge1xyXG4gICAgICB2YXIgdGFyZ2V0ID0gZS50b0VsZW1lbnQgfHwgZS50YXJnZXQ7XHJcblxyXG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSB8fCAhdGFyZ2V0KVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHZhciBlbF9zdmcgPSBuZXcgRWxlbWVudCh0YXJnZXQpLFxyXG4gICAgICAgIGV2ZW50ID0ge1xyXG4gICAgICAgICAgbGVhdmU6IHtub2RlczogW10sIGVkZ2VzOiBbXX0sXHJcbiAgICAgICAgICBlbnRlcjoge25vZGVzOiBbXSwgZWRnZXM6IFtdfSxcclxuICAgICAgICAgIGNhcHRvcjogc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbDtcclxuXHJcbiAgICAgIGlmIChlbF9zdmcuaXNOb2RlKCkpIHtcclxuICAgICAgICBlbCA9IGdyYXBoLm5vZGVzKGVsX3N2Zy5hdHRyKCdkYXRhLW5vZGUtaWQnKSk7XHJcbiAgICAgICAgZXZlbnQuZW50ZXIubm9kZXMgPSBbZWxdO1xyXG4gICAgICAgIGhvdmVyZWQubm9kZXMucHVzaChlbCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZWxfc3ZnLmlzRWRnZSgpKSB7XHJcbiAgICAgICAgZWwgPSBncmFwaC5lZGdlcyhlbF9zdmcuYXR0cignZGF0YS1lZGdlLWlkJykpO1xyXG4gICAgICAgIGV2ZW50LmVudGVyLmVkZ2VzID0gW2VsXTtcclxuICAgICAgICBob3ZlcmVkLmVkZ2VzLnB1c2goZWwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBldmVudC5jdXJyZW50ID0gaG92ZXJlZDtcclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdob3ZlcnMnLCBldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT24gb3V0XHJcbiAgICBmdW5jdGlvbiBvbk91dChlKSB7XHJcbiAgICAgIHZhciB0YXJnZXQgPSBlLmZyb21FbGVtZW50IHx8IGUub3JpZ2luYWxUYXJnZXQ7XHJcblxyXG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB2YXIgZWxfc3ZnID0gbmV3IEVsZW1lbnQodGFyZ2V0KSxcclxuICAgICAgICBldmVudCA9IHtcclxuICAgICAgICAgIGxlYXZlOiB7bm9kZXM6IFtdLCBlZGdlczogW119LFxyXG4gICAgICAgICAgZW50ZXI6IHtub2RlczogW10sIGVkZ2VzOiBbXX0sXHJcbiAgICAgICAgICBjYXB0b3I6IHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZWw7XHJcblxyXG4gICAgICBpZiAoZWxfc3ZnLmlzTm9kZSgpKSB7XHJcbiAgICAgICAgZWwgPSBncmFwaC5ub2RlcyhlbF9zdmcuYXR0cignZGF0YS1ub2RlLWlkJykpO1xyXG4gICAgICAgIGV2ZW50LmxlYXZlLm5vZGVzID0gW2VsXTtcclxuICAgICAgICBob3ZlcmVkLm5vZGVzLnB1c2goZWwpO1xyXG4gICAgICB9IGVsc2UgaWYgKGVsX3N2Zy5pc0VkZ2UoKSkge1xyXG4gICAgICAgIGVsID0gZ3JhcGguZWRnZXMoZWxfc3ZnLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcclxuICAgICAgICBldmVudC5sZWF2ZS5lZGdlcyA9IFtlbF07XHJcbiAgICAgICAgaG92ZXJlZC5lZGdlcy5wdXNoKGVsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV2ZW50LmN1cnJlbnQgPSBob3ZlcmVkO1xyXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2hvdmVycycsIGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWdpc3RlcmluZyBFdmVudHM6XHJcblxyXG4gICAgLy8gQ2xpY2tcclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrLCBmYWxzZSk7XHJcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICdjbGljaycsIGRvdWJsZUNsaWNrKTtcclxuXHJcbiAgICAvLyBUb3VjaCBjb3VudGVycGFydHNcclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2xpY2ssIGZhbHNlKTtcclxuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKGNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCBkb3VibGVDbGljayk7XHJcblxyXG4gICAgLy8gTW91c2VvdmVyXHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25PdmVyLCB0cnVlKTtcclxuXHJcbiAgICAvLyBNb3VzZW91dFxyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgb25PdXQsIHRydWUpO1xyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBcImhvdmVyc1wiIGV2ZW50cyBmcm9tIGEgcmVuZGVyZXIgYW5kIHJlbmRlcnNcclxuICAgKiB0aGUgbm9kZXMgZGlmZmVyZW50bHkgb24gdGhlIHRvcCBsYXllci5cclxuICAgKiBUaGUgZ29hbCBpcyB0byBtYWtlIGFueSBub2RlIGxhYmVsIHJlYWRhYmxlIHdpdGggdGhlIG1vdXNlLCBhbmQgdG9cclxuICAgKiBoaWdobGlnaHQgaG92ZXJlZCBub2RlcyBhbmQgZWRnZXMuXHJcbiAgICpcclxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cclxuICAgKi9cclxuICBzaWdtYS5taXNjLmRyYXdIb3ZlcnMgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBjdXJyZW50ID0ge25vZGVzOiBbXSwgZWRnZXM6IFtdfTtcclxuXHJcbiAgICB0aGlzLmJpbmQoJ2hvdmVycycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIGN1cnJlbnQgPSBldmVudC5kYXRhLmN1cnJlbnQ7XHJcbiAgICAgIGRyYXcoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgZHJhdygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhdygpIHtcclxuICAgICAgdmFyIGMgPSBzZWxmLmNvbnRleHRzLmhvdmVyLmNhbnZhcyxcclxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XHJcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIGVuZCA9IGVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJykgPyAxIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgcmVuZGVyUGFyYW1zID0ge1xyXG4gICAgICAgICAgICBlbGVtZW50czogY3VycmVudC5ub2RlcyxcclxuICAgICAgICAgICAgcmVuZGVyZXJzOiBzaWdtYS5jYW52YXMuaG92ZXJzLFxyXG4gICAgICAgICAgICB0eXBlOiAnbm9kZXMnLFxyXG4gICAgICAgICAgICBjdHg6IHNlbGYuY29udGV4dHMuaG92ZXIsXHJcbiAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICBncmFwaDogc2VsZi5ncmFwaCxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IGVtYmVkU2V0dGluZ3MsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgc2VsZi5jb250ZXh0cy5ob3Zlci5jbGVhclJlY3QoMCwgMCwgYy53aWR0aCwgYy5oZWlnaHQpO1xyXG5cclxuICAgICAgLy8gTm9kZSByZW5kZXJcclxuICAgICAgaWYgKGN1cnJlbnQubm9kZXMubGVuZ3RoID4gMCAmJiBlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpKSB7XHJcbiAgICAgICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5hcHBseVJlbmRlcmVycyhyZW5kZXJQYXJhbXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFZGdlIHJlbmRlclxyXG4gICAgICBpZiAoY3VycmVudC5lZGdlcy5sZW5ndGggPiAwICYmIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpKSB7XHJcbiAgICAgICAgcmVuZGVyUGFyYW1zLnJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzO1xyXG4gICAgICAgIHJlbmRlclBhcmFtcy5lbGVtZW50cyA9IGN1cnJlbnQuZWRnZXM7XHJcbiAgICAgICAgcmVuZGVyUGFyYW1zLnR5cGUgPSAnZWRnZXMnO1xyXG4gICAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMuYXBwbHlSZW5kZXJlcnMocmVuZGVyUGFyYW1zKTtcclxuXHJcbiAgICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VIb3ZlckV4dHJlbWl0aWVzJykpIHtcclxuICAgICAgICAgIHJlbmRlclBhcmFtcy5yZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZXh0cmVtaXRpZXM7XHJcbiAgICAgICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLmFwcGx5UmVuZGVyZXJzKHJlbmRlclBhcmFtcyk7XHJcbiAgICAgICAgfSBlbHNlIHsgLy9kcmF3IG5vZGVzIG92ZXIgZWRnZXNcclxuICAgICAgICAgIHJlbmRlclBhcmFtcy5jdHggPSBzZWxmLmNvbnRleHRzLm5vZGVzO1xyXG4gICAgICAgICAgcmVuZGVyUGFyYW1zLnR5cGUgPSAnbm9kZXMnO1xyXG4gICAgICAgICAgcmVuZGVyUGFyYW1zLnJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5ub2RlcztcclxuICAgICAgICAgIHJlbmRlclBhcmFtcy5lbGVtZW50cyA9IGN1cnJlbnQubm9kZXM7XHJcbiAgICAgICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLmFwcGx5UmVuZGVyZXJzKHJlbmRlclBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuIiwiOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaWdtYSBpcyBub3QgZGVjbGFyZWQnKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubGF5b3V0cy5ub3ZlcmxhcCcpO1xyXG5cclxuICAvKipcclxuICAgKiBOb3ZlcmxhcCBMYXlvdXRcclxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICpcclxuICAgKiBBdXRob3I6IEBhcGl0dHMgLyBBbmRyZXcgUGl0dHNcclxuICAgKiBBbGdvcml0aG06IEBqYWNvbXltYSAvIE1hdGhpZXUgSmFjb215IChvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIHRvIEdlcGhpIGFuZCBwb3J0ZWQgdG8gc2lnbWEuanMgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGJ5IEBhbmRwaXR0cyB3aXRoIHBlcm1pc3Npb24pXHJcbiAgICogQWNrbm93bGVkZ2VtZW50OiBAc2hleW1hbiAvIFPDqWJhc3RpZW4gSGV5bWFubiAoc29tZSBpbnNwaXJhdGlvbiBoYXMgYmVlbiB0YWtlbiBmcm9tIG90aGVyIE1JVCBsaWNlbnNlZCBsYXlvdXQgYWxnb3JpdGhtcyBhdXRob3JlZCBieSBAc2hleW1hbilcclxuICAgKiBWZXJzaW9uOiAwLjFcclxuICAgKi9cclxuXHJcbiAgdmFyIHNldHRpbmdzID0ge1xyXG4gICAgc3BlZWQ6IDMsXHJcbiAgICBzY2FsZU5vZGVzOiAxLjIsXHJcbiAgICBub2RlTWFyZ2luOiA1LjAsXHJcbiAgICBncmlkU2l6ZTogMjAsXHJcbiAgICBwZXJtaXR0ZWRFeHBhbnNpb246IDEuMSxcclxuICAgIHJlbmRlcmVySW5kZXg6IDAsXHJcbiAgICBtYXhJdGVyYXRpb25zOiA1MDBcclxuICB9O1xyXG5cclxuICB2YXIgX2luc3RhbmNlID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IGVtaXR0ZXIgT2JqZWN0XHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgdmFyIF9ldmVudEVtaXR0ZXIgPSB7fTtcclxuXHJcbiAgIC8qKlxyXG4gICAqIE5vdmVybGFwIE9iamVjdFxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIE5vdmVybGFwKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChzaWdJbnN0LCBvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgLy8gUHJvcGVydGllc1xyXG4gICAgICB0aGlzLnNpZ0luc3QgPSBzaWdJbnN0O1xyXG4gICAgICB0aGlzLmNvbmZpZyA9IHNpZ21hLnV0aWxzLmV4dGVuZChvcHRpb25zLCBzZXR0aW5ncyk7XHJcbiAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XHJcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMubm9kZXMpIHtcclxuICAgICAgICB0aGlzLm5vZGVzID0gb3B0aW9ucy5ub2RlcztcclxuICAgICAgICBkZWxldGUgb3B0aW9ucy5ub2RlcztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFzaWdtYS5wbHVnaW5zIHx8IHR5cGVvZiBzaWdtYS5wbHVnaW5zLmFuaW1hdGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWdtYS5wbHVnaW5zLmFuaW1hdGUgaXMgbm90IGRlY2xhcmVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN0YXRlXHJcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbmdsZSBsYXlvdXQgaXRlcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmF0b21pY0dvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoIXRoaXMucnVubmluZyB8fCB0aGlzLml0ZXJDb3VudCA8IDEpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMgfHwgdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCksXHJcbiAgICAgICAgICBub2Rlc0NvdW50ID0gbm9kZXMubGVuZ3RoLFxyXG4gICAgICAgICAgaSxcclxuICAgICAgICAgIG4sXHJcbiAgICAgICAgICBuMSxcclxuICAgICAgICAgIG4yLFxyXG4gICAgICAgICAgeG1pbiA9IEluZmluaXR5LFxyXG4gICAgICAgICAgeG1heCA9IC1JbmZpbml0eSxcclxuICAgICAgICAgIHltaW4gPSBJbmZpbml0eSxcclxuICAgICAgICAgIHltYXggPSAtSW5maW5pdHksXHJcbiAgICAgICAgICB4d2lkdGgsXHJcbiAgICAgICAgICB5aGVpZ2h0LFxyXG4gICAgICAgICAgeGNlbnRlcixcclxuICAgICAgICAgIHljZW50ZXIsXHJcbiAgICAgICAgICBncmlkLFxyXG4gICAgICAgICAgcm93LFxyXG4gICAgICAgICAgY29sLFxyXG4gICAgICAgICAgbWluWEJveCxcclxuICAgICAgICAgIG1heFhCb3gsXHJcbiAgICAgICAgICBtaW5ZQm94LFxyXG4gICAgICAgICAgbWF4WUJveCxcclxuICAgICAgICAgIGFkamFjZW50Tm9kZXMsXHJcbiAgICAgICAgICBzdWJSb3csXHJcbiAgICAgICAgICBzdWJDb2wsXHJcbiAgICAgICAgICBueG1pbixcclxuICAgICAgICAgIG54bWF4LFxyXG4gICAgICAgICAgbnltaW4sXHJcbiAgICAgICAgICBueW1heDtcclxuXHJcbiAgICAgIHRoaXMuaXRlckNvdW50LS07XHJcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcclxuICAgICAgICBuID0gbm9kZXNbaV07XHJcbiAgICAgICAgbi5kbi5keCA9IDA7XHJcbiAgICAgICAgbi5kbi5keSA9IDA7XHJcblxyXG4gICAgICAgIC8vRmluZCB0aGUgbWluIGFuZCBtYXggZm9yIGJvdGggeCBhbmQgeSBhY3Jvc3MgYWxsIG5vZGVzXHJcbiAgICAgICAgeG1pbiA9IE1hdGgubWluKHhtaW4sIG4uZG5feCAtIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XHJcbiAgICAgICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIG4uZG5feCArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XHJcbiAgICAgICAgeW1pbiA9IE1hdGgubWluKHltaW4sIG4uZG5feSAtIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XHJcbiAgICAgICAgeW1heCA9IE1hdGgubWF4KHltYXgsIG4uZG5feSArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICB4d2lkdGggPSB4bWF4IC0geG1pbjtcclxuICAgICAgeWhlaWdodCA9IHltYXggLSB5bWluO1xyXG4gICAgICB4Y2VudGVyID0gKHhtaW4gKyB4bWF4KSAvIDI7XHJcbiAgICAgIHljZW50ZXIgPSAoeW1pbiArIHltYXgpIC8gMjtcclxuICAgICAgeG1pbiA9IHhjZW50ZXIgLSBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeHdpZHRoIC8gMjtcclxuICAgICAgeG1heCA9IHhjZW50ZXIgKyBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeHdpZHRoIC8gMjtcclxuICAgICAgeW1pbiA9IHljZW50ZXIgLSBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeWhlaWdodCAvIDI7XHJcbiAgICAgIHltYXggPSB5Y2VudGVyICsgc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnloZWlnaHQgLyAyO1xyXG5cclxuICAgICAgZ3JpZCA9IHt9OyAvL0FuIG9iamVjdCBvZiBvYmplY3RzIHdoZXJlIGdyaWRbcm93XVtjb2xdIGlzIGFuIGFycmF5IG9mIG5vZGUgaWRzIHJlcHJlc2VudGluZyBub2RlcyB0aGF0IGZhbGwgaW4gdGhhdCBncmlkLiBOb2RlcyBjYW4gZmFsbCBpbiBtb3JlIHRoYW4gb25lIGdyaWRcclxuXHJcbiAgICAgIGZvcihyb3cgPSAwOyByb3cgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgcm93KyspIHtcclxuICAgICAgICBncmlkW3Jvd10gPSB7fTtcclxuICAgICAgICBmb3IoY29sID0gMDsgY29sIDwgc2VsZi5jb25maWcuZ3JpZFNpemU7IGNvbCsrKSB7XHJcbiAgICAgICAgICBncmlkW3Jvd11bY29sXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy9QbGFjZSBub2RlcyBpbiBncmlkXHJcbiAgICAgIGZvciAoaT0wOyBpIDwgbm9kZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5vZGVzW2ldO1xyXG5cclxuICAgICAgICBueG1pbiA9IG4uZG5feCAtIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pO1xyXG4gICAgICAgIG54bWF4ID0gbi5kbl94ICsgKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbik7XHJcbiAgICAgICAgbnltaW4gPSBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcclxuICAgICAgICBueW1heCA9IG4uZG5feSArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pO1xyXG5cclxuICAgICAgICBtaW5YQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG54bWluIC0geG1pbikgLyAoeG1heCAtIHhtaW4pICk7XHJcbiAgICAgICAgbWF4WEJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueG1heCAtIHhtaW4pIC8gKHhtYXggLSB4bWluKSApO1xyXG4gICAgICAgIG1pbllCb3ggPSBNYXRoLmZsb29yKHNlbGYuY29uZmlnLmdyaWRTaXplKiAobnltaW4gLSB5bWluKSAvICh5bWF4IC0geW1pbikgKTtcclxuICAgICAgICBtYXhZQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG55bWF4IC0geW1pbikgLyAoeW1heCAtIHltaW4pICk7XHJcbiAgICAgICAgZm9yKGNvbCA9IG1pblhCb3g7IGNvbCA8PSBtYXhYQm94OyBjb2wrKykge1xyXG4gICAgICAgICAgZm9yKHJvdyA9IG1pbllCb3g7IHJvdyA8PSBtYXhZQm94OyByb3crKykge1xyXG4gICAgICAgICAgICBncmlkW3Jvd11bY29sXS5wdXNoKG4uaWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGFkamFjZW50Tm9kZXMgPSB7fTsgLy9BbiBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIG5vZGUgaWRzIG9mIGFkamFjZW50IG5vZGVzIChlaXRoZXIgaW4gc2FtZSBncmlkIGJveCBvciBhZGphY2VudCBncmlkIGJveCkgZm9yIGFsbCBub2Rlc1xyXG5cclxuICAgICAgZm9yKHJvdyA9IDA7IHJvdyA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyByb3crKykge1xyXG4gICAgICAgIGZvcihjb2wgPSAwOyBjb2wgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgY29sKyspIHtcclxuICAgICAgICAgIGdyaWRbcm93XVtjb2xdLmZvckVhY2goZnVuY3Rpb24obm9kZUlkKSB7XHJcbiAgICAgICAgICAgIGlmKCFhZGphY2VudE5vZGVzW25vZGVJZF0pIHtcclxuICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3Ioc3ViUm93ID0gTWF0aC5tYXgoMCwgcm93IC0gMSk7IHN1YlJvdyA8PSBNYXRoLm1pbihyb3cgKyAxLCBzZWxmLmNvbmZpZy5ncmlkU2l6ZSAtIDEpOyBzdWJSb3crKykge1xyXG4gICAgICAgICAgICAgIGZvcihzdWJDb2wgPSBNYXRoLm1heCgwLCBjb2wgLSAxKTsgc3ViQ29sIDw9IE1hdGgubWluKGNvbCArIDEsICBzZWxmLmNvbmZpZy5ncmlkU2l6ZSAtIDEpOyBzdWJDb2wrKykge1xyXG4gICAgICAgICAgICAgICAgZ3JpZFtzdWJSb3ddW3N1YkNvbF0uZm9yRWFjaChmdW5jdGlvbihzdWJOb2RlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgaWYoc3ViTm9kZUlkICE9PSBub2RlSWQgJiYgYWRqYWNlbnROb2Rlc1tub2RlSWRdLmluZGV4T2Yoc3ViTm9kZUlkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0ucHVzaChzdWJOb2RlSWQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy9JZiB0d28gbm9kZXMgb3ZlcmxhcCB0aGVuIHJlcHVsc2UgdGhlbVxyXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xyXG4gICAgICAgIG4xID0gbm9kZXNbaV07XHJcbiAgICAgICAgYWRqYWNlbnROb2Rlc1tuMS5pZF0uZm9yRWFjaChmdW5jdGlvbihub2RlSWQpIHtcclxuICAgICAgICAgIHZhciBuMiA9IHNlbGYuc2lnSW5zdC5ncmFwaC5ub2Rlcyhub2RlSWQpO1xyXG4gICAgICAgICAgdmFyIHhEaXN0ID0gbjIuZG5feCAtIG4xLmRuX3g7XHJcbiAgICAgICAgICB2YXIgeURpc3QgPSBuMi5kbl95IC0gbjEuZG5feTtcclxuICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KHhEaXN0KnhEaXN0ICsgeURpc3QqeURpc3QpO1xyXG4gICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IChkaXN0IDwgKChuMS5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSArIChuMi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSkpO1xyXG4gICAgICAgICAgaWYoY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgIHNlbGYucnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmKGRpc3QgPiAwKSB7XHJcbiAgICAgICAgICAgICAgbjIuZG4uZHggKz0geERpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcclxuICAgICAgICAgICAgICBuMi5kbi5keSArPSB5RGlzdCAvIGRpc3QgKiAoMSArIG4xLmRuX3NpemUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4yLmRuLmR4ICs9IHh3aWR0aCAqIDAuMDEgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XHJcbiAgICAgICAgICAgICAgbjIuZG4uZHkgKz0geWhlaWdodCAqIDAuMDEgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcclxuICAgICAgICBuID0gbm9kZXNbaV07XHJcbiAgICAgICAgaWYoIW4uZml4ZWQpIHtcclxuICAgICAgICAgIG4uZG5feCA9IG4uZG5feCArIG4uZG4uZHggKiAwLjEgKiBzZWxmLmNvbmZpZy5zcGVlZDtcclxuICAgICAgICAgIG4uZG5feSA9IG4uZG5feSArIG4uZG4uZHkgKiAwLjEgKiBzZWxmLmNvbmZpZy5zcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKHRoaXMucnVubmluZyAmJiB0aGlzLml0ZXJDb3VudCA8IDEpIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5pdGVyQ291bnQgPSB0aGlzLmNvbmZpZy5tYXhJdGVyYXRpb25zO1xyXG5cclxuICAgICAgd2hpbGUgKHRoaXMucnVubmluZykge1xyXG4gICAgICAgIHRoaXMuYXRvbWljR28oKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHJldHVybjtcclxuXHJcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuc2lnSW5zdC5ncmFwaC5ub2RlcygpO1xyXG5cclxuICAgICAgdmFyIHByZWZpeCA9IHRoaXMuc2lnSW5zdC5yZW5kZXJlcnNbc2VsZi5jb25maWcucmVuZGVyZXJJbmRleF0ub3B0aW9ucy5wcmVmaXg7XHJcblxyXG4gICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gSW5pdCBub2Rlc1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbm9kZXNbaV0uZG5feCA9IG5vZGVzW2ldW3ByZWZpeCArICd4J107XHJcbiAgICAgICAgbm9kZXNbaV0uZG5feSA9IG5vZGVzW2ldW3ByZWZpeCArICd5J107XHJcbiAgICAgICAgbm9kZXNbaV0uZG5fc2l6ZSA9IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ107XHJcbiAgICAgICAgbm9kZXNbaV0uZG4gPSB7XHJcbiAgICAgICAgICBkeDogMCxcclxuICAgICAgICAgIGR5OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RhcnQnKTtcclxuICAgICAgdGhpcy5nbygpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCk7XHJcblxyXG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmVhc2luZykge1xyXG4gICAgICAgIF9ldmVudEVtaXR0ZXJbc2VsZi5zaWdJbnN0LmlkXS5kaXNwYXRjaEV2ZW50KCdpbnRlcnBvbGF0ZScpO1xyXG4gICAgICAgIHNpZ21hLnBsdWdpbnMuYW5pbWF0ZShcclxuICAgICAgICAgIHNlbGYuc2lnSW5zdCxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgeDogJ2RuX3gnLFxyXG4gICAgICAgICAgICB5OiAnZG5feSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGVhc2luZzogc2VsZi5lYXNpbmcsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHNlbGYuc2lnSW5zdC5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uZG4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uZG5feCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbl95ID0gbnVsbDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgX2V2ZW50RW1pdHRlcltzZWxmLnNpZ0luc3QuaWRdLmRpc3BhdGNoRXZlbnQoJ3N0b3AnKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHNlbGYuZHVyYXRpb25cclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEFwcGx5IGNoYW5nZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBub2Rlc1tpXS54ID0gbm9kZXNbaV0uZG5feDtcclxuICAgICAgICAgIG5vZGVzW2ldLnkgPSBub2Rlc1tpXS5kbl95O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zaWdJbnN0LnJlZnJlc2goKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbm9kZXNbaV0uZG4gPSBudWxsO1xyXG4gICAgICAgICAgbm9kZXNbaV0uZG5feCA9IG51bGw7XHJcbiAgICAgICAgICBub2Rlc1tpXS5kbl95ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2V2ZW50RW1pdHRlcltzZWxmLnNpZ0luc3QuaWRdLmRpc3BhdGNoRXZlbnQoJ3N0b3AnKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5zaWdJbnN0ID0gbnVsbDtcclxuICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xyXG4gICAgICB0aGlzLmVhc2luZyA9IG51bGw7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZVxyXG4gICAqIC0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uZmlndXJlIHRoZSBsYXlvdXQgYWxnb3JpdGhtLlxyXG5cclxuICAgKiBSZWNvZ25pemVkIG9wdGlvbnM6XHJcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXIgaW4gdGhlIHNldHRpbmdzXHJcbiAgICogb2JqZWN0OlxyXG4gICAqXHJcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBzcGVlZCAgICAgICAgICAgICAgIEEgbGFyZ2VyIHZhbHVlIGluY3JlYXNlcyB0aGUgY29udmVyZ2VuY2Ugc3BlZWQgYXQgdGhlIGNvc3Qgb2YgcHJlY2lzaW9uXHJcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBzY2FsZU5vZGVzICAgICAgICAgIFRoZSByYXRpbyB0byBzY2FsZSBub2RlcyBieSAtIGEgbGFyZ2VyIHJhdGlvIHdpbGwgbGVhZCB0byBtb3JlIHNwYWNlIGFyb3VuZCBsYXJnZXIgbm9kZXNcclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtIGJlZm9yZSB0aGUgbGF5b3V0IGNvbXBsZXRlcy5cclxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIGdyaWRTaXplICAgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIHRvIHVzZSB3aGVuIHBhcnRpb25pbmcgbm9kZXMgaW50byBhIGdyaWQgZm9yIGVmZmljaWVudCBjb21wdXRhdGlvblxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxyXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgcmVuZGVyZXJJbmRleCAgICAgICBUaGUgaW5kZXggb2YgdGhlIHJlbmRlcmVyIHRvIHVzZSBmb3Igbm9kZSBjby1vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHplcm8uXHJcbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSBlYXNpbmcgICAgICAgICAgICAgIEVpdGhlciB0aGUgbmFtZSBvZiBhbiBlYXNpbmcgaW4gdGhlIHNpZ21hLnV0aWxzLmVhc2luZ3MgcGFja2FnZSBvciBhIGZ1bmN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICAgICAgICAgICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIFwiYW5pbWF0aW9uc1RpbWVcIiBzZXR0aW5nIHZhbHVlIG9mIHRoZSBzaWdtYSBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgKlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgIFRoZSBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxyXG4gICAqL1xyXG4gIHNpZ21hLnByb3RvdHlwZS5jb25maWdOb3ZlcmxhcCA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cclxuICAgIHZhciBzaWdJbnN0ID0gdGhpcztcclxuXHJcbiAgICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGFyZ3VtZW50OiBcImNvbmZpZ1wiJyk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGluc3RhbmNlIGlmIHVuZGVmaW5lZFxyXG4gICAgaWYgKCFfaW5zdGFuY2Vbc2lnSW5zdC5pZF0pIHtcclxuICAgICAgX2luc3RhbmNlW3NpZ0luc3QuaWRdID0gbmV3IE5vdmVybGFwKCk7XHJcblxyXG4gICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0ge307XHJcbiAgICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQoX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXSk7XHJcblxyXG4gICAgICAvLyBCaW5kaW5nIG9uIGtpbGwgdG8gY2xlYXIgdGhlIHJlZmVyZW5jZXNcclxuICAgICAgc2lnSW5zdC5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX2luc3RhbmNlW3NpZ0luc3QuaWRdLmtpbGwoKTtcclxuICAgICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gPSBudWxsO1xyXG4gICAgICAgIF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF0gPSBudWxsO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0uaW5pdChzaWdJbnN0LCBjb25maWcpO1xyXG5cclxuICAgIHJldHVybiBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBsYXlvdXQgYWxnb3JpdGhtLiBJdCB3aWxsIHVzZSB0aGUgZXhpc3RpbmcgY29uZmlndXJhdGlvbiBpZiBub1xyXG4gICAqIG5ldyBjb25maWd1cmF0aW9uIGlzIHBhc3NlZC5cclxuXHJcbiAgICogUmVjb2duaXplZCBvcHRpb25zOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVyIGluIHRoZSBzZXR0aW5nc1xyXG4gICAqIG9iamVjdFxyXG4gICAqXHJcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBzcGVlZCAgICAgICAgICAgICAgIEEgbGFyZ2VyIHZhbHVlIGluY3JlYXNlcyB0aGUgY29udmVyZ2VuY2Ugc3BlZWQgYXQgdGhlIGNvc3Qgb2YgcHJlY2lzaW9uXHJcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBzY2FsZU5vZGVzICAgICAgICAgIFRoZSByYXRpbyB0byBzY2FsZSBub2RlcyBieSAtIGEgbGFyZ2VyIHJhdGlvIHdpbGwgbGVhZCB0byBtb3JlIHNwYWNlIGFyb3VuZCBsYXJnZXIgbm9kZXNcclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtIGJlZm9yZSB0aGUgbGF5b3V0IGNvbXBsZXRlcy5cclxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIGdyaWRTaXplICAgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIHRvIHVzZSB3aGVuIHBhcnRpb25pbmcgbm9kZXMgaW50byBhIGdyaWQgZm9yIGVmZmljaWVudCBjb21wdXRhdGlvblxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxyXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgcmVuZGVyZXJJbmRleCAgICAgICBUaGUgaW5kZXggb2YgdGhlIHJlbmRlcmVyIHRvIHVzZSBmb3Igbm9kZSBjby1vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHplcm8uXHJcbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSBlYXNpbmcgICAgICAgICAgICAgIEVpdGhlciB0aGUgbmFtZSBvZiBhbiBlYXNpbmcgaW4gdGhlIHNpZ21hLnV0aWxzLmVhc2luZ3MgcGFja2FnZSBvciBhIGZ1bmN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICAgICAgICAgICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIFwiYW5pbWF0aW9uc1RpbWVcIiBzZXR0aW5nIHZhbHVlIG9mIHRoZSBzaWdtYSBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgKlxyXG4gICAqXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvbmZpZyAgVGhlIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyfSBSZXR1cm5zIGFuIGV2ZW50IGVtaXR0ZXIuXHJcbiAgICovXHJcblxyXG4gIHNpZ21hLnByb3RvdHlwZS5zdGFydE5vdmVybGFwID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcblxyXG4gICAgdmFyIHNpZ0luc3QgPSB0aGlzO1xyXG5cclxuICAgIGlmIChjb25maWcpIHtcclxuICAgICAgdGhpcy5jb25maWdOb3ZlcmxhcChzaWdJbnN0LCBjb25maWcpO1xyXG4gICAgfVxyXG5cclxuICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5zdGFydCgpO1xyXG5cclxuICAgIHJldHVybiBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGhhcyBzdGFydGVkIGFuZCBpcyBub3QgY29tcGxldGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUuaXNOb3ZlcmxhcFJ1bm5pbmcgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XHJcblxyXG4gICAgcmV0dXJuICEhX2luc3RhbmNlW3NpZ0luc3QuaWRdICYmIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5ydW5uaW5nO1xyXG4gIH07XHJcblxyXG59KS5jYWxsKHRoaXMpOyIsIi8qKlxyXG4gKiBUaGlzIHBsdWdpbiBwcm92aWRlcyBhIG1ldGhvZCB0byBhbmltYXRlIGEgc2lnbWEgaW5zdGFuY2UgYnkgaW50ZXJwb2xhdGluZ1xyXG4gKiBzb21lIG5vZGUgcHJvcGVydGllcy4gQ2hlY2sgdGhlIHNpZ21hLnBsdWdpbnMuYW5pbWF0ZSBmdW5jdGlvbiBkb2Mgb3IgdGhlXHJcbiAqIGV4YW1wbGVzL2FuaW1hdGUuaHRtbCBjb2RlIHNhbXBsZSB0byBrbm93IG1vcmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnBsdWdpbnMnKTtcclxuXHJcbiAgdmFyIF9pZCA9IDAsXHJcbiAgICAgIF9jYWNoZSA9IHt9O1xyXG5cclxuICAvLyBUT09MSU5HIEZVTkNUSU9OUzpcclxuICAvLyAqKioqKioqKioqKioqKioqKipcclxuICBmdW5jdGlvbiBwYXJzZUNvbG9yKHZhbCkge1xyXG4gICAgaWYgKF9jYWNoZVt2YWxdKVxyXG4gICAgICByZXR1cm4gX2NhY2hlW3ZhbF07XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFswLCAwLCAwXTtcclxuXHJcbiAgICBpZiAodmFsLm1hdGNoKC9eIy8pKSB7XHJcbiAgICAgIHZhbCA9ICh2YWwgfHwgJycpLnJlcGxhY2UoL14jLywgJycpO1xyXG4gICAgICByZXN1bHQgPSAodmFsLmxlbmd0aCA9PT0gMykgP1xyXG4gICAgICAgIFtcclxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDApLCAxNiksXHJcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpLFxyXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KVxyXG4gICAgICAgIF0gOlxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNiksXHJcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpLFxyXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCg0KSArIHZhbC5jaGFyQXQoNSksIDE2KVxyXG4gICAgICAgIF07XHJcbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XHJcbiAgICAgIHZhbCA9IHZhbC5tYXRjaChcclxuICAgICAgICAvXiAqcmdiYT8gKlxcKCAqKFswLTldKikgKiwgKihbMC05XSopICosICooWzAtOV0qKSAqKCwuKik/XFwpICokL1xyXG4gICAgICApO1xyXG4gICAgICByZXN1bHQgPSBbXHJcbiAgICAgICAgK3ZhbFsxXSxcclxuICAgICAgICArdmFsWzJdLFxyXG4gICAgICAgICt2YWxbM11cclxuICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBfY2FjaGVbdmFsXSA9IHtcclxuICAgICAgcjogcmVzdWx0WzBdLFxyXG4gICAgICBnOiByZXN1bHRbMV0sXHJcbiAgICAgIGI6IHJlc3VsdFsyXVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NhY2hlW3ZhbF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9ycyhjMSwgYzIsIHApIHtcclxuICAgIGMxID0gcGFyc2VDb2xvcihjMSk7XHJcbiAgICBjMiA9IHBhcnNlQ29sb3IoYzIpO1xyXG5cclxuICAgIHZhciBjID0ge1xyXG4gICAgICByOiBjMS5yICogKDEgLSBwKSArIGMyLnIgKiBwLFxyXG4gICAgICBnOiBjMS5nICogKDEgLSBwKSArIGMyLmcgKiBwLFxyXG4gICAgICBiOiBjMS5iICogKDEgLSBwKSArIGMyLmIgKiBwXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAncmdiKCcgKyBbYy5yIHwgMCwgYy5nIHwgMCwgYy5iIHwgMF0uam9pbignLCcpICsgJyknO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGFuaW1hdGUgc29tZSBzcGVjaWZpZWQgbm9kZSBwcm9wZXJ0aWVzLiBJdCB3aWxsXHJcbiAgICogYmFzaWNhbGx5IGNhbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBpbnRlcnBvbGF0ZSB0aGUgdmFsdWVzIGFuZCBjYWxsIHRoZVxyXG4gICAqIHJlZnJlc2ggbWV0aG9kIGR1cmluZyBhIHNwZWNpZmllZCBkdXJhdGlvbi5cclxuICAgKlxyXG4gICAqIEV2ZW50cyBmaXJlZCB0aG91Z2ggc2lnbWEgaW5zdGFuY2U6XHJcbiAgICogKioqKioqKioqKioqKlxyXG4gICAqIGFuaW1hdGUuc3RhcnQgIEZpcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgKiBhbmltYXRlLmVuZCAgICBGaXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XHJcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBzZXR0aW5nc1xyXG4gICAqIG9iamVjdDpcclxuICAgKlxyXG4gICAqICAgez9hcnJheX0gICAgICAgICAgICAgbm9kZXMgICAgICBBbiBhcnJheSBvZiBub2RlIG9iamVjdHMgb3Igbm9kZSBpZHMuIElmXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBzcGVjaWZpZWQsIGFsbCBub2RlcyBvZiB0aGUgZ3JhcGhcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBhbmltYXRlZC5cclxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncyBwYWNrYWdlIG9yIGFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNJbk91dCBlYXNpbmcgZnJvbSB0aGlzIHBhY2thZ2VcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBkdXJhdGlvbiAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiBJZiBub3RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCB0aGUgXCJhbmltYXRpb25zVGltZVwiIHNldHRpbmdcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgb2YgdGhlIHNpZ21hIGluc3RhbmNlIHdpbGwgYmUgdXNlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0ZWFkLlxyXG4gICAqICAgez9mdW5jdGlvbn0gICAgICAgICAgb25Db21wbGV0ZSBFdmVudHVhbGx5IGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24gaXMgZW5kZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzaWdtYX0gICBzICAgICAgIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGFuaW1hdGUgQW4gaGFzaCB3aXRoIHRoZSBrZXlzIGJlaW5nIHRoZSBub2RlIHByb3BlcnRpZXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGludGVycG9sYXRlLCBhbmQgdGhlIHZhbHVlcyBiZWluZyB0aGUgcmVsYXRlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0IHZhbHVlcy5cclxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cclxuICAgKi9cclxuICBzaWdtYS5wbHVnaW5zLmFuaW1hdGUgPSBmdW5jdGlvbihzLCBhbmltYXRlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbyA9IG9wdGlvbnMgfHwge30sXHJcbiAgICAgICAgaWQgPSArK19pZCxcclxuICAgICAgICBkdXJhdGlvbiA9IG8uZHVyYXRpb24gfHwgcy5zZXR0aW5ncygnYW5pbWF0aW9uc1RpbWUnKSxcclxuICAgICAgICBlYXNpbmcgPSB0eXBlb2Ygby5lYXNpbmcgPT09ICdzdHJpbmcnID9cclxuICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3Nbby5lYXNpbmddIDpcclxuICAgICAgICAgIHR5cGVvZiBvLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyA/XHJcbiAgICAgICAgICBvLmVhc2luZyA6XHJcbiAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luT3V0LFxyXG4gICAgICAgIHN0YXJ0ID0gc2lnbWEudXRpbHMuZGF0ZU5vdygpLFxyXG4gICAgICAgIG5vZGVzLFxyXG4gICAgICAgIHN0YXJ0UG9zaXRpb25zO1xyXG5cclxuICAgIGlmIChvLm5vZGVzICYmIG8ubm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygby5ub2Rlc1swXSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgbm9kZXMgPSBvLm5vZGVzO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbm9kZXMgPSBzLmdyYXBoLm5vZGVzKG8ubm9kZXMpOyAvLyBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBJRHNcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgbm9kZXMgPSBzLmdyYXBoLm5vZGVzKCk7XHJcblxyXG4gICAgLy8gU3RvcmUgaW5pdGlhbCBwb3NpdGlvbnM6XHJcbiAgICBzdGFydFBvc2l0aW9ucyA9IG5vZGVzLnJlZHVjZShmdW5jdGlvbihyZXMsIG5vZGUpIHtcclxuICAgICAgdmFyIGs7XHJcbiAgICAgIHJlc1tub2RlLmlkXSA9IHt9O1xyXG4gICAgICBmb3IgKGsgaW4gYW5pbWF0ZSlcclxuICAgICAgICBpZiAoayBpbiBub2RlKVxyXG4gICAgICAgICAgcmVzW25vZGUuaWRdW2tdID0gbm9kZVtrXTtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICBzLmFuaW1hdGlvbnMgPSBzLmFuaW1hdGlvbnMgfHwgT2JqZWN0LmNyZWF0ZSh7fSk7XHJcbiAgICBzaWdtYS5wbHVnaW5zLmtpbGxBbmltYXRlKHMpO1xyXG5cclxuICAgIHMuZGlzcGF0Y2hFdmVudCgnYW5pbWF0ZS5zdGFydCcpOyAvLyBzZW5kIGEgc2lnbWEgZXZlbnRcclxuXHJcbiAgICBmdW5jdGlvbiBzdGVwKCkge1xyXG4gICAgICB2YXIgcCA9IChzaWdtYS51dGlscy5kYXRlTm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbjtcclxuXHJcbiAgICAgIGlmIChwID49IDEpIHtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgIGZvciAodmFyIGsgaW4gYW5pbWF0ZSlcclxuICAgICAgICAgICAgaWYgKGsgaW4gYW5pbWF0ZSAmJiBhbmltYXRlW2tdIGluIG5vZGUpXHJcbiAgICAgICAgICAgICAgbm9kZVtrXSA9IG5vZGVbYW5pbWF0ZVtrXV07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHMucmVmcmVzaCh7c2tpcEluZGV4YXRpb246IHRydWV9KTtcclxuICAgICAgICBpZiAodHlwZW9mIG8ub25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgby5vbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMuZGlzcGF0Y2hFdmVudCgnYW5pbWF0ZS5lbmQnKTsgLy8gc2VuZCBhIHNpZ21hIGV2ZW50XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcCA9IGVhc2luZyhwKTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgIGZvciAodmFyIGsgaW4gYW5pbWF0ZSlcclxuICAgICAgICAgICAgaWYgKGsgaW4gYW5pbWF0ZSAmJiBhbmltYXRlW2tdIGluIG5vZGUpIHtcclxuICAgICAgICAgICAgICBpZiAoay5tYXRjaCgvY29sb3IkLykpXHJcbiAgICAgICAgICAgICAgICBub2RlW2tdID0gaW50ZXJwb2xhdGVDb2xvcnMoXHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25zW25vZGUuaWRdW2tdLFxyXG4gICAgICAgICAgICAgICAgICBub2RlW2FuaW1hdGVba11dLFxyXG4gICAgICAgICAgICAgICAgICBwXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG5vZGVba10gPVxyXG4gICAgICAgICAgICAgICAgICBub2RlW2FuaW1hdGVba11dICogcCArXHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25zW25vZGUuaWRdW2tdICogKDEgLSBwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzLnJlZnJlc2goe3NraXBJbmRleGF0aW9uOiB0cnVlfSk7XHJcbiAgICAgICAgcy5hbmltYXRpb25zW2lkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0ZXAoKTtcclxuICB9O1xyXG5cclxuICBzaWdtYS5wbHVnaW5zLmtpbGxBbmltYXRlID0gZnVuY3Rpb24ocykge1xyXG4gICAgZm9yICh2YXIgayBpbiAocy5hbmltYXRpb25zIHx8IHt9KSlcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocy5hbmltYXRpb25zW2tdKTtcclxuICB9O1xyXG59KS5jYWxsKHdpbmRvdyk7XHJcbiIsIi8qKlxyXG4gKiBUaGlzIHBsdWdpbiBwcm92aWRlcyBhIG1ldGhvZCB0byBkcmFnICYgZHJvcCBub2Rlcy4gQ2hlY2sgdGhlXHJcbiAqIHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzIGZ1bmN0aW9uIGRvYyBvciB0aGUgZXhhbXBsZXMvZHJhZy1ub2Rlcy5odG1sIGNvZGVcclxuICogc2FtcGxlIHRvIGtub3cgbW9yZS5cclxuICovXHJcbihmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucGx1Z2lucycpO1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBgbW91c2Vkb3duYCwgYG1vdXNldXBgICYgYG1vdXNlbW92ZWAgZXZlbnRzIHRvIHRoZVxyXG4gICAqIG5vZGVzIGluIHRoZSBgb3Zlck5vZGVgZXZlbnQgdG8gcGVyZm9ybSBkcmFnICYgZHJvcCBvcGVyYXRpb25zLiBJdCB1c2VzXHJcbiAgICogYGxpbmVhciBpbnRlcnBvbGF0aW9uYCBbaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvbl1cclxuICAgKiBhbmQgYHJvdGF0aW9uIG1hdHJpeGAgW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm90YXRpb25fbWF0cml4XSB0b1xyXG4gICAqIGNhbGN1bGF0ZSB0aGUgWCBhbmQgWSBjb29yZGluYXRlcyBmcm9tIHRoZSBgY2FtYCBvciBgcmVuZGVyZXJgIG5vZGVcclxuICAgKiBhdHRyaWJ1dGVzLiBUaGVzZSBhdHRyaWJ1dGVzIHJlcHJlc2VudCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVzIGluXHJcbiAgICogdGhlIHJlYWwgY29udGFpbmVyLCBub3QgaW4gY2FudmFzLlxyXG4gICAqXHJcbiAgICogRmlyZWQgZXZlbnRzOlxyXG4gICAqICoqKioqKioqKioqKipcclxuICAgKiBzdGFydGRyYWcgIEZpcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXHJcbiAgICogZHJhZyAgICAgICBGaXJlZCB3aGlsZSB0aGUgbm9kZSBpcyBkcmFnZ2VkLlxyXG4gICAqIGRyb3AgICAgICAgRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgZHJhZyBpZiB0aGUgbm9kZSBoYXMgYmVlbiBkcmFnZ2VkLlxyXG4gICAqIGRyYWdlbmQgICAgRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgZHJhZy5cclxuICAgKlxyXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICogQHBhcmFtICB7c2lnbWF9ICAgICAgICAgICAgICAgICAgICAgIHMgICAgICAgIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSAge3JlbmRlcmVyfSAgICAgICAgICAgICAgICAgICByZW5kZXJlciBUaGUgcmVsYXRlZCByZW5kZXJlciBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gIHs/c2lnbWEucGx1Z2lucy5hY3RpdmVTdGF0ZX0gYSAgICAgICAgVGhlIGFjdGl2ZVN0YXRlIHBsdWdpbiBpbnN0YW5jZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBEcmFnTm9kZXMocywgcmVuZGVyZXIsIGEpIHtcclxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XHJcblxyXG4gICAgLy8gQSBxdWljayBoYXJkY29kZWQgcnVsZSB0byBwcmV2ZW50IHBlb3BsZSBmcm9tIHVzaW5nIHRoaXMgcGx1Z2luIHdpdGggdGhlXHJcbiAgICAvLyBXZWJHTCByZW5kZXJlciAod2hpY2ggaXMgaW1wb3NzaWJsZSBhdCB0aGUgbW9tZW50KTpcclxuICAgIGlmIChcclxuICAgICAgc2lnbWEucmVuZGVyZXJzLndlYmdsICYmXHJcbiAgICAgIHJlbmRlcmVyIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLndlYmdsXHJcbiAgICApXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnVGhlIHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFdlYkdMIHJlbmRlcmVyJ1xyXG4gICAgICApO1xyXG5cclxuICAgIC8vIEluaXQgdmFyaWFibGVzOlxyXG4gICAgdmFyIF9zZWxmID0gdGhpcyxcclxuICAgICAgX3MgPSBzLFxyXG4gICAgICBfYSA9IGEsXHJcbiAgICAgIF9ib2R5ID0gZG9jdW1lbnQuYm9keSxcclxuICAgICAgX3JlbmRlcmVyID0gcmVuZGVyZXIsXHJcbiAgICAgIF9tb3VzZSA9IHJlbmRlcmVyLmNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzaWdtYS1tb3VzZScpWzBdLFxyXG4gICAgICBfcHJlZml4ID0gcmVuZGVyZXIub3B0aW9ucy5wcmVmaXgsXHJcbiAgICAgIF9ub2RlID0gbnVsbCxcclxuICAgICAgX2RyYWdnaW5nTm9kZSA9IG51bGwsXHJcbiAgICAgIF9ob3ZlcmVkTm9kZSA9IG51bGwsXHJcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlLFxyXG4gICAgICBfaXNNb3VzZU92ZXJDYW52YXMgPSBmYWxzZSxcclxuICAgICAgX2RyYWcgPSBmYWxzZSxcclxuICAgICAgX3N0aWNreSA9IHRydWUsXHJcbiAgICAgIF9lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAocmVuZGVyZXIgaW5zdGFuY2VvZiBzaWdtYS5yZW5kZXJlcnMuc3ZnKSB7XHJcbiAgICAgICAgX21vdXNlID0gcmVuZGVyZXIuY29udGFpbmVyLmZpcnN0Q2hpbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyZXIuYmluZCgnaG92ZXJzJywgbm9kZU1vdXNlT3Zlcik7XHJcbiAgICByZW5kZXJlci5iaW5kKCdob3ZlcnMnLCB0cmVhdE91dE5vZGUpO1xyXG4gICAgcmVuZGVyZXIuYmluZCgnY2xpY2snLCBjbGljayk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgZHJhZ2dpbmcgYW5kIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2VuYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZSBkcmFnZ2luZyBhbmQgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgX25vZGUgPSBudWxsLFxyXG4gICAgICBfZHJhZ2dpbmdOb2RlID0gbnVsbCxcclxuICAgICAgX2hvdmVyZWROb2RlID0gbnVsbDtcclxuICAgICAgX2lzTW91c2VEb3duID0gZmFsc2UsXHJcbiAgICAgIF9pc01vdXNlT3ZlckNhbnZhcyA9IGZhbHNlLFxyXG4gICAgICBfZHJhZyA9IGZhbHNlLFxyXG4gICAgICBfc3RpY2t5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuYmluZCBhbGwgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnVuYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XHJcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG5vZGVNb3VzZU1vdmUpO1xyXG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xyXG4gICAgICBfcmVuZGVyZXIudW5iaW5kKCdob3ZlcnMnLCBub2RlTW91c2VPdmVyKTtcclxuICAgICAgX3JlbmRlcmVyLnVuYmluZCgnaG92ZXJzJywgdHJlYXRPdXROb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50IG1vcmUgYWNjdXJhdGVseSB0aGFuXHJcbiAgICAvLyBlbGVtZW50Lm9mZnNldFRvcCBhbmQgZWxlbWVudC5vZmZzZXRMZWZ0LlxyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KGVsZW1lbnQpIHtcclxuICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgICAgIHZhciBnZXRDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKS5yZXBsYWNlKCdweCcsICcnKSkgfHwgMDtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBnZXRDc3NQcm9wZXJ0eSgncGFkZGluZy1sZWZ0JyksXHJcbiAgICAgICAgdG9wOiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIGdldENzc1Byb3BlcnR5KCdwYWRkaW5nLXRvcCcpXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XHJcbiAgICAgIC8vIGV2ZW50IHRyaWdnZXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBjbGlja1xyXG4gICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XHJcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XHJcblxyXG4gICAgICBpZiAoIV9ob3ZlcmVkTm9kZSkge1xyXG4gICAgICAgIF9ub2RlID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBEcmFnIG5vZGUgcmlnaHQgYWZ0ZXIgY2xpY2sgaW5zdGVhZCBvZiBuZWVkaW5nIG1vdXNlIG91dCArIG1vdXNlIG92ZXI6XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBub2RlIHRvIGJlIHRoZSBsYXN0IGhvdmVyZWQgbm9kZVxyXG4gICAgICAgICAgX25vZGUgPSBfaG92ZXJlZE5vZGU7XHJcbiAgICAgICAgICBfbW91c2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlT3ZlcihldmVudCkge1xyXG4gICAgICBpZiAoZXZlbnQuZGF0YS5lbnRlci5ub2Rlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbiA9IGV2ZW50LmRhdGEuZW50ZXIubm9kZXNbMF07XHJcblxyXG4gICAgICAvLyBEb24ndCB0cmVhdCB0aGUgbm9kZSBpZiBpdCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcclxuICAgICAgaWYgKF9ob3ZlcmVkTm9kZSAmJiBfaG92ZXJlZE5vZGUuaWQgPT09IG4uaWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCByZWZlcmVuY2UgdG8gdGhlIGhvdmVyZWQgbm9kZVxyXG4gICAgICBfaG92ZXJlZE5vZGUgPSBuO1xyXG5cclxuICAgICAgaWYoIV9pc01vdXNlRG93bikge1xyXG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBub2RlIHRvIGJlIHRoZSBsYXN0IGhvdmVyZWQgbm9kZVxyXG4gICAgICAgIF9ub2RlID0gX2hvdmVyZWROb2RlO1xyXG4gICAgICAgIF9tb3VzZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiB0cmVhdE91dE5vZGUoZXZlbnQpIHtcclxuICAgICAgaWYgKGV2ZW50LmRhdGEubGVhdmUubm9kZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG4gPSBldmVudC5kYXRhLmxlYXZlLm5vZGVzWzBdO1xyXG5cclxuICAgICAgaWYgKF9ob3ZlcmVkTm9kZSAmJiBfaG92ZXJlZE5vZGUuaWQgPT09IG4uaWQpIHtcclxuICAgICAgICBfaG92ZXJlZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIF9ub2RlID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICghX2hvdmVyZWROb2RlKSB7XHJcbiAgICAgICAgX21vdXNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZURvd24oZXZlbnQpIHtcclxuICAgICAgaWYoIV9lbmFibGVkIHx8IGV2ZW50LndoaWNoID09IDMpIHJldHVybjsgLy8gUmlnaHQgbW91c2UgYnV0dG9uIHByZXNzZWRcclxuXHJcbiAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XHJcbiAgICAgIGlmIChfbm9kZSAmJiBfcy5ncmFwaC5ub2RlcygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBfc3RpY2t5ID0gdHJ1ZTtcclxuICAgICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XHJcbiAgICAgICAgX2JvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XHJcbiAgICAgICAgX2JvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG5vZGVNb3VzZVVwKTtcclxuXHJcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSBkcmFnIGdyYXBoLlxyXG4gICAgICAgIF9yZW5kZXJlci5zZXR0aW5ncyh7bW91c2VFbmFibGVkOiBmYWxzZSwgZW5hYmxlSG92ZXJpbmc6IGZhbHNlfSk7XHJcblxyXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ3N0YXJ0ZHJhZycsIHtcclxuICAgICAgICAgIG5vZGU6IF9ub2RlLFxyXG4gICAgICAgICAgY2FwdG9yOiBldmVudCxcclxuICAgICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBub2RlTW91c2VVcChldmVudCkge1xyXG4gICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgX21vdXNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xyXG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBub2RlTW91c2VNb3ZlKTtcclxuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG5vZGVNb3VzZVVwKTtcclxuXHJcbiAgICAgIC8vIEFjdGl2YXRlIGRyYWcgZ3JhcGguXHJcbiAgICAgIF9yZW5kZXJlci5zZXR0aW5ncyh7bW91c2VFbmFibGVkOiB0cnVlLCBlbmFibGVIb3ZlcmluZzogdHJ1ZX0pO1xyXG5cclxuICAgICAgaWYgKF9kcmFnKSB7XHJcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJvcCcsIHtcclxuICAgICAgICAgIG5vZGU6IF9kcmFnZ2luZ05vZGUsXHJcbiAgICAgICAgICBjYXB0b3I6IGV2ZW50LFxyXG4gICAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZihfYSkge1xyXG4gICAgICAgICAgdmFyIGFjdGl2ZU5vZGVzID0gX2Eubm9kZXMoKTtcclxuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhY3RpdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhY3RpdmVOb2Rlc1tpXS5hbHBoYVggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGFjdGl2ZU5vZGVzW2ldLmFscGhhWSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9zLnJlZnJlc2goKTtcclxuICAgICAgfVxyXG4gICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnZW5kJywge1xyXG4gICAgICAgIG5vZGU6IF9ub2RlLFxyXG4gICAgICAgIGNhcHRvcjogZXZlbnQsXHJcbiAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIF9kcmFnID0gZmFsc2U7XHJcbiAgICAgIF9kcmFnZ2luZ05vZGUgPSBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBub2RlTW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAgIGlmKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAtMSkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lT3V0KTtcclxuICAgICAgICB2YXIgdGltZU91dCA9IHNldFRpbWVvdXQoZXhlY3V0ZU5vZGVNb3VzZU1vdmUsIDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGV4ZWN1dGVOb2RlTW91c2VNb3ZlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVOb2RlTW91c2VNb3ZlKCkge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSBjYWxjdWxhdGVPZmZzZXQoX3JlbmRlcmVyLmNvbnRhaW5lciksXHJcbiAgICAgICAgICAgIHggPSBldmVudC5jbGllbnRYIC0gb2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgICAgIHkgPSBldmVudC5jbGllbnRZIC0gb2Zmc2V0LnRvcCxcclxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoX3JlbmRlcmVyLmNhbWVyYS5hbmdsZSksXHJcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKF9yZW5kZXJlci5jYW1lcmEuYW5nbGUpLFxyXG4gICAgICAgICAgICBub2RlcyA9IF9zLmdyYXBoLm5vZGVzKCksXHJcbiAgICAgICAgICAgIHJlZiA9IFtdLFxyXG4gICAgICAgICAgICB4MixcclxuICAgICAgICAgICAgeTIsXHJcbiAgICAgICAgICAgIGFjdGl2ZU5vZGVzLFxyXG4gICAgICAgICAgICBuLFxyXG4gICAgICAgICAgICBhdXgsXHJcbiAgICAgICAgICAgIGlzSG92ZXJlZE5vZGVBY3RpdmUsXHJcbiAgICAgICAgICAgIGRpc3Q7XHJcblxyXG4gICAgICAgIGlmIChfYSAmJiBfYS5uYk5vZGVzKCkgPT09IG5vZGVzLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIV9lbmFibGVkIHx8IG5vZGVzLmxlbmd0aCA8IDIpIHJldHVybjtcclxuXHJcbiAgICAgICAgZGlzdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIF9ub2RlW19wcmVmaXggKyAneCddLF9ub2RlW19wcmVmaXggKyAneSddKTtcclxuXHJcbiAgICAgICAgaWYgKF9zdGlja3kgJiYgZGlzdCA8IF9ub2RlW19wcmVmaXggKyAnc2l6ZSddKSByZXR1cm47XHJcbiAgICAgICAgX3N0aWNreSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHR3byByZWZlcmVuY2UgcG9pbnRzIGFuZCBkZXJvdGF0ZSB0aGVtXHJcbiAgICAgICAgLy8gV2UgdGFrZSB0aGUgZmlyc3Qgbm9kZSBhcyBhIGZpcnN0IHJlZmVyZW5jZSBwb2ludCBhbmQgdGhlbiB0cnkgdG8gZmluZFxyXG4gICAgICAgIC8vIGFub3RoZXIgbm9kZSBub3QgYWxpZ25lZCB3aXRoIGl0XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7O2krKykge1xyXG4gICAgICAgICAgaWYoIV9lbmFibGVkKSBicmVhaztcclxuXHJcbiAgICAgICAgICBuID0gbm9kZXNbaV07XHJcbiAgICAgICAgICBpZiAobikge1xyXG4gICAgICAgICAgICBhdXggPSB7XHJcbiAgICAgICAgICAgICAgeDogbi54ICogY29zICsgbi55ICogc2luLFxyXG4gICAgICAgICAgICAgIHk6IG4ueSAqIGNvcyAtIG4ueCAqIHNpbixcclxuICAgICAgICAgICAgICByZW5YOiBuW19wcmVmaXggKyAneCddLCAvL3JlbmRlcmVyIFhcclxuICAgICAgICAgICAgICByZW5ZOiBuW19wcmVmaXggKyAneSddLCAvL3JlbmRlcmVyIFlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVmLnB1c2goYXV4KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGkgPT0gbm9kZXMubGVuZ3RoIC0gMSkgeyAvL3dlIHRyaWVkIGFsbCBub2Rlc1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWZbMF0ueCA9PSByZWZbMV0ueCB8fCByZWZbMF0ueSA9PSByZWZbMV0ueSkge1xyXG4gICAgICAgICAgICAgIHJlZi5wb3AoKSAvLyBkcm9wIGxhc3Qgbm9kZXMgYW5kIHRyeSB0byBmaW5kIGFub3RoZXIgb25lXHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHdlIG1hbmFnZWQgdG8gZmluZCB0d28gbm9kZXMgbm90IGFsaWduZWRcclxuICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYSA9IHJlZlswXSwgYiA9IHJlZlsxXTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHlpbmcgbGluZWFyIGludGVycG9sYXRpb24uXHJcbiAgICAgICAgdmFyIGRpdnggPSAoYi5yZW5YIC0gYS5yZW5YKTtcclxuICAgICAgICBpZiAoZGl2eCA9PT0gMCkgZGl2eCA9IDE7IC8vZml4IGVkZ2UgY2FzZSB3aGVyZSBheGlzIGFyZSBhbGlnbmVkXHJcblxyXG4gICAgICAgIHZhciBkaXZ5ID0gKGIucmVuWSAtIGEucmVuWSk7XHJcbiAgICAgICAgaWYgKGRpdnkgPT09IDApIGRpdnkgPSAxOyAvL2ZpeCBlZGdlIGNhc2Ugd2hlcmUgYXhpcyBhcmUgYWxpZ25lZFxyXG5cclxuICAgICAgICB4ID0gKCh4IC0gYS5yZW5YKSAvIGRpdngpICogKGIueCAtIGEueCkgKyBhLng7XHJcbiAgICAgICAgeSA9ICgoeSAtIGEucmVuWSkgLyBkaXZ5KSAqIChiLnkgLSBhLnkpICsgYS55O1xyXG5cclxuICAgICAgICB4MiA9IHggKiBjb3MgLSB5ICogc2luO1xyXG4gICAgICAgIHkyID0geSAqIGNvcyArIHggKiBzaW47XHJcblxyXG4gICAgICAgIC8vIERyYWcgbXVsdGlwbGUgbm9kZXMsIEtlZXAgZGlzdGFuY2VcclxuICAgICAgICBpZihfYSkge1xyXG4gICAgICAgICAgYWN0aXZlTm9kZXMgPSBfYS5ub2RlcygpO1xyXG5cclxuICAgICAgICAgIC8vIElmIGhvdmVyZWQgbm9kZSBpcyBhY3RpdmUsIGRyYWcgYWN0aXZlIG5vZGVzXHJcbiAgICAgICAgICBpc0hvdmVyZWROb2RlQWN0aXZlID0gKC0xIDwgYWN0aXZlTm9kZXMubWFwKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQ7XHJcbiAgICAgICAgICB9KS5pbmRleE9mKF9ub2RlLmlkKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGlzSG92ZXJlZE5vZGVBY3RpdmUpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFjdGl2ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgLy8gRGVsZXRlIG9sZCByZWZlcmVuY2VcclxuICAgICAgICAgICAgICBpZihfZHJhZ2dpbmdOb2RlICE9IF9ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVOb2Rlc1tpXS5hbHBoYVggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVOb2Rlc1tpXS5hbHBoYVkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWwgZmlyc3QgcG9zaXRpb24gb2YgYWN0aXZlTm9kZXNcclxuICAgICAgICAgICAgICBpZighYWN0aXZlTm9kZXNbaV0uYWxwaGFYIHx8ICFhY3RpdmVOb2Rlc1tpXS5hbHBoYVkpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZU5vZGVzW2ldLmFscGhhWCA9IGFjdGl2ZU5vZGVzW2ldLnggLSB4O1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlTm9kZXNbaV0uYWxwaGFZID0gYWN0aXZlTm9kZXNbaV0ueSAtIHk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBNb3ZlIGFjdGl2ZU5vZGVzIHRvIGtlZXAgc2FtZSBkaXN0YW5jZSBiZXR3ZWVuIGRyYWdnZWQgbm9kZXNcclxuICAgICAgICAgICAgICAvLyBhbmQgYWN0aXZlIG5vZGVzXHJcbiAgICAgICAgICAgICAgYWN0aXZlTm9kZXNbaV0ueCA9IF9ub2RlLnggKyBhY3RpdmVOb2Rlc1tpXS5hbHBoYVg7XHJcbiAgICAgICAgICAgICAgYWN0aXZlTm9kZXNbaV0ueSA9IF9ub2RlLnkgKyBhY3RpdmVOb2Rlc1tpXS5hbHBoYVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJvdGF0aW5nIHRoZSBjb29yZGluYXRlcy5cclxuICAgICAgICBfbm9kZS54ID0geDI7XHJcbiAgICAgICAgX25vZGUueSA9IHkyO1xyXG5cclxuICAgICAgICBfcy5yZWZyZXNoKHtza2lwSW5kZXhhdGlvbjogdHJ1ZX0pO1xyXG5cclxuICAgICAgICBfZHJhZyA9IHRydWU7XHJcbiAgICAgICAgX2RyYWdnaW5nTm9kZSA9IF9ub2RlO1xyXG5cclxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJywge1xyXG4gICAgICAgICAgbm9kZTogX2RyYWdnaW5nTm9kZSxcclxuICAgICAgICAgIGNhcHRvcjogZXZlbnQsXHJcbiAgICAgICAgICByZW5kZXJlcjogX3JlbmRlcmVyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICpcclxuICAgKiA+IHZhciBkcmFnTm9kZXNMaXN0ZW5lciA9IHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzKHMsIHMucmVuZGVyZXJzWzBdLCBhKTtcclxuICAgKi9cclxuICB2YXIgX2luc3RhbmNlID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hfSAgICAgICAgICAgICAgICAgICAgICBzICAgICAgICBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gIHtyZW5kZXJlcn0gICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgVGhlIHJlbGF0ZWQgcmVuZGVyZXIgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtICB7P3NpZ21hLnBsdWdpbnMuYWN0aXZlU3RhdGV9IGEgICAgICAgIFRoZSBhY3RpdmVTdGF0ZSBwbHVnaW4gaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMgPSBmdW5jdGlvbihzLCByZW5kZXJlciwgYSkge1xyXG4gICAgLy8gQ3JlYXRlIG9iamVjdCBpZiB1bmRlZmluZWRcclxuICAgIGlmICghX2luc3RhbmNlW3MuaWRdKSB7XHJcbiAgICAgIC8vIEhhbmRsZSBkcmFnIGV2ZW50czpcclxuICAgICAgX2luc3RhbmNlW3MuaWRdID0gbmV3IERyYWdOb2RlcyhzLCByZW5kZXJlciwgYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcy5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNpZ21hLnBsdWdpbnMua2lsbERyYWdOb2RlcyhzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGRpc2FibGUgb24gcGx1Z2lucy5hbmltYXRlIHN0YXJ0LlxyXG4gICAgcy5iaW5kKCdhbmltYXRlLnN0YXJ0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIF9pbnN0YW5jZVtzLmlkXS5kaXNhYmxlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBlbmFibGUgb24gcGx1Z2lucy5hbmltYXRlIGVuZC5cclxuICAgIHMuYmluZCgnYW5pbWF0ZS5lbmQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgX2luc3RhbmNlW3MuaWRdLmVuYWJsZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIF9pbnN0YW5jZVtzLmlkXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCByZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgYW5kIGtpbGxzIHRoZSBkcmFnTm9kZXMgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzaWdtYX0gcyBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5wbHVnaW5zLmtpbGxEcmFnTm9kZXMgPSBmdW5jdGlvbihzKSB7XHJcbiAgICBpZiAoX2luc3RhbmNlW3MuaWRdIGluc3RhbmNlb2YgRHJhZ05vZGVzKSB7XHJcbiAgICAgIF9pbnN0YW5jZVtzLmlkXS51bmJpbmRBbGwoKTtcclxuICAgICAgZGVsZXRlIF9pbnN0YW5jZVtzLmlkXTtcclxuICAgIH1cclxuICB9O1xyXG5cclxufSkuY2FsbCh3aW5kb3cpO1xyXG4iLCI7KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcclxuXHJcbiAgdmFyIGRyYXdCb3JkZXIgPSBmdW5jdGlvbihjb250ZXh0LCB4LCB5LCByYWRpdXMsIGNvbG9yLCBsaW5lX3dpZHRoKSB7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG5cdCAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lX3dpZHRoO1xyXG4gICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICAgICBvcHRpb25zICBGb3JjZSBvcHRpb25hbCBwYXJhbWV0ZXJzIChlLmcuIGNvbG9yKS5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMubm9kZXMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcclxuICAgIHZhciBvID0gb3B0aW9ucyB8fCB7fSxcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIHggPSBub2RlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgeSA9IG5vZGVbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBpbWdDcm9zc09yaWdpbiA9IHNldHRpbmdzKCdpbWdDcm9zc09yaWdpbicpIHx8ICdhbm9ueW1vdXMnLFxyXG4gICAgICAgIGJvcmRlclNpemUgPSBub2RlLmJvcmRlcl9zaXplIHx8IHNldHRpbmdzKCdub2RlQm9yZGVyU2l6ZScpLFxyXG4gICAgICAgIG91dGVyQm9yZGVyU2l6ZSA9IHNldHRpbmdzKCdub2RlT3V0ZXJCb3JkZXJTaXplJyksXHJcbiAgICAgICAgYWN0aXZlQm9yZGVyU2l6ZSA9IG5vZGUuYm9yZGVyX3NpemUgfHwgc2V0dGluZ3MoJ25vZGVBY3RpdmVCb3JkZXJTaXplJyksXHJcbiAgICAgICAgYWN0aXZlT3V0ZXJCb3JkZXJTaXplID0gc2V0dGluZ3MoJ25vZGVBY3RpdmVPdXRlckJvcmRlclNpemUnKSxcclxuICAgICAgICBjb2xvciA9IG8uY29sb3IgfHwgbm9kZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yLFxyXG5cdCAgICAgIGJvcmRlckNvbG9yID0gc2V0dGluZ3MoJ25vZGVCb3JkZXJDb2xvcicpID09PSAnZGVmYXVsdCdcclxuICAgICAgICAgID8gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQm9yZGVyQ29sb3InKVxyXG4gICAgICAgICAgOiAoby5ib3JkZXJDb2xvciB8fCBub2RlLmJvcmRlcl9jb2xvciB8fCBub2RlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3IpLFxyXG4gICAgICAgIGxldmVsID0gbm9kZS5hY3RpdmUgPyBzZXR0aW5ncygnbm9kZUFjdGl2ZUxldmVsJykgOiBub2RlLmxldmVsO1xyXG5cclxuICAgIC8vIExldmVsOlxyXG4gICAgc2lnbWEudXRpbHMuY2FudmFzLnNldExldmVsKGxldmVsLCBjb250ZXh0KTtcclxuXHJcbiAgICBpZiAobm9kZS5hY3RpdmUpIHtcclxuICAgICAgLy8gQ29sb3I6XHJcbiAgICAgIGlmIChzZXR0aW5ncygnbm9kZUFjdGl2ZUNvbG9yJykgPT09ICdub2RlJykge1xyXG4gICAgICAgIGNvbG9yID0gbm9kZS5hY3RpdmVfY29sb3IgfHwgY29sb3I7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVBY3RpdmVDb2xvcicpIHx8IGNvbG9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPdXRlciBCb3JkZXI6XHJcbiAgICAgIGlmIChhY3RpdmVPdXRlckJvcmRlclNpemUgPiAwKSB7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdub2RlQWN0aXZlT3V0ZXJCb3JkZXJDb2xvcicpID09PSAnbm9kZScgP1xyXG4gICAgICAgICAgKGNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3IpIDpcclxuICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0Tm9kZUFjdGl2ZU91dGVyQm9yZGVyQ29sb3InKTtcclxuICAgICAgICBjb250ZXh0LmFyYyh4LCB5LCBzaXplICsgYWN0aXZlQm9yZGVyU2l6ZSArIGFjdGl2ZU91dGVyQm9yZGVyU2l6ZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQm9yZGVyOlxyXG4gICAgICBpZiAoYWN0aXZlQm9yZGVyU2l6ZSA+IDApIHtcclxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MoJ25vZGVBY3RpdmVCb3JkZXJDb2xvcicpID09PSAnbm9kZSdcclxuICAgICAgICAgID8gYm9yZGVyQ29sb3JcclxuICAgICAgICAgIDogc2V0dGluZ3MoJ2RlZmF1bHROb2RlQWN0aXZlQm9yZGVyQ29sb3InKTtcclxuICAgICAgICBjb250ZXh0LmFyYyh4LCB5LCBzaXplICsgYWN0aXZlQm9yZGVyU2l6ZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBPdXRlciBCb3JkZXI6XHJcbiAgICAgIGlmIChvdXRlckJvcmRlclNpemUgPiAwKSB7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdub2RlT3V0ZXJCb3JkZXJDb2xvcicpID09PSAnbm9kZScgP1xyXG4gICAgICAgICAgKGNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3IpIDpcclxuICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0Tm9kZU91dGVyQm9yZGVyQ29sb3InKTtcclxuICAgICAgICBjb250ZXh0LmFyYyh4LCB5LCBzaXplICsgYm9yZGVyU2l6ZSArIG91dGVyQm9yZGVyU2l6ZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJvcmRlcjpcclxuICAgICAgaWYgKGJvcmRlclNpemUgPiAwKSB7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdub2RlQm9yZGVyQ29sb3InKSA9PT0gJ25vZGUnXHJcbiAgICAgICAgICA/IGJvcmRlckNvbG9yXHJcbiAgICAgICAgICA6IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUJvcmRlckNvbG9yJyk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSArIGJvcmRlclNpemUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCghbm9kZS5hY3RpdmUgfHxcclxuICAgICAgKG5vZGUuYWN0aXZlICYmIHNldHRpbmdzKCdub2RlQWN0aXZlQ29sb3InKSA9PT0gJ25vZGUnKSkgJiZcclxuICAgICAgbm9kZS5jb2xvcnMgJiZcclxuICAgICAgbm9kZS5jb2xvcnMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAvLyBzZWUgaHR0cDovL2pzZmlkZGxlLm5ldC9odllrTS8xL1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICAgIGwgPSBub2RlLmNvbG9ycy5sZW5ndGgsXHJcbiAgICAgICAgICBqID0gMSAvIGwsXHJcbiAgICAgICAgICBsYXN0ZW5kID0gMDtcclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG5vZGUuY29sb3JzW2ldO1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSwgbGFzdGVuZCwgbGFzdGVuZCArIChNYXRoLlBJICogMiAqIGopLCBmYWxzZSk7XHJcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcclxuICAgICAgICBsYXN0ZW5kICs9IE1hdGguUEkgKiAyICogajtcclxuICAgICAgfVxyXG4gICAgICBzaWdtYS51dGlscy5jYW52YXMucmVzZXRMZXZlbChjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCBzaXplLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XHJcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG5cclxuICAgICAgc2lnbWEudXRpbHMuY2FudmFzLnJlc2V0TGV2ZWwoY29udGV4dCk7XHJcblxyXG4gICAgICBpZiAoIW5vZGUuYWN0aXZlICYmIGJvcmRlclNpemUgPiAwICYmIChzaXplID4gMiAqIGJvcmRlclNpemUpKSB7XHJcblx0XHQgICAgZHJhd0JvcmRlcihjb250ZXh0LCB4LCB5LCBzaXplLCBib3JkZXJDb2xvciwgYm9yZGVyU2l6ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJbWFnZTpcclxuICAgIGlmIChub2RlLmltYWdlKSB7XHJcbiAgICAgIHNpZ21hLnV0aWxzLmNhbnZhcy5kcmF3SW1hZ2UoXHJcbiAgICAgICAgbm9kZSwgeCwgeSwgc2l6ZSwgY29udGV4dCwgaW1nQ3Jvc3NPcmlnaW4sIHNldHRpbmdzKCdpbWFnZVRocmVzaG9sZCcpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWNvbjpcclxuICAgIGlmIChub2RlLmljb24pIHtcclxuICAgICAgc2lnbWEudXRpbHMuY2FudmFzLmRyYXdJY29uKG5vZGUsIHgsIHksIHNpemUsIGNvbnRleHQsIHNldHRpbmdzKCdpY29uVGhyZXNob2xkJykpO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG59KSgpO1xyXG4iLCI7KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9faW5zdGFuY2VzID0ge307XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHNpZ21hIGluc3RhbmNlcyBjb25zdHJ1Y3Rvci4gT25lIGluc3RhbmNlIG9mIHNpZ21hIHJlcHJlc2VudFxuICAgKiBvbmUgZ3JhcGguIEl0IGlzIHBvc3NpYmxlIHRvIHJlcHJlc2VudCB0aGlzIGdyYXDEpSB3aXRoIHNldmVyYWwgcmVuZGVyZXJzXG4gICAqIGF0IHRoZSBzYW1lIHRpbWUuIEJ5IGRlZmF1bHQsIHRoZSBkZWZhdWx0IHJlbmRlcmVyIChXZWJHTCArIENhbnZhc1xuICAgKiBwb2x5ZmlsbCkgd2lsbCBiZSB1c2VkIGFzIHRoZSBvbmx5IHJlbmRlcmVyLCB3aXRoIHRoZSBjb250YWluZXIgc3BlY2lmaWVkXG4gICAqIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/Kn0gICAgY29uZiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgaW5zdGFuY2UuIFRoZXJlIGFyZSBhIGxvdCBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbnQgcmVjb2duaXplZCBmb3JtcyB0byBpbnN0YW50aWF0ZSBzaWdtYSwgY2hlY2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgZXhhbXBsZSBmaWxlcywgZG9jdW1lbnRhdGlvbiBpbiB0aGlzIGZpbGUgYW5kIHVuaXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgdGVzdHMgdG8ga25vdyBtb3JlLlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICBUaGUgZnJlc2ggbmV3IHNpZ21hIGluc3RhbmNlLlxuICAgKlxuICAgKiBJbnN0YW5jaWF0aW5nIHNpZ21hOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgKiBJZiBubyBwYXJhbWV0ZXIgaXMgZ2l2ZW4gdG8gdGhlIGNvbnN0cnVjdG9yLCB0aGUgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAqIHdpdGhvdXQgYW55IHJlbmRlcmVyIG9yIGNhbWVyYS4gSXQgd2lsbCBqdXN0IGluc3RhbnRpYXRlIHRoZSBncmFwaCwgYW5kXG4gICAqIG90aGVyIG1vZHVsZXMgd2lsbCBoYXZlIHRvIGJlIGluc3RhbnRpYXRlZCB0aHJvdWdoIHRoZSBwdWJsaWMgbWV0aG9kcyxcbiAgICogbGlrZSBcImFkZFJlbmRlcmVyXCIgZXRjOlxuICAgKlxuICAgKiAgPiBzMCA9IG5ldyBzaWdtYSgpO1xuICAgKiAgPiBzMC5hZGRSZW5kZXJlcih7XG4gICAqICA+ICAgdHlwZTogJ2NhbnZhcycsXG4gICAqICA+ICAgY29udGFpbmVyOiAnbXktY29udGFpbmVyLWlkJ1xuICAgKiAgPiB9KTtcbiAgICpcbiAgICogSW4gbW9zdCBvZiB0aGUgY2FzZXMsIHNpZ21hIHdpbGwgc2ltcGx5IGJlIHVzZWQgd2l0aCB0aGUgZGVmYXVsdCByZW5kZXJlci5cbiAgICogVGhlbiwgc2luY2UgdGhlIG9ubHkgcmVxdWlyZWQgcGFyYW1ldGVyIGlzIHRoZSBET00gY29udGFpbmVyLCB0aGVyZSBhcmVcbiAgICogc29tZSBzaW1wbGVyIHdheSB0byBjYWxsIHRoZSBjb25zdHJ1Y3Rvci4gVGhlIGZvdXIgZm9sbG93aW5nIGNhbGxzIGRvIHRoZVxuICAgKiBleGFjdCBzYW1lIHRoaW5nczpcbiAgICpcbiAgICogID4gczEgPSBuZXcgc2lnbWEoJ215LWNvbnRhaW5lci1pZCcpO1xuICAgKiAgPiBzMiA9IG5ldyBzaWdtYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJykpO1xuICAgKiAgPiBzMyA9IG5ldyBzaWdtYSh7XG4gICAqICA+ICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJylcbiAgICogID4gfSk7XG4gICAqICA+IHM0ID0gbmV3IHNpZ21hKHtcbiAgICogID4gICByZW5kZXJlcnM6IFt7XG4gICAqICA+ICAgICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1jb250YWluZXItaWQnKVxuICAgKiAgPiAgIH1dXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMsIHdoZW4gY2FsbGluZyB0aGVcbiAgICogY29uc3RydWN0b3Igd2l0aCB0byB0b3AgbGV2ZWwgY29uZmlndXJhdGlvbiBvYmplY3QgKGZvdXJ0aCBjYXNlIGluIHRoZVxuICAgKiBwcmV2aW91cyBleGFtcGxlcyk6XG4gICAqXG4gICAqICAgez9zdHJpbmd9IGlkICAgICAgICBUaGUgaWQgb2YgdGhlIGluc3RhbmNlLiBJdCB3aWxsIGJlIGdlbmVyYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBpZiBub3Qgc3BlY2lmaWVkLlxuICAgKiAgIHs/YXJyYXl9ICByZW5kZXJlcnMgQW4gYXJyYXkgY29udGFpbmluZyBvYmplY3RzIGRlc2NyaWJpbmcgcmVuZGVyZXJzLlxuICAgKiAgIHs/b2JqZWN0fSBncmFwaCAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2Ygbm9kZXMgYW5kIGFuIGFycmF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICBvZiBlZGdlcywgdG8gYXZvaWQgaGF2aW5nIHRvIGFkZCB0aGVtIGJ5IGhhbmQgbGF0ZXIuXG4gICAqICAgez9vYmplY3R9IHNldHRpbmdzICBBbiBvYmplY3QgY29udGFpbmluZyBpbnN0YW5jZSBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9uZXMgZGVmaW5lZCBpbiB0aGUgb2JqZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICBzaWdtYS5zZXR0aW5ncy5cbiAgICovXG4gIHZhciBzaWdtYSA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICAvLyBMb2NhbCB2YXJpYWJsZXM6XG4gICAgLy8gKioqKioqKioqKioqKioqKlxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBjLFxuICAgICAgICBvLFxuICAgICAgICBpZDtcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBQcml2YXRlIGF0dHJpYnV0ZXM6XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKlxuICAgIHZhciBfc2VsZiA9IHRoaXMsXG4gICAgICAgIF9jb25mID0gY29uZiB8fCB7fTtcblxuICAgIC8vIExpdHRsZSBzaG9ydGN1dDpcbiAgICAvLyAqKioqKioqKioqKioqKioqXG4gICAgLy8gVGhlIGNvbmZpZ3VyYXRpb24gaXMgc3VwcG9zZWQgdG8gaGF2ZSBhIGxpc3Qgb2YgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBvYmplY3RzIGZvciBlYWNoIHJlbmRlcmVyLlxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyBjb25maWd1cmF0aW9uIGF0IGFsbCwgdGhlbiBub3RoaW5nIGlzIGRvbmUuXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3QsIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uIG9iamVjdCB3aWxsIGJlXG4gICAgLy8gICAgY29uc2lkZXJlZCBhcyBkZXNjcmliaW5nIHRoZSBmaXJzdCBhbmQgb25seSByZW5kZXJlci5cbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gcmVuZGVyZXIgbGlzdCBub3IgXCJjb250YWluZXJcIiBvYmplY3QsIGl0IHdpbGwgYmVcbiAgICAvLyAgICBjb25zaWRlcmVkIGFzIHRoZSBjb250YWluZXIgaXRzZWxmIChhIERPTSBlbGVtZW50KS5cbiAgICAvLyAgLSBJZiB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHNpZ21hKCkgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY29uc2lkZXJlZFxuICAgIC8vICAgIGFzIHRoZSBJRCBvZiB0aGUgRE9NIGNvbnRhaW5lci5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgX2NvbmYgPT09ICdzdHJpbmcnIHx8XG4gICAgICBfY29uZiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50XG4gICAgKVxuICAgICAgX2NvbmYgPSB7XG4gICAgICAgIHJlbmRlcmVyczogW19jb25mXVxuICAgICAgfTtcbiAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoX2NvbmYpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgX2NvbmYgPSB7XG4gICAgICAgIHJlbmRlcmVyczogX2NvbmZcbiAgICAgIH07XG5cbiAgICAvLyBBbHNvIGNoZWNrIFwicmVuZGVyZXJcIiBhbmQgXCJjb250YWluZXJcIiBrZXlzOlxuICAgIG8gPSBfY29uZi5yZW5kZXJlcnMgfHwgX2NvbmYucmVuZGVyZXIgfHwgX2NvbmYuY29udGFpbmVyO1xuICAgIGlmICghX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVycy5sZW5ndGggPT09IDApXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgKHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiAnY29udGFpbmVyJyBpbiBvKVxuICAgICAgKVxuICAgICAgICBfY29uZi5yZW5kZXJlcnMgPSBbb107XG5cbiAgICAvLyBSZWNlbnNlIHRoZSBpbnN0YW5jZTpcbiAgICBpZiAoX2NvbmYuaWQpIHtcbiAgICAgIGlmIChfX2luc3RhbmNlc1tfY29uZi5pZF0pXG4gICAgICAgIHRocm93ICdzaWdtYTogSW5zdGFuY2UgXCInICsgX2NvbmYuaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBfY29uZi5pZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlIChfX2luc3RhbmNlc1tpZF0pXG4gICAgICAgIGlkKys7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogJycgKyBpZFxuICAgICAgfSk7XG4gICAgfVxuICAgIF9faW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcblxuICAgIC8vIEluaXRpYWxpemUgc2V0dGluZ3MgZnVuY3Rpb246XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBzaWdtYS5jbGFzc2VzLmNvbmZpZ3VyYWJsZShcbiAgICAgIHNpZ21hLnNldHRpbmdzLFxuICAgICAgX2NvbmYuc2V0dGluZ3MgfHwge31cbiAgICApO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBsb2NrZWQgYXR0cmlidXRlczpcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dyYXBoJywge1xuICAgICAgdmFsdWU6IG5ldyBzaWdtYS5jbGFzc2VzLmdyYXBoKHRoaXMuc2V0dGluZ3MpLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtaWRkbGV3YXJlcycsIHtcbiAgICAgIHZhbHVlOiBbXSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FtZXJhcycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVuZGVyZXJzJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZW5kZXJlcnNQZXJDYW1lcmEnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYUZyYW1lcycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FtZXJhJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhc1swXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2V2ZW50cycsIHtcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgICdjbGljaycsXG4gICAgICAgICdyaWdodENsaWNrJyxcbiAgICAgICAgJ2NsaWNrU3RhZ2UnLFxuICAgICAgICAnZG91YmxlQ2xpY2tTdGFnZScsXG4gICAgICAgICdyaWdodENsaWNrU3RhZ2UnLFxuICAgICAgICAnY2xpY2tOb2RlJyxcbiAgICAgICAgJ2NsaWNrTm9kZXMnLFxuICAgICAgICAnZG91YmxlQ2xpY2tOb2RlJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZXMnLFxuICAgICAgICAncmlnaHRDbGlja05vZGUnLFxuICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcbiAgICAgICAgJ292ZXJOb2RlJyxcbiAgICAgICAgJ292ZXJOb2RlcycsXG4gICAgICAgICdvdXROb2RlJyxcbiAgICAgICAgJ291dE5vZGVzJyxcbiAgICAgICAgJ2Rvd25Ob2RlJyxcbiAgICAgICAgJ2Rvd25Ob2RlcycsXG4gICAgICAgICd1cE5vZGUnLFxuICAgICAgICAndXBOb2RlcydcbiAgICAgIF0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIEFkZCBhIGN1c3RvbSBoYW5kbGVyLCB0byByZWRpc3BhdGNoIGV2ZW50cyBmcm9tIHJlbmRlcmVyczpcbiAgICB0aGlzLl9oYW5kbGVyID0gKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBrLFxuICAgICAgICAgIGRhdGEgPSB7fTtcblxuICAgICAgZm9yIChrIGluIGUuZGF0YSlcbiAgICAgICAgZGF0YVtrXSA9IGUuZGF0YVtrXTtcblxuICAgICAgZGF0YS5yZW5kZXJlciA9IGUudGFyZ2V0O1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUudHlwZSwgZGF0YSk7XG4gICAgfSkuYmluZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgcmVuZGVyZXJzOlxuICAgIGEgPSBfY29uZi5yZW5kZXJlcnMgfHwgW107XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgdGhpcy5hZGRSZW5kZXJlcihhW2ldKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWlkZGxld2FyZXM6XG4gICAgYSA9IF9jb25mLm1pZGRsZXdhcmVzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMubWlkZGxld2FyZXMucHVzaChcbiAgICAgICAgdHlwZW9mIGFbaV0gPT09ICdzdHJpbmcnID9cbiAgICAgICAgICBzaWdtYS5taWRkbGV3YXJlc1thW2ldXSA6XG4gICAgICAgICAgYVtpXVxuICAgICAgKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBncmFwaCB0byBmaWxsIGluOlxuICAgIGlmICh0eXBlb2YgX2NvbmYuZ3JhcGggPT09ICdvYmplY3QnICYmIF9jb25mLmdyYXBoKSB7XG4gICAgICB0aGlzLmdyYXBoLnJlYWQoX2NvbmYuZ3JhcGgpO1xuXG4gICAgICAvLyBJZiBhIGdyYXBoIGlzIGdpdmVuIHRvIHRoZSB0byB0aGUgaW5zdGFuY2UsIHRoZSBcInJlZnJlc2hcIiBtZXRob2QgaXNcbiAgICAgIC8vIGRpcmVjdGx5IGNhbGxlZDpcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCByZXNpemU6XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKF9zZWxmLnNldHRpbmdzKVxuICAgICAgICBfc2VsZi5yZWZyZXNoKCk7XG4gICAgfSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyB3aWxsIGluc3RhbnRpYXRlIGFuZCByZWZlcmVuY2UgYSBuZXcgY2FtZXJhLiBJZiBubyBpZCBpc1xuICAgKiBzcGVjaWZpZWQsIHRoZW4gYW4gYXV0b21hdGljIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgICAgICAgICAgaWQgRXZlbnR1YWxseSB0aGUgY2FtZXJhIGlkLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgVGhlIGZyZXNoIG5ldyBjYW1lcmEgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUuYWRkQ2FtZXJhID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNhbWVyYTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWQgPSAwO1xuICAgICAgd2hpbGUgKHRoaXMuY2FtZXJhc1snJyArIGlkXSlcbiAgICAgICAgaWQrKztcbiAgICAgIGlkID0gJycgKyBpZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYW1lcmFzW2lkXSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRDYW1lcmE6IFRoZSBjYW1lcmEgXCInICsgaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIGNhbWVyYSA9IG5ldyBzaWdtYS5jbGFzc2VzLmNhbWVyYShpZCwgdGhpcy5ncmFwaCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5jYW1lcmFzW2lkXSA9IGNhbWVyYTtcblxuICAgIC8vIEFkZCBhIHF1YWR0cmVlIHRvIHRoZSBjYW1lcmE6XG4gICAgY2FtZXJhLnF1YWR0cmVlID0gbmV3IHNpZ21hLmNsYXNzZXMucXVhZCgpO1xuXG4gICAgLy8gQWRkIGFuIGVkZ2VxdWFkdHJlZSB0byB0aGUgY2FtZXJhOlxuICAgIGlmIChzaWdtYS5jbGFzc2VzLmVkZ2VxdWFkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbWVyYS5lZGdlcXVhZHRyZWUgPSBuZXcgc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCgpO1xuICAgIH1cblxuICAgIGNhbWVyYS5iaW5kKCdjb29yZGluYXRlc1VwZGF0ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLnJlbmRlckNhbWVyYShjYW1lcmEsIGNhbWVyYS5pc0FuaW1hdGVkKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2lkXSA9IFtdO1xuXG4gICAgcmV0dXJuIGNhbWVyYTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgYSBjYW1lcmEsIGFuZCBldmVyeSByZW5kZXJlciBhdHRhY2hlZCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfGNhbWVyYX0gdiBUaGUgY2FtZXJhIHRvIGtpbGwgb3IgaXRzIElELlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmtpbGxDYW1lcmEgPSBmdW5jdGlvbih2KSB7XG4gICAgdiA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRoaXMuY2FtZXJhc1t2XSA6IHY7XG5cbiAgICBpZiAoIXYpXG4gICAgICB0aHJvdyAnc2lnbWEua2lsbENhbWVyYTogVGhlIGNhbWVyYSBpcyB1bmRlZmluZWQuJztcblxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5pZF07XG5cbiAgICBmb3IgKGwgPSBhLmxlbmd0aCwgaSA9IGwgLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRoaXMua2lsbFJlbmRlcmVyKGFbaV0pO1xuXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmNhbWVyYUZyYW1lc1t2LmlkXTtcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFzW3YuaWRdO1xuXG4gICAgaWYgKHYua2lsbClcbiAgICAgIHYua2lsbCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyB3aWxsIGluc3RhbnRpYXRlIGFuZCByZWZlcmVuY2UgYSBuZXcgcmVuZGVyZXIuIFRoZSBcInR5cGVcIlxuICAgKiBhcmd1bWVudCBjYW4gYmUgdGhlIGNvbnN0cnVjdG9yIG9yIGl0cyBuYW1lIGluIHRoZSBcInNpZ21hLnJlbmRlcmVyc1wiXG4gICAqIHBhY2thZ2UuIElmIG5vIHR5cGUgaXMgc3BlY2lmaWVkLCB0aGVuIFwic2lnbWEucmVuZGVyZXJzLmRlZlwiIHdpbGwgYmUgdXNlZC5cbiAgICogSWYgbm8gaWQgaXMgc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbnMgRXZlbnR1YWxseSBzb21lIG9wdGlvbnMgdG8gZ2l2ZSB0byB0aGUgcmVuZGVyZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm4ge3JlbmRlcmVyfSAgICAgICAgIFRoZSBmcmVzaCBuZXcgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgXCJvcHRpb25zXCJcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/c3RyaW5nfSAgICAgICAgICAgIGlkICAgICBFdmVudHVhbGx5IHRoZSByZW5kZXJlciBpZC5cbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSB0eXBlICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgY29uc3RydWN0b3Igb3IgaXRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgaW4gdGhlIFwic2lnbWEucmVuZGVyZXJzXCIgcGFja2FnZS5cbiAgICogICB7PyhjYW1lcmF8c3RyaW5nKX0gICBjYW1lcmEgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgY2FtZXJhIG9yIGl0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZC5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5hZGRSZW5kZXJlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIGZuLFxuICAgICAgICBjYW1lcmEsXG4gICAgICAgIHJlbmRlcmVyLFxuICAgICAgICBvID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFBvbHltb3JwaGlzbTpcbiAgICBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnKVxuICAgICAgbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvKVxuICAgICAgfTtcbiAgICBlbHNlIGlmIChvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpXG4gICAgICBvID0ge1xuICAgICAgICBjb250YWluZXI6IG9cbiAgICAgIH07XG5cbiAgICAvLyBJZiB0aGUgY29udGFpbmVyIHN0aWxsIGlzIGEgc3RyaW5nLCB3ZSBnZXQgaXQgYnkgaWRcbiAgICBpZiAodHlwZW9mIG8uY29udGFpbmVyID09PSAnc3RyaW5nJylcbiAgICAgIG8uY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoby5jb250YWluZXIpO1xuXG4gICAgLy8gUmVmZXJlbmNlIHRoZSBuZXcgcmVuZGVyZXI6XG4gICAgaWYgKCEoJ2lkJyBpbiBvKSkge1xuICAgICAgaWQgPSAwO1xuICAgICAgd2hpbGUgKHRoaXMucmVuZGVyZXJzWycnICsgaWRdKVxuICAgICAgICBpZCsrO1xuICAgICAgaWQgPSAnJyArIGlkO1xuICAgIH0gZWxzZVxuICAgICAgaWQgPSBvLmlkO1xuXG4gICAgaWYgKHRoaXMucmVuZGVyZXJzW2lkXSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIHJlbmRlcmVyIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICAvLyBGaW5kIHRoZSBnb29kIGNvbnN0cnVjdG9yOlxuICAgIGZuID0gdHlwZW9mIG8udHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IG8udHlwZSA6IHNpZ21hLnJlbmRlcmVyc1tvLnR5cGVdO1xuICAgIGZuID0gZm4gfHwgc2lnbWEucmVuZGVyZXJzLmRlZjtcblxuICAgIC8vIEZpbmQgdGhlIGdvb2QgY2FtZXJhOlxuICAgIGNhbWVyYSA9ICdjYW1lcmEnIGluIG8gP1xuICAgICAgKFxuICAgICAgICBvLmNhbWVyYSBpbnN0YW5jZW9mIHNpZ21hLmNsYXNzZXMuY2FtZXJhID9cbiAgICAgICAgICBvLmNhbWVyYSA6XG4gICAgICAgICAgdGhpcy5jYW1lcmFzW28uY2FtZXJhXSB8fCB0aGlzLmFkZENhbWVyYShvLmNhbWVyYSlcbiAgICAgICkgOlxuICAgICAgdGhpcy5hZGRDYW1lcmEoKTtcblxuICAgIGlmICh0aGlzLmNhbWVyYXNbY2FtZXJhLmlkXSAhPT0gY2FtZXJhKVxuICAgICAgdGhyb3cgJ3NpZ21hLmFkZFJlbmRlcmVyOiBUaGUgY2FtZXJhIGlzIG5vdCBwcm9wZXJseSByZWZlcmVuY2VkLic7XG5cbiAgICAvLyBJbnN0YW50aWF0ZTpcbiAgICByZW5kZXJlciA9IG5ldyBmbih0aGlzLmdyYXBoLCBjYW1lcmEsIHRoaXMuc2V0dGluZ3MsIG8pO1xuICAgIHRoaXMucmVuZGVyZXJzW2lkXSA9IHJlbmRlcmVyO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXJlciwgJ2lkJywge1xuICAgICAgdmFsdWU6IGlkXG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGV2ZW50czpcbiAgICBpZiAocmVuZGVyZXIuYmluZClcbiAgICAgIHJlbmRlcmVyLmJpbmQoXG4gICAgICAgIFtcbiAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICdyaWdodENsaWNrJyxcbiAgICAgICAgICAnY2xpY2tTdGFnZScsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxuICAgICAgICAgICdyaWdodENsaWNrU3RhZ2UnLFxuICAgICAgICAgICdjbGlja05vZGUnLFxuICAgICAgICAgICdjbGlja05vZGVzJyxcbiAgICAgICAgICAnY2xpY2tFZGdlJyxcbiAgICAgICAgICAnY2xpY2tFZGdlcycsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZScsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZXMnLFxuICAgICAgICAgICdkb3VibGVDbGlja0VkZ2UnLFxuICAgICAgICAgICdkb3VibGVDbGlja0VkZ2VzJyxcbiAgICAgICAgICAncmlnaHRDbGlja05vZGUnLFxuICAgICAgICAgICdyaWdodENsaWNrTm9kZXMnLFxuICAgICAgICAgICdyaWdodENsaWNrRWRnZScsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tFZGdlcycsXG4gICAgICAgICAgJ292ZXJOb2RlJyxcbiAgICAgICAgICAnb3Zlck5vZGVzJyxcbiAgICAgICAgICAnb3ZlckVkZ2UnLFxuICAgICAgICAgICdvdmVyRWRnZXMnLFxuICAgICAgICAgICdvdXROb2RlJyxcbiAgICAgICAgICAnb3V0Tm9kZXMnLFxuICAgICAgICAgICdvdXRFZGdlJyxcbiAgICAgICAgICAnb3V0RWRnZXMnLFxuICAgICAgICAgICdkb3duTm9kZScsXG4gICAgICAgICAgJ2Rvd25Ob2RlcycsXG4gICAgICAgICAgJ2Rvd25FZGdlJyxcbiAgICAgICAgICAnZG93bkVkZ2VzJyxcbiAgICAgICAgICAndXBOb2RlJyxcbiAgICAgICAgICAndXBOb2RlcycsXG4gICAgICAgICAgJ3VwRWRnZScsXG4gICAgICAgICAgJ3VwRWRnZXMnXG4gICAgICAgIF0sXG4gICAgICAgIHRoaXMuX2hhbmRsZXJcbiAgICAgICk7XG5cbiAgICAvLyBSZWZlcmVuY2UgdGhlIHJlbmRlcmVyIGJ5IGl0cyBjYW1lcmE6XG4gICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbY2FtZXJhLmlkXS5wdXNoKHJlbmRlcmVyKTtcblxuICAgIHJldHVybiByZW5kZXJlcjtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgYSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfHJlbmRlcmVyfSB2IFRoZSByZW5kZXJlciB0byBraWxsIG9yIGl0cyBJRC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmtpbGxSZW5kZXJlciA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2ID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdGhpcy5yZW5kZXJlcnNbdl0gOiB2O1xuXG4gICAgaWYgKCF2KVxuICAgICAgdGhyb3cgJ3NpZ21hLmtpbGxSZW5kZXJlcjogVGhlIHJlbmRlcmVyIGlzIHVuZGVmaW5lZC4nO1xuXG4gICAgdmFyIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmNhbWVyYS5pZF0sXG4gICAgICAgIGkgPSBhLmluZGV4T2Yodik7XG5cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgYS5zcGxpY2UoaSwgMSk7XG5cbiAgICBpZiAodi5raWxsKVxuICAgICAgdi5raWxsKCk7XG5cbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnNbdi5pZF07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIsIHdpdGggdGhlIHNhbWVcbiAgICogYXJndW1lbnRzIHRoYW4gdGhlIFwicmVuZGVyXCIgbWV0aG9kLCBidXQgd2lsbCBhbHNvIGNoZWNrIGlmIHRoZSByZW5kZXJlclxuICAgKiBoYXMgYSBcInByb2Nlc3NcIiBtZXRob2QsIGFuZCBjYWxsIGl0IGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogSXQgaXMgdXNlZnVsIGZvciBxdWFkdHJlZXMgb3IgV2ViR0wgcHJvY2Vzc2luZywgZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgb3B0aW9ucyBFdmVudHVhbGx5IHNvbWUgb3B0aW9ucyB0byBnaXZlIHRvIHRoZSByZWZyZXNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P2Jvb2xlYW59IHNraXBJbmRleGF0aW9uIEEgZmxhZyBzcGVjaWZ5aW5nIHdldGhlciBvciBub3QgdGhlIHJlZnJlc2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZCByZWluZGV4IHRoZSBncmFwaCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWR0cmVlcyBvciBub3QgKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBjLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIHByZWZpeCA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIENhbGwgZWFjaCBtaWRkbGV3YXJlOlxuICAgIGEgPSB0aGlzLm1pZGRsZXdhcmVzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGFbaV0uY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgKGkgPT09IDApID8gJycgOiAndG1wJyArIHByZWZpeCArICc6JyxcbiAgICAgICAgKGkgPT09IGwgLSAxKSA/ICdyZWFkeTonIDogKCd0bXAnICsgKCsrcHJlZml4KSArICc6JylcbiAgICAgICk7XG5cbiAgICAvLyBUaGVuLCBmb3IgZWFjaCBjYW1lcmEsIGNhbGwgdGhlIFwicmVzY2FsZVwiIG1pZGRsZXdhcmUsIHVubGVzcyB0aGVcbiAgICAvLyBzZXR0aW5ncyBzcGVjaWZ5IG5vdCB0bzpcbiAgICBmb3IgKGsgaW4gdGhpcy5jYW1lcmFzKSB7XG4gICAgICBjID0gdGhpcy5jYW1lcmFzW2tdO1xuICAgICAgaWYgKFxuICAgICAgICBjLnNldHRpbmdzKCdhdXRvUmVzY2FsZScpICYmXG4gICAgICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdICYmXG4gICAgICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdLmxlbmd0aFxuICAgICAgKVxuICAgICAgICBzaWdtYS5taWRkbGV3YXJlcy5yZXNjYWxlLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhLmxlbmd0aCA/ICdyZWFkeTonIDogJycsXG4gICAgICAgICAgYy5yZWFkUHJlZml4LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXVswXS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0uaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBzaWdtYS5taWRkbGV3YXJlcy5jb3B5LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhLmxlbmd0aCA/ICdyZWFkeTonIDogJycsXG4gICAgICAgICAgYy5yZWFkUHJlZml4XG4gICAgICAgICk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5za2lwSW5kZXhhdGlvbikge1xuICAgICAgICAvLyBGaW5kIGdyYXBoIGJvdW5kYXJpZXM6XG4gICAgICAgIGJvdW5kcyA9IHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMoXG4gICAgICAgICAgdGhpcy5ncmFwaCxcbiAgICAgICAgICBjLnJlYWRQcmVmaXhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBSZWZyZXNoIHF1YWR0cmVlOlxuICAgICAgICBjLnF1YWR0cmVlLmluZGV4KHRoaXMuZ3JhcGgubm9kZXMoKSwge1xuICAgICAgICAgIHByZWZpeDogYy5yZWFkUHJlZml4LFxuICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgeDogYm91bmRzLm1pblgsXG4gICAgICAgICAgICB5OiBib3VuZHMubWluWSxcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMubWF4WSAtIGJvdW5kcy5taW5ZXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWZyZXNoIGVkZ2VxdWFkdHJlZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGMuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBjLnNldHRpbmdzKCdkcmF3RWRnZXMnKSAmJlxuICAgICAgICAgIGMuc2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpXG4gICAgICAgICkge1xuICAgICAgICAgIGMuZWRnZXF1YWR0cmVlLmluZGV4KHRoaXMuZ3JhcGgsIHtcbiAgICAgICAgICAgIHByZWZpeDogYy5yZWFkUHJlZml4LFxuICAgICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICAgIHg6IGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgICB5OiBib3VuZHMubWluWSxcbiAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgsXG4gICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBlYWNoIHJlbmRlcmVyOlxuICAgIGEgPSBPYmplY3Qua2V5cyh0aGlzLnJlbmRlcmVycyk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucHJvY2VzcygpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArIGFbaV0gKyAnXCIgY3Jhc2hlZCBvbiBcIi5wcm9jZXNzKClcIidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucHJvY2VzcygpO1xuICAgICAgfVxuXG4gICAgdGhpcy5yZW5kZXIoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlci5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWF9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgcHJlZml4ID0gMDtcblxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcbiAgICBhID0gT2JqZWN0LmtleXModGhpcy5yZW5kZXJlcnMpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucmVuZGVyKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygndmVyYm9zZScpKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXSArICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnJlbmRlcigpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcInJlbmRlclwiIG1ldGhvZCBvZiBlYWNoIHJlbmRlcmVyIHRoYXQgaXMgYm91bmQgdG9cbiAgICogdGhlIHNwZWNpZmllZCBjYW1lcmEuIFRvIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlcywgaWYgdGhpcyBtZXRob2QgaXNcbiAgICogY2FsbGVkIHRvbyBvZnRlbiwgdGhlIG51bWJlciBvZiBlZmZlY3RpdmUgcmVuZGVyaW5ncyBpcyBsaW1pdGF0ZWQgdG8gb25lXG4gICAqIHBlciBmcmFtZSwgdW5sZXNzIHlvdSBhcmUgdXNpbmcgdGhlIFwiZm9yY2VcIiBmbGFnLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gY2FtZXJhIFRoZSBjYW1lcmEgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHs/Ym9vbGVhbn0gICAgICAgICAgICAgZm9yY2UgIElmIHRydWUsIHdpbGwgcmVuZGVyIHRoZSBjYW1lcmFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RseS5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVuZGVyQ2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhLCBmb3JjZSkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGlmIChmb3JjZSkge1xuICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF07XG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldLmlkICsgJ1wiIGNyYXNoZWQgb24gXCIucmVuZGVyKClcIidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF0pIHtcbiAgICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF07XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICtcbiAgICAgICAgICAgICAgICAgICAgYVtpXS5pZCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJraWxsXCIgbWV0aG9kIG9mIGVhY2ggbW9kdWxlIGFuZCBkZXN0cm95cyBhbnlcbiAgICogcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaztcblxuICAgIC8vIERpc3BhdGNoaW5nIGV2ZW50XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdraWxsJyk7XG5cbiAgICAvLyBLaWxsIGdyYXBoOlxuICAgIHRoaXMuZ3JhcGgua2lsbCgpO1xuXG4gICAgLy8gS2lsbCBtaWRkbGV3YXJlczpcbiAgICBkZWxldGUgdGhpcy5taWRkbGV3YXJlcztcblxuICAgIC8vIEtpbGwgZWFjaCByZW5kZXJlcjpcbiAgICBmb3IgKGsgaW4gdGhpcy5yZW5kZXJlcnMpXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcih0aGlzLnJlbmRlcmVyc1trXSk7XG5cbiAgICAvLyBLaWxsIGVhY2ggY2FtZXJhOlxuICAgIGZvciAoayBpbiB0aGlzLmNhbWVyYXMpXG4gICAgICB0aGlzLmtpbGxDYW1lcmEodGhpcy5jYW1lcmFzW2tdKTtcblxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVycztcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFzO1xuXG4gICAgLy8gS2lsbCBldmVyeXRoaW5nIGVsc2U6XG4gICAgZm9yIChrIGluIHRoaXMpXG4gICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgZGVsZXRlIHRoaXNba107XG5cbiAgICBkZWxldGUgX19pbnN0YW5jZXNbdGhpcy5pZF07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgaW5zdGFuY2VzIG9iamVjdCBvciBhIHNwZWNpZmljIHJ1bm5pbmcgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IGlkIEV2ZW50dWFsbHkgYW4gaW5zdGFuY2UgSUQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFRoZSByZWxhdGVkIGluc3RhbmNlIG9yIGEgY2xvbmUgb2YgdGhlIGluc3RhbmNlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuXG4gICAqL1xuICBzaWdtYS5pbnN0YW5jZXMgPSBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgIF9faW5zdGFuY2VzW2lkXSA6XG4gICAgICBzaWdtYS51dGlscy5leHRlbmQoe30sIF9faW5zdGFuY2VzKTtcbiAgfTtcblxuXG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZlcnNpb24gb2Ygc2lnbWE6XG4gICAqL1xuICBzaWdtYS52ZXJzaW9uID0gJzEuMi4xJztcblxuXG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdBbiBvYmplY3QgY2FsbGVkIHNpZ21hIGlzIGFscmVhZHkgaW4gdGhlIGdsb2JhbCBzY29wZS4nO1xuXG4gIHRoaXMuc2lnbWEgPSBzaWdtYTtcblxufSkuY2FsbCh0aGlzKTtcblxuLyoqXG4gKiBjb25yYWQuanMgaXMgYSB0aW55IEphdmFTY3JpcHQgam9icyBzY2hlZHVsZXIsXG4gKlxuICogVmVyc2lvbjogMC4xLjBcbiAqIFNvdXJjZXM6IGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qc1xuICogRG9jOiAgICAgaHR0cDovL2dpdGh1Yi5jb20vamFjb215YWwvY29ucmFkLmpzI3JlYWRtZVxuICpcbiAqIExpY2Vuc2U6XG4gKiAtLS0tLS0tLVxuICogQ29weXJpZ2h0IMKpIDIwMTMgQWxleGlzIEphY29teSwgU2NpZW5jZXMtUG8gbcOpZGlhbGFiXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbiAqIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4gKiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUaGUgU29mdHdhcmUgaXMgcHJvdmlkZWQgXCJhcyBpc1wiLCB3aXRob3V0IHdhcnJhbnR5IG9mIGFueSBraW5kLCBleHByZXNzIG9yXG4gKiBpbXBsaWVkLCBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIHRoZSB3YXJyYW50aWVzIG9mIG1lcmNoYW50YWJpbGl0eSxcbiAqIGZpdG5lc3MgZm9yIGEgcGFydGljdWxhciBwdXJwb3NlIGFuZCBub25pbmZyaW5nZW1lbnQuIEluIG5vIGV2ZW50IHNoYWxsIHRoZVxuICogYXV0aG9ycyBvciBjb3B5cmlnaHQgaG9sZGVycyBiZSBsaWFibGUgZm9yIGFueSBjbGFpbSwgZGFtYWdlcyBvciBvdGhlclxuICogbGlhYmlsaXR5LCB3aGV0aGVyIGluIGFuIGFjdGlvbiBvZiBjb250cmFjdCwgdG9ydCBvciBvdGhlcndpc2UsIGFyaXNpbmdcbiAqIGZyb20sIG91dCBvZiBvciBpbiBjb25uZWN0aW9uIHdpdGggdGhlIHNvZnR3YXJlIG9yIHRoZSB1c2Ugb3Igb3RoZXIgZGVhbGluZ3NcbiAqIGluIHRoZSBTb2Z0d2FyZS5cbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ2hlY2sgdGhhdCBjb25yYWQuanMgaGFzIG5vdCBiZWVuIGxvYWRlZCB5ZXQ6XG4gIGlmIChnbG9iYWwuY29ucmFkKVxuICAgIHRocm93IG5ldyBFcnJvcignY29ucmFkIGFscmVhZHkgZXhpc3RzJyk7XG5cblxuICAvKipcbiAgICogUFJJVkFURSBWQVJJQUJMRVM6XG4gICAqICoqKioqKioqKioqKioqKioqKlxuICAgKi9cblxuICAvKipcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBjb25yYWQgaXMgcnVubmluZyBvciBub3QuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB2YXIgX2xhc3RGcmFtZVRpbWU7XG5cbiAgLyoqXG4gICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgY29ucmFkIGlzIHJ1bm5pbmcgb3Igbm90LlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHZhciBfaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBoYXNoIG9mIHJlZ2lzdGVyZWQgam9icy4gRWFjaCBqb2IgbXVzdCBhdCBsZWFzdCBoYXZlIGEgdW5pcXVlIElEXG4gICAqIHVuZGVyIHRoZSBrZXkgXCJpZFwiIGFuZCBhIGZ1bmN0aW9uIHVuZGVyIHRoZSBrZXkgXCJqb2JcIi4gVGhpcyBoYXNoXG4gICAqIGNvbnRhaW5zIGVhY2ggcnVubmluZyBqb2IgYW5kIGVhY2ggd2FpdGluZyBqb2IuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX2pvYnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIGhhc2ggb2YgY3VycmVudGx5IHJ1bm5pbmcgam9icy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfcnVubmluZ0pvYnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMsIHNvcnRlZCBieSBwcmlvcml0eS5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIF9zb3J0ZWRCeVByaW9yaXR5Sm9icyA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXkgb2YgY3VycmVudGx5IHdhaXRpbmcgam9icy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfd2FpdGluZ0pvYnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGZpbmlzaGVkIGpvYnMuIFRoZXkgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSwgc2luY2UgdHdvIGpvYnNcbiAgICogd2l0aCB0aGUgc2FtZSBcImlkXCIgY2FuIGhhcHBlbiBhdCB0d28gZGlmZmVyZW50IHRpbWVzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB2YXIgX2RvbmVKb2JzID0gW107XG5cbiAgLyoqXG4gICAqIEEgZGlydHkgZmxhZyB0byBrZWVwIGNvbnJhZCBmcm9tIHN0YXJ0aW5nOiBJbmRlZWQsIHdoZW4gYWRkSm9iKCkgaXMgY2FsbGVkXG4gICAqIHdpdGggc2V2ZXJhbCBqb2JzLCBjb25yYWQgbXVzdCBiZSBzdGFydGVkIG9ubHkgYXQgdGhlIGVuZC4gVGhpcyBmbGFnIGtlZXBzXG4gICAqIG1lIGZyb20gZHVwbGljYXRpbmcgdGhlIGNvZGUgdGhhdCBlZmZlY3RpdmVseSBhZGRzIGEgam9iLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHZhciBfbm9TdGFydCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBbiBoYXNoIGNvbnRhaW5pbmcgc29tZSBnbG9iYWwgc2V0dGluZ3MgYWJvdXQgaG93IGNvbnJhZC5qcyBzaG91bGRcbiAgICogYmVoYXZlLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9wYXJhbWV0ZXJzID0ge1xuICAgIGZyYW1lRHVyYXRpb246IDIwLFxuICAgIGhpc3Rvcnk6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgZXZlcnkgaGFuZGxlcnMgYm91bmQgdG8gY29ucmFkIGV2ZW50cy4gSXQgZG9lcyBub3RcbiAgICogcmVxdWlyZWEgYW55IERPTSBpbXBsZW1lbnRhdGlvbiwgc2luY2UgdGhlIGV2ZW50cyBhcmUgYWxsIEphdmFTY3JpcHQuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4gIC8qKlxuICAgKiBQUklWQVRFIEZVTkNUSU9OUzpcbiAgICogKioqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXaWxsIGV4ZWN1dGUgdGhlIGhhbmRsZXIgZXZlcnl0aW1lIHRoYXQgdGhlIGluZGljYXRlZCBldmVudCAob3IgdGhlXG4gICAqIGluZGljYXRlZCBldmVudHMpIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl8b2JqZWN0fSBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihPYmplY3QpfSAgICBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIGJpbmQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfYmluZChldmVudHMsIGhhbmRsZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBPYmplY3QoYXJndW1lbnRzWzBdKSA9PT0gYXJndW1lbnRzWzBdXG4gICAgKVxuICAgICAgZm9yIChldmVudHMgaW4gYXJndW1lbnRzWzBdKVxuICAgICAgICBfYmluZChldmVudHMsIGFyZ3VtZW50c1swXVtldmVudHNdKTtcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZUFycmF5ID1cbiAgICAgICAgQXJyYXkuaXNBcnJheShldmVudHMpID9cbiAgICAgICAgICBldmVudHMgOlxuICAgICAgICAgIGV2ZW50cy5zcGxpdCgvIC8pO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XG5cbiAgICAgICAgaWYgKCFfaGFuZGxlcnNbZXZlbnRdKVxuICAgICAgICAgIF9oYW5kbGVyc1tldmVudF0gPSBbXTtcblxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcbiAgICAgICAgLy8gbGF0ZXIgdG8gYWRkIGZsYWdzXG4gICAgICAgIF9oYW5kbGVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgaGFuZGxlciBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50IChvciBzcGVjaWZpZWQgZXZlbnRzKS5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGhhbmRsZXJzIGFyZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gIHs/ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byB1bmJpbmQuIElmIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudCBvciB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX3VuYmluZChldmVudHMsIGhhbmRsZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGosXG4gICAgICAgIGpfZW5kLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5ID0gQXJyYXkuaXNBcnJheShldmVudHMpID9cbiAgICAgICAgICAgICAgICAgICBldmVudHMgOlxuICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpdCgvIC8pO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XG4gICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7IGogIT09IGpfZW5kOyBqICs9IDEpXG4gICAgICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxuICAgICAgICAgICAgICBhLnB1c2goX2hhbmRsZXJzW2V2ZW50XVtqXSk7XG5cbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdICYmIF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoID09PSAwKVxuICAgICAgICAgIGRlbGV0ZSBfaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKVxuICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2VBcnJheVtpXV07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAgez9PYmplY3R9IGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2Rpc3BhdGNoKGV2ZW50cywgZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBpX2VuZCxcbiAgICAgICAgal9lbmQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IGRhdGE7XG5cbiAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcbiAgICAgIGV2ZW50TmFtZSA9IGVBcnJheVtpXTtcblxuICAgICAgaWYgKF9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IGV2ZW50TmFtZSxcbiAgICAgICAgICBkYXRhOiBkYXRhIHx8IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChqID0gMCwgal9lbmQgPSBfaGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7IGogIT09IGpfZW5kOyBqICs9IDEpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9oYW5kbGVyc1tldmVudE5hbWVdW2pdLmhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBtb3N0IHByaW9yaXRhcnkgam9iIG9uY2UsIGFuZCBkZWFscyB3aXRoIGZpbGxpbmcgdGhlIHN0YXRzXG4gICAqIChkb25lLCB0aW1lLCBhdmVyYWdlVGltZSwgY3VycmVudFRpbWUsIGV0Yy4uLikuXG4gICAqXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgaGFzIHRvIGJlIGtpbGxlZCwgbnVsbCBlbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2V4ZWN1dGVGaXJzdEpvYigpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgdGVzdCxcbiAgICAgICAga2lsbCxcbiAgICAgICAgcHVzaGVkID0gZmFsc2UsXG4gICAgICAgIHRpbWUgPSBfX2RhdGVOb3coKSxcbiAgICAgICAgam9iID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNoaWZ0KCk7XG5cbiAgICAvLyBFeGVjdXRlIHRoZSBqb2IgYW5kIGxvb2sgYXQgdGhlIHJlc3VsdDpcbiAgICB0ZXN0ID0gam9iLmpvYigpO1xuXG4gICAgLy8gRGVhbCB3aXRoIHN0YXRzOlxuICAgIHRpbWUgPSBfX2RhdGVOb3coKSAtIHRpbWU7XG4gICAgam9iLmRvbmUrKztcbiAgICBqb2IudGltZSArPSB0aW1lO1xuICAgIGpvYi5jdXJyZW50VGltZSArPSB0aW1lO1xuICAgIGpvYi53ZWlnaHRUaW1lID0gam9iLmN1cnJlbnRUaW1lIC8gKGpvYi53ZWlnaHQgfHwgMSk7XG4gICAgam9iLmF2ZXJhZ2VUaW1lID0gam9iLnRpbWUgLyBqb2IuZG9uZTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBqb2IgaGFzIHRvIGJlIGtpbGxlZDpcbiAgICBraWxsID0gam9iLmNvdW50ID8gKGpvYi5jb3VudCA8PSBqb2IuZG9uZSkgOiAhdGVzdDtcblxuICAgIC8vIFJlc2V0IHByaW9yaXRpZXM6XG4gICAgaWYgKCFraWxsKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKF9zb3J0ZWRCeVByaW9yaXR5Sm9ic1tpXS53ZWlnaHRUaW1lID4gam9iLndlaWdodFRpbWUpIHtcbiAgICAgICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMuc3BsaWNlKGksIDAsIGpvYik7XG4gICAgICAgICAgcHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBpZiAoIXB1c2hlZClcbiAgICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnB1c2goam9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2lsbCA/IGpvYiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGEgam9iLCBieSBhZGRpbmcgaXQgdG8gdGhlIF9ydW5uaW5nSm9icyBvYmplY3QgYW5kIHRoZVxuICAgKiBfc29ydGVkQnlQcmlvcml0eUpvYnMgYXJyYXkuIEl0IGFsc28gaW5pdGlhbGl6ZXMgaXRzIGN1cnJlbnRUaW1lIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGpvYiBUaGUgam9iIHRvIGFjdGl2YXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2FjdGl2YXRlSm9iKGpvYikge1xuICAgIHZhciBsID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDtcblxuICAgIC8vIEFkZCB0aGUgam9iIHRvIHRoZSBydW5uaW5nIGpvYnM6XG4gICAgX3J1bm5pbmdKb2JzW2pvYi5pZF0gPSBqb2I7XG4gICAgam9iLnN0YXR1cyA9ICdydW5uaW5nJztcblxuICAgIC8vIEFkZCB0aGUgam9iIHRvIHRoZSBwcmlvcml0aWVzOlxuICAgIGlmIChsKSB7XG4gICAgICBqb2Iud2VpZ2h0VGltZSA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9ic1tsIC0gMV0ud2VpZ2h0VGltZTtcbiAgICAgIGpvYi5jdXJyZW50VGltZSA9IGpvYi53ZWlnaHRUaW1lICogKGpvYi53ZWlnaHQgfHwgMSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgam9iIGFuZCBkaXNwYXRjaDpcbiAgICBqb2Iuc3RhcnRUaW1lID0gX19kYXRlTm93KCk7XG4gICAgX2Rpc3BhdGNoKCdqb2JTdGFydGVkJywgX19jbG9uZShqb2IpKTtcblxuICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1haW4gbG9vcCBvZiBjb25yYWQuanM6XG4gICAqICAuIEl0IGV4ZWN1dGVzIGpvYiBzdWNoIHRoYXQgdGhleSBhbGwgb2NjdXBhdGUgdGhlIHNhbWUgcHJvY2Vzc2luZyB0aW1lLlxuICAgKiAgLiBJdCBzdG9wcyBqb2JzIHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgZXhlY3V0ZWQgYW55bW9yZS5cbiAgICogIC4gSXQgdHJpZ2dlcnMgY2FsbGJhY2tzIHdoZW4gaXQgaXMgcmVsZXZhbnQuXG4gICAqICAuIEl0IHN0YXJ0cyB3YWl0aW5nIGpvYnMgd2hlbiB0aGV5IG5lZWQgdG8gYmUgc3RhcnRlZC5cbiAgICogIC4gSXQgaW5qZWN0cyBmcmFtZXMgdG8ga2VlcCBhIGNvbnN0YW50IGZyYXBlcyBwZXIgc2Vjb25kIHJhdGlvLlxuICAgKiAgLiBJdCBzdG9wcyBpdHNlbGYgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBqb2JzIHRvIGV4ZWN1dGUuXG4gICAqL1xuICBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgayxcbiAgICAgICAgbyxcbiAgICAgICAgbCxcbiAgICAgICAgam9iLFxuICAgICAgICB0aW1lLFxuICAgICAgICBkZWFkSm9iO1xuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBuZXdseSBhZGRlZCBqb2JzICh0aGUgX2pvYnMgb2JqZWN0KTpcbiAgICBmb3IgKGsgaW4gX2pvYnMpIHtcbiAgICAgIGpvYiA9IF9qb2JzW2tdO1xuXG4gICAgICBpZiAoam9iLmFmdGVyKVxuICAgICAgICBfd2FpdGluZ0pvYnNba10gPSBqb2I7XG4gICAgICBlbHNlXG4gICAgICAgIF9hY3RpdmF0ZUpvYihqb2IpO1xuXG4gICAgICBkZWxldGUgX2pvYnNba107XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBfaXNSdW5uaW5nIGZsYWcgdG8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIHJ1bm5pbmcgam9iOlxuICAgIF9pc1J1bm5pbmcgPSAhIV9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XG5cbiAgICAvLyBEZWFsIHdpdGggdGhlIHJ1bm5pbmcgam9icyAodGhlIF9ydW5uaW5nSm9icyBvYmplY3QpOlxuICAgIHdoaWxlIChcbiAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGggJiZcbiAgICAgIF9fZGF0ZU5vdygpIC0gX2xhc3RGcmFtZVRpbWUgPCBfcGFyYW1ldGVycy5mcmFtZUR1cmF0aW9uXG4gICAgKSB7XG4gICAgICBkZWFkSm9iID0gX2V4ZWN1dGVGaXJzdEpvYigpO1xuXG4gICAgICAvLyBEZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGpvYiBoYXMgZW5kZWQ6XG4gICAgICBpZiAoZGVhZEpvYikge1xuICAgICAgICBfa2lsbEpvYihkZWFkSm9iLmlkKTtcblxuICAgICAgICAvLyBDaGVjayBmb3Igd2FpdGluZyBqb2JzOlxuICAgICAgICBmb3IgKGsgaW4gX3dhaXRpbmdKb2JzKVxuICAgICAgICAgIGlmIChfd2FpdGluZ0pvYnNba10uYWZ0ZXIgPT09IGRlYWRKb2IuaWQpIHtcbiAgICAgICAgICAgIF9hY3RpdmF0ZUpvYihfd2FpdGluZ0pvYnNba10pO1xuICAgICAgICAgICAgZGVsZXRlIF93YWl0aW5nSm9ic1trXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY29ucmFkIHN0aWxsIGhhcyBqb2JzIHRvIGRlYWwgd2l0aCwgYW5kIGtpbGwgaXQgaWYgbm90OlxuICAgIGlmIChfaXNSdW5uaW5nKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxuICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgX2Rpc3BhdGNoKCdlbnRlckZyYW1lJyk7XG4gICAgICBzZXRUaW1lb3V0KF9sb29wLCAwKTtcbiAgICB9IGVsc2VcbiAgICAgIF9kaXNwYXRjaCgnc3RvcCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb25lIG9yIG1vcmUgam9icywgYW5kIHN0YXJ0cyB0aGUgbG9vcCBpZiBubyBqb2Igd2FzIHJ1bm5pbmcgYmVmb3JlLiBBXG4gICAqIGpvYiBpcyBhdCBsZWFzdCBhIHVuaXF1ZSBzdHJpbmcgXCJpZFwiIGFuZCBhIGZ1bmN0aW9uLCBhbmQgdGhlcmUgYXJlIHNvbWVcbiAgICogcGFyYW1ldGVycyB0aGF0IHlvdSBjYW4gc3BlY2lmeSBmb3IgZWFjaCBqb2IgdG8gbW9kaWZ5IHRoZSB3YXkgY29ucmFkIHdpbGxcbiAgICogZXhlY3V0ZSBpdC4gSWYgYSBqb2IgaXMgYWRkZWQgd2l0aCB0aGUgXCJpZFwiIG9mIGFub3RoZXIgam9iIHRoYXQgaXMgd2FpdGluZ1xuICAgKiBvciBzdGlsbCBydW5uaW5nLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICpcbiAgICogV2hlbiBhIGpvYiBpcyBhZGRlZCwgaXQgaXMgcmVmZXJlbmNlZCBpbiB0aGUgX2pvYnMgb2JqZWN0LCBieSBpdHMgaWQuXG4gICAqIFRoZW4sIGlmIGl0IGhhcyB0byBiZSBleGVjdXRlZCByaWdodCBub3csIGl0IHdpbGwgYmUgYWxzbyByZWZlcmVuY2VkIGluXG4gICAqIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0LiBJZiBpdCBoYXMgdG8gd2FpdCwgdGhlbiBpdCB3aWxsIGJlIGFkZGVkIGludG8gdGhlXG4gICAqIF93YWl0aW5nSm9icyBvYmplY3QsIHVudGlsIGl0IGNhbiBzdGFydC5cbiAgICpcbiAgICogS2VlcCByZWFkaW5nIHRoaXMgZG9jdW1lbnRhdGlvbiB0byBzZWUgaG93IHRvIGNhbGwgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXG4gICAqXG4gICAqIEFkZGluZyBvbmUgam9iOlxuICAgKiAqKioqKioqKioqKioqKipcbiAgICogQmFzaWNhbGx5LCBhIGpvYiBpcyBkZWZpbmVkIGJ5IGl0cyBzdHJpbmcgaWQgYW5kIGEgZnVuY3Rpb24gKHRoZSBqb2IpLiBJdFxuICAgKiBpcyBhbHNvIHBvc3NpYmxlIHRvIGFkZCBzb21lIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCBteUpvYkZ1bmN0aW9uKTtcbiAgICogID4gY29ucmFkLmFkZEpvYignbXlKb2JJZCcsIHtcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXG4gICAqICA+IH0pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcbiAgICogID4gICBpZDogJ215Sm9iSWQnLFxuICAgKiAgPiAgIGpvYjogbXlKb2JGdW5jdGlvbixcbiAgICogID4gICBzb21lUGFyYW1ldGVyOiBzb21lVmFsdWVcbiAgICogID4gfSk7XG4gICAqXG4gICAqIEFkZGluZyBzZXZlcmFsIGpvYnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqXG4gICAqIFdoZW4gYWRkaW5nIHNldmVyYWwgam9icyBhdCB0aGUgc2FtZSB0aW1lLCBpdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5XG4gICAqIHBhcmFtZXRlcnMgZm9yIGVhY2ggb25lIGluZGl2aWR1YWxseSBvciBmb3IgYWxsOlxuICAgKlxuICAgKiAgPiBjb25yYWQuYWRkSm9iKFtcbiAgICogID4gICB7XG4gICAqICA+ICAgICBpZDogJ215Sm9iSWQxJyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjEsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMTogc29tZVZhbHVlMVxuICAgKiAgPiAgIH0sXG4gICAqICA+ICAge1xuICAgKiAgPiAgICAgaWQ6ICdteUpvYklkMicsXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24yLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjI6IHNvbWVWYWx1ZTJcbiAgICogID4gICB9XG4gICAqICA+IF0sIHtcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcbiAgICogID4gfSk7XG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xuICAgKiAgPiAgIG15Sm9iSWQxOiB7LFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMSxcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIxOiBzb21lVmFsdWUxXG4gICAqICA+ICAgfSxcbiAgICogID4gICBteUpvYklkMjogeyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjIsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMjogc29tZVZhbHVlMlxuICAgKiAgPiAgIH1cbiAgICogID4gfSwge1xuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxuICAgKiAgPiB9KTtcbiAgICogID4gY29ucmFkLmFkZEpvYih7XG4gICAqICA+ICAgbXlKb2JJZDE6IG15Sm9iRnVuY3Rpb24xLFxuICAgKiAgPiAgIG15Sm9iSWQyOiBteUpvYkZ1bmN0aW9uMlxuICAgKiAgPiB9LCB7XG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiAgUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAgKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiAgSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgIHs/RnVuY3Rpb259IGVuZCAgICAgIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBqb2IgaXMgZW5kZWQuIEl0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBleGVjdXRlZCBpZiB0aGUgam9iIGlzIGtpbGxlZCBpbnN0ZWFkIG9mIGVuZGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIFwibmF0dXJhbGx5XCIuXG4gICAqICAgIHs/SW50ZWdlcn0gIGNvdW50ICAgIFRoZSBudW1iZXIgb2YgdGltZSB0aGUgam9iIGhhcyB0byBiZSBleGVjdXRlZC5cbiAgICogICAgez9OdW1iZXJ9ICAgd2VpZ2h0ICAgSWYgc3BlY2lmaWVkLCB0aGUgam9iIHdpbGwgYmUgZXhlY3V0ZWQgYXMgaXQgd2FzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkIFwid2VpZ2h0XCIgdGltZXMuXG4gICAqICAgIHs/U3RyaW5nfSAgIGFmdGVyICAgIFRoZSBpZCBvZiBhbm90aGVyIGpvYiAoZXZlbnR1YWxseSBub3QgYWRkZWQgeWV0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgc3BlY2lmaWVkLCB0aGlzIGpvYiB3aWxsIHN0YXJ0IG9ubHkgd2hlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkIFwiYWZ0ZXJcIiBqb2IgaXMgZW5kZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkSm9iKHYxLCB2Mikge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBvO1xuXG4gICAgLy8gQXJyYXkgb2Ygam9iczpcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2MSkpIHtcbiAgICAgIC8vIEtlZXAgY29ucmFkIHRvIHN0YXJ0IHVudGlsIHRoZSBsYXN0IGpvYiBpcyBhZGRlZDpcbiAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHYxLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgX2FkZEpvYih2MVtpXS5pZCwgX19leHRlbmQodjFbaV0sIHYyKSk7XG5cbiAgICAgIF9ub1N0YXJ0ID0gZmFsc2U7XG4gICAgICBpZiAoIV9pc1J1bm5pbmcpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBPbmUgam9iIChvYmplY3QpOlxuICAgICAgaWYgKHR5cGVvZiB2MS5pZCA9PT0gJ3N0cmluZycpXG4gICAgICAgIF9hZGRKb2IodjEuaWQsIHYxKTtcblxuICAgICAgLy8gSGFzaCBvZiBqb2JzOlxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgY29ucmFkIHRvIHN0YXJ0IHVudGlsIHRoZSBsYXN0IGpvYiBpcyBhZGRlZDpcbiAgICAgICAgX25vU3RhcnQgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSBpbiB2MSlcbiAgICAgICAgICBpZiAodHlwZW9mIHYxW2ldID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgX2FkZEpvYihpLCBfX2V4dGVuZCh7XG4gICAgICAgICAgICAgIGpvYjogdjFbaV1cbiAgICAgICAgICAgIH0sIHYyKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX2FkZEpvYihpLCBfX2V4dGVuZCh2MVtpXSwgdjIpKTtcblxuICAgICAgICBfbm9TdGFydCA9IGZhbHNlO1xuICAgICAgICBpZiAoIV9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxuICAgICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gT25lIGpvYiAoc3RyaW5nLCAqKTpcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChfaGFzSm9iKHYxKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdbY29ucmFkLmFkZEpvYl0gSm9iIHdpdGggaWQgXCInICsgdjEgKyAnXCIgYWxyZWFkeSBleGlzdHMuJ1xuICAgICAgICApO1xuXG4gICAgICAvLyBPbmUgam9iIChzdHJpbmcsIGZ1bmN0aW9uKTpcbiAgICAgIGlmICh0eXBlb2YgdjIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICBpZDogdjEsXG4gICAgICAgICAgZG9uZTogMCxcbiAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICAgIGN1cnJlbnRUaW1lOiAwLFxuICAgICAgICAgIGF2ZXJhZ2VUaW1lOiAwLFxuICAgICAgICAgIHdlaWdodFRpbWU6IDAsXG4gICAgICAgICAgam9iOiB2MlxuICAgICAgICB9O1xuXG4gICAgICAvLyBPbmUgam9iIChzdHJpbmcsIG9iamVjdCk6XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2MiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbyA9IF9fZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiB2MSxcbiAgICAgICAgICAgIGRvbmU6IDAsXG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgc3RhdHVzOiAnd2FpdGluZycsXG4gICAgICAgICAgICBjdXJyZW50VGltZTogMCxcbiAgICAgICAgICAgIGF2ZXJhZ2VUaW1lOiAwLFxuICAgICAgICAgICAgd2VpZ2h0VGltZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdjJcbiAgICAgICAgKTtcblxuICAgICAgLy8gSWYgbm9uZSBvZiB0aG9zZSBjYXNlcywgdGhyb3cgYW4gZXJyb3I6XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmFkZEpvYl0gV3JvbmcgYXJndW1lbnRzLicpO1xuXG4gICAgICAvLyBFZmZlY3RpdmVseSBhZGQgdGhlIGpvYjpcbiAgICAgIF9qb2JzW3YxXSA9IG87XG4gICAgICBfZGlzcGF0Y2goJ2pvYkFkZGVkJywgX19jbG9uZShvKSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBsb29wIGhhcyB0byBiZSBzdGFydGVkOlxuICAgICAgaWYgKCFfaXNSdW5uaW5nICYmICFfbm9TdGFydCkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxuICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICAgIF9kaXNwYXRjaCgnc3RhcnQnKTtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cblxuICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmFkZEpvYl0gV3JvbmcgYXJndW1lbnRzLicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogS2lsbHMgb25lIG9yIG1vcmUgam9icywgaW5kaWNhdGVkIGJ5IHRoZWlyIGlkcy4gSXQgaXMgb25seSBwb3NzaWJsZSB0b1xuICAgKiBraWxsIHJ1bm5pbmcgam9icyBvciB3YWl0aW5nIGpvYnMuIElmIHlvdSB0cnkgdG8ga2lsbCBhIGpvYiB0aGF0IGRvZXMgbm90XG4gICAqIGV4aXN0IG9yIHRoYXQgaXMgYWxyZWFkeSBraWxsZWQsIGEgd2FybmluZyB3aWxsIGJlIHRocm93bi5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl8U3RyaW5nfSB2MSBBIHN0cmluZyBqb2IgaWQgb3IgYW4gYXJyYXkgb2Ygam9iIGlkcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9raWxsSm9iKHYxKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGssXG4gICAgICAgIGEsXG4gICAgICAgIGpvYixcbiAgICAgICAgZm91bmQgPSBmYWxzZTtcblxuICAgIC8vIEFycmF5IG9mIGpvYiBpZHM6XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKVxuICAgICAgZm9yIChpID0gMCwgbCA9IHYxLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgX2tpbGxKb2IodjFbaV0pO1xuXG4gICAgLy8gT25lIGpvYidzIGlkOlxuICAgIGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGEgPSBbX3J1bm5pbmdKb2JzLCBfd2FpdGluZ0pvYnMsIF9qb2JzXTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBqb2IgZnJvbSB0aGUgaGFzaGVzOlxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodjEgaW4gYVtpXSkge1xuICAgICAgICAgIGpvYiA9IGFbaV1bdjFdO1xuXG4gICAgICAgICAgaWYgKF9wYXJhbWV0ZXJzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSAnZG9uZSc7XG4gICAgICAgICAgICBfZG9uZUpvYnMucHVzaChqb2IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9kaXNwYXRjaCgnam9iRW5kZWQnLCBfX2Nsb25lKGpvYikpO1xuICAgICAgICAgIGRlbGV0ZSBhW2ldW3YxXTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygam9iLmVuZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGpvYi5lbmQoKTtcblxuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIHByaW9yaXRpZXMgYXJyYXk6XG4gICAgICBhID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoYVtpXS5pZCA9PT0gdjEpIHtcbiAgICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjb25yYWQua2lsbEpvYl0gSm9iIFwiJyArIHYxICsgJ1wiIG5vdCBmb3VuZC4nKTtcblxuICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpbGxzIGV2ZXJ5IHJ1bm5pbmcsIHdhaXRpbmcsIGFuZCBqdXN0IGFkZGVkIGpvYnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfa2lsbEFsbCgpIHtcbiAgICB2YXIgayxcbiAgICAgICAgam9icyA9IF9fZXh0ZW5kKF9qb2JzLCBfcnVubmluZ0pvYnMsIF93YWl0aW5nSm9icyk7XG5cbiAgICAvLyBUYWtlIGV2ZXJ5IGpvYnMgYW5kIHB1c2ggdGhlbSBpbnRvIHRoZSBfZG9uZUpvYnMgb2JqZWN0OlxuICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KVxuICAgICAgZm9yIChrIGluIGpvYnMpIHtcbiAgICAgICAgam9ic1trXS5zdGF0dXMgPSAnZG9uZSc7XG4gICAgICAgIF9kb25lSm9icy5wdXNoKGpvYnNba10pO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygam9ic1trXS5lbmQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgam9ic1trXS5lbmQoKTtcbiAgICAgIH1cblxuICAgIC8vIFJlaW5pdGlhbGl6ZSB0aGUgZGlmZmVyZW50IGpvYnMgbGlzdHM6XG4gICAgX2pvYnMgPSB7fTtcbiAgICBfd2FpdGluZ0pvYnMgPSB7fTtcbiAgICBfcnVubmluZ0pvYnMgPSB7fTtcbiAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcblxuICAgIC8vIEluIGNhc2Ugc29tZSBqb2JzIGFyZSBhZGRlZCByaWdodCBhZnRlciB0aGUga2lsbDpcbiAgICBfaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBqb2Igd2l0aCB0aGUgc3BlY2lmaWVkIGlkIGlzIGN1cnJlbnRseSBydW5uaW5nIG9yXG4gICAqIHdhaXRpbmcsIGFuZCBmYWxzZSBlbHNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBpZCBUaGUgaWQgb2YgdGhlIGpvYi5cbiAgICogQHJldHVybiB7P09iamVjdH0gUmV0dXJucyB0aGUgam9iIG9iamVjdCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBmdW5jdGlvbiBfaGFzSm9iKGlkKSB7XG4gICAgdmFyIGpvYiA9IF9qb2JzW2lkXSB8fCBfcnVubmluZ0pvYnNbaWRdIHx8IF93YWl0aW5nSm9ic1tpZF07XG4gICAgcmV0dXJuIGpvYiA/IF9fZXh0ZW5kKGpvYikgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgc2V0IHRoZSBzZXR0aW5nIHNwZWNpZmllZCBieSBcInYxXCIgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuICAgKiBieSBcInYyXCIgaWYgYm90aCBhcmUgZ2l2ZW4sIGFuZCBlbHNlIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGVcbiAgICogc2V0dGluZ3MgXCJ2MVwiLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgdjEgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gIHs/Kn0gICAgICAgdjIgRXZlbnR1YWxseSwgYSB2YWx1ZSB0byBzZXQgdG8gdGhlIHNwZWNpZmllZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXG4gICAqIEByZXR1cm4ge09iamVjdHwqfSBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgc2V0dGluZ3MgdmFsdWUgaWYgXCJ2MlwiIGlzIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgICAgZ2l2ZW4sIGFuZCBjb25yYWQgZWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9zZXR0aW5ncyh2MSwgdjIpIHtcbiAgICB2YXIgbztcblxuICAgIGlmICh0eXBlb2YgYTEgPT09ICdzdHJpbmcnICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gX3BhcmFtZXRlcnNbYTFdO1xuICAgIGVsc2Uge1xuICAgICAgbyA9ICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpID9cbiAgICAgICAgYTEgfHwge30gOlxuICAgICAgICB7fTtcbiAgICAgIGlmICh0eXBlb2YgYTEgPT09ICdzdHJpbmcnKVxuICAgICAgICBvW2ExXSA9IGEyO1xuXG4gICAgICBmb3IgKHZhciBrIGluIG8pXG4gICAgICAgIGlmIChvW2tdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3BhcmFtZXRlcnNba10gPSBvW2tdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZGVsZXRlIF9wYXJhbWV0ZXJzW2tdO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbnJhZCBpcyBjdXJyZW50bHkgcnVubmluZywgYW5kIGZhbHNlIGVsc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgX2lzUnVubmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRJc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIF9pc1J1bm5pbmc7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWZlcmVuY2UgZXZlcnkgam9iIHRoYXQgaXMgc3RvcmVkIGluIHRoZSBfZG9uZUpvYnMgb2JqZWN0LiBJdCB3aWxsXG4gICAqIG5vdCBiZSBwb3NzaWJsZSBhbnltb3JlIHRvIGdldCBzdGF0cyBhYm91dCB0aGVzZSBqb2JzLCBidXQgaXQgd2lsbCByZWxlYXNlXG4gICAqIHRoZSBtZW1vcnkuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfY2xlYXJIaXN0b3J5KCkge1xuICAgIF9kb25lSm9icyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzbmFwc2hvdCBvZiBldmVyeSBkYXRhIGFib3V0IGpvYnMgdGhhdCB3YWl0IHRvIGJlIHN0YXJ0ZWQsIGFyZVxuICAgKiBjdXJyZW50bHkgcnVubmluZyBvciBhcmUgZG9uZS5cbiAgICpcbiAgICogSXQgaXMgcG9zc2libGUgdG8gZ2V0IG9ubHkgcnVubmluZywgd2FpdGluZyBvciBkb25lIGpvYnMgYnkgZ2l2aW5nXG4gICAqIFwicnVubmluZ1wiLCBcIndhaXRpbmdcIiBvciBcImRvbmVcIiBhcyBmaXN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGdldCBldmVyeSBqb2Igd2l0aCBhIHNwZWNpZmllZCBpZCBieSBnaXZpbmcgaXQgYXNcbiAgICogZmlyc3QgYXJndW1lbnQuIEFsc28sIHVzaW5nIGEgUmVnRXhwIGluc3RlYWQgb2YgYW4gaWQgd2lsbCByZXR1cm4gZXZlcnlcbiAgICogam9icyB3aG9zZSBpZHMgbWF0Y2ggdGhlIFJlZ0V4cC4gQW5kIHRoZXNlIHR3byBsYXN0IHVzZSBjYXNlcyB3b3JrIGFzIHdlbGxcbiAgICogYnkgZ2l2aW5nIGJlZm9yZSBcInJ1bm5pbmdcIiwgXCJ3YWl0aW5nXCIgb3IgXCJkb25lXCIuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgdGhlIG1hdGNoaW5nIGpvYnMuXG4gICAqXG4gICAqIFNvbWUgY2FsbCBleGFtcGxlczpcbiAgICogKioqKioqKioqKioqKioqKioqKlxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3dhaXRpbmcnKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ2RvbmUnKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ215Sm9iJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKC90ZXN0LylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJywgJ215UnVubmluZ0pvYicpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycsIC90ZXN0LylcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTdGF0cyh2MSwgdjIpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGlzUGF0dGVyblN0cmluZztcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgc3RhdHMgPSBbXTtcblxuICAgICAgZm9yIChrIGluIF9qb2JzKVxuICAgICAgICBzdGF0cy5wdXNoKF9qb2JzW2tdKTtcblxuICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgc3RhdHMucHVzaChfd2FpdGluZ0pvYnNba10pO1xuXG4gICAgICBmb3IgKGsgaW4gX3J1bm5pbmdKb2JzKVxuICAgICAgICBzdGF0cy5wdXNoKF9ydW5uaW5nSm9ic1trXSk7XG5cbiAgICAgIHN0YXRzID0gc3RhdHMuY29uY2F0KF9kb25lSm9icyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpXG4gICAgICBzd2l0Y2ggKHYxKSB7XG4gICAgICAgIGNhc2UgJ3dhaXRpbmcnOlxuICAgICAgICAgIHN0YXRzID0gX19vYmplY3RWYWx1ZXMoX3dhaXRpbmdKb2JzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnVubmluZyc6XG4gICAgICAgICAgc3RhdHMgPSBfX29iamVjdFZhbHVlcyhfcnVubmluZ0pvYnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICBzdGF0cyA9IF9kb25lSm9icztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwYXR0ZXJuID0gdjE7XG4gICAgICB9XG5cbiAgICBpZiAodjEgaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICBwYXR0ZXJuID0gdjE7XG5cbiAgICBpZiAoIXBhdHRlcm4gJiYgKHR5cGVvZiB2MiA9PT0gJ3N0cmluZycgfHwgdjIgaW5zdGFuY2VvZiBSZWdFeHApKVxuICAgICAgcGF0dGVybiA9IHYyO1xuXG4gICAgLy8gRmlsdGVyIGpvYnMgaWYgYSBwYXR0ZXJuIGlzIGdpdmVuOlxuICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICBpc1BhdHRlcm5TdHJpbmcgPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZyc7XG5cbiAgICAgIGlmIChzdGF0cyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGEgPSBzdGF0cztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gW107XG5cbiAgICAgICAgZm9yIChrIGluIHN0YXRzKVxuICAgICAgICAgIGEgPSBhLmNvbmNhdChzdGF0c1trXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gW107XG5cbiAgICAgICAgZm9yIChrIGluIF9qb2JzKVxuICAgICAgICAgIGEucHVzaChfam9ic1trXSk7XG5cbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgICBhLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcblxuICAgICAgICBmb3IgKGsgaW4gX3J1bm5pbmdKb2JzKVxuICAgICAgICAgIGEucHVzaChfcnVubmluZ0pvYnNba10pO1xuXG4gICAgICAgIGEgPSBhLmNvbmNhdChfZG9uZUpvYnMpO1xuICAgICAgfVxuXG4gICAgICBzdGF0cyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoaXNQYXR0ZXJuU3RyaW5nID8gYVtpXS5pZCA9PT0gcGF0dGVybiA6IGFbaV0uaWQubWF0Y2gocGF0dGVybikpXG4gICAgICAgICAgc3RhdHMucHVzaChhW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX19jbG9uZShzdGF0cyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUT09MUyBGVU5DVElPTlM6XG4gICAqICoqKioqKioqKioqKioqKipcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW55IG51bWJlciBvZiBvYmplY3RzIGFzIGFyZ3VtZW50cywgY29waWVzIGZyb20gZWFjaFxuICAgKiBvZiB0aGVzZSBvYmplY3RzIGVhY2ggcGFpciBrZXkvdmFsdWUgaW50byBhIG5ldyBvYmplY3QsIGFuZCBmaW5hbGx5XG4gICAqIHJldHVybnMgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBhcmd1bWVudHMgYXJlIHBhcnNlZCBmcm9tIHRoZSBsYXN0IG9uZSB0byB0aGUgZmlyc3Qgb25lLCBzdWNoIHRoYXRcbiAgICogd2hlbiB0d28gb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiB2YXIgbzEgPSB7XG4gICAqICA+ICAgICAgIGE6IDEsXG4gICAqICA+ICAgICAgIGI6IDIsXG4gICAqICA+ICAgICAgIGM6ICczJ1xuICAgKiAgPiAgICAgfSxcbiAgICogID4gICAgIG8yID0ge1xuICAgKiAgPiAgICAgICBjOiAnNCcsXG4gICAqICA+ICAgICAgIGQ6IFsgNSBdXG4gICAqICA+ICAgICB9O1xuICAgKiAgPiBfX2V4dGVuZChvMSwgbzIpO1xuICAgKiAgPiAvLyBSZXR1cm5zOiB7XG4gICAqICA+IC8vICAgYTogMSxcbiAgICogID4gLy8gICBiOiAyLFxuICAgKiAgPiAvLyAgIGM6ICczJyxcbiAgICogID4gLy8gICBkOiBbIDUgXVxuICAgKiAgPiAvLyB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3QrfSBBbnkgbnVtYmVyIG9mIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gIFRoZSBtZXJnZWQgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX19leHRlbmQoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGssXG4gICAgICAgIHJlcyA9IHt9LFxuICAgICAgICBsID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGwgLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGZvciAoayBpbiBhcmd1bWVudHNbaV0pXG4gICAgICAgIHJlc1trXSA9IGFyZ3VtZW50c1tpXVtrXTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBzaW1wbHkgY2xvbmVzIGFuIG9iamVjdC4gVGhpcyBvYmplY3QgbXVzdCBjb250YWluIG9ubHlcbiAgICogb2JqZWN0cywgYXJyYXlzIGFuZCBpbW11dGFibGUgdmFsdWVzLiBTaW5jZSBpdCBpcyBub3QgcHVibGljLCBpdCBkb2VzIG5vdFxuICAgKiBkZWFsIHdpdGggY3ljbGljIHJlZmVyZW5jZXMsIERPTSBlbGVtZW50cyBhbmQgaW5zdGFudGlhdGVkIG9iamVjdHMgLSBzb1xuICAgKiB1c2UgaXQgY2FyZWZ1bGx5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuICAgKi9cbiAgZnVuY3Rpb24gX19jbG9uZShpdGVtKSB7XG4gICAgdmFyIHJlc3VsdCwgaSwgaywgbDtcblxuICAgIGlmICghaXRlbSlcbiAgICAgIHJldHVybiBpdGVtO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZW0ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaChfX2Nsb25lKGl0ZW1baV0pKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGkgaW4gaXRlbSlcbiAgICAgICAgcmVzdWx0W2ldID0gX19jbG9uZShpdGVtW2ldKTtcbiAgICB9IGVsc2VcbiAgICAgIHJlc3VsdCA9IGl0ZW07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBUaGUgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtBcnJheX0gIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfX29iamVjdFZhbHVlcyhvKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGEgPSBbXTtcblxuICAgIGZvciAoayBpbiBvKVxuICAgICAgYS5wdXNoKG9ba10pO1xuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICAvKipcbiAgICogQSBzaG9ydCBcIkRhdGUubm93KClcIiBwb2x5ZmlsbC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB0aW1lIChpbiBtcykuXG4gICAqL1xuICBmdW5jdGlvbiBfX2RhdGVOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIGZvciB0aGUgQXJyYXkuaXNBcnJheSBmdW5jdGlvbjpcbiAgICovXG4gIGlmICghQXJyYXkuaXNBcnJheSlcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVCBQVUJMSUMgQVBJOlxuICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICovXG4gIHZhciBjb25yYWQgPSB7XG4gICAgaGFzSm9iOiBfaGFzSm9iLFxuICAgIGFkZEpvYjogX2FkZEpvYixcbiAgICBraWxsSm9iOiBfa2lsbEpvYixcbiAgICBraWxsQWxsOiBfa2lsbEFsbCxcbiAgICBzZXR0aW5nczogX3NldHRpbmdzLFxuICAgIGdldFN0YXRzOiBfZ2V0U3RhdHMsXG4gICAgaXNSdW5uaW5nOiBfZ2V0SXNSdW5uaW5nLFxuICAgIGNsZWFySGlzdG9yeTogX2NsZWFySGlzdG9yeSxcblxuICAgIC8vIEV2ZW50cyBtYW5hZ2VtZW50OlxuICAgIGJpbmQ6IF9iaW5kLFxuICAgIHVuYmluZDogX3VuYmluZCxcblxuICAgIC8vIFZlcnNpb246XG4gICAgdmVyc2lvbjogJzAuMS4wJ1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjb25yYWQ7XG4gICAgZXhwb3J0cy5jb25yYWQgPSBjb25yYWQ7XG4gIH1cbiAgZ2xvYmFsLmNvbnJhZCA9IGNvbnJhZDtcbn0pKHRoaXMpO1xuXG4vLyBIYXJkY29kZWQgZXhwb3J0IGZvciB0aGUgbm9kZS5qcyB2ZXJzaW9uOlxudmFyIHNpZ21hID0gdGhpcy5zaWdtYSxcbiAgICBjb25yYWQgPSB0aGlzLmNvbnJhZDtcblxuc2lnbWEuY29ucmFkID0gY29ucmFkO1xuXG4vLyBEaXJ0eSBwb2x5ZmlsbHMgdG8gcGVybWl0IHNpZ21hIHVzYWdlIGluIG5vZGVcbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnKVxuICBIVE1MRWxlbWVudCA9IGZ1bmN0aW9uKCkge307XG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgd2luZG93ID0ge1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc2lnbWE7XG4gIGV4cG9ydHMuc2lnbWEgPSBzaWdtYTtcbn1cblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHZhciBfcm9vdCA9IHRoaXM7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMgPSBzaWdtYS51dGlscyB8fCB7fTtcblxuICAvKipcbiAgICogTUlTQyBVVElMUzpcbiAgICovXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFueSBudW1iZXIgb2Ygb2JqZWN0cyBhcyBhcmd1bWVudHMsIGNvcGllcyBmcm9tIGVhY2hcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxuICAgKiByZXR1cm5zIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XG4gICAqIHdoZW4gc2V2ZXJhbCBvYmplY3RzIGhhdmUga2V5cyBpbiBjb21tb24sIHRoZSBcImVhcmxpZXN0XCIgb2JqZWN0IHdpbnMuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHZhciBvMSA9IHtcbiAgICogID4gICAgICAgYTogMSxcbiAgICogID4gICAgICAgYjogMixcbiAgICogID4gICAgICAgYzogJzMnXG4gICAqICA+ICAgICB9LFxuICAgKiAgPiAgICAgbzIgPSB7XG4gICAqICA+ICAgICAgIGM6ICc0JyxcbiAgICogID4gICAgICAgZDogWyA1IF1cbiAgICogID4gICAgIH07XG4gICAqICA+IHNpZ21hLnV0aWxzLmV4dGVuZChvMSwgbzIpO1xuICAgKiAgPiAvLyBSZXR1cm5zOiB7XG4gICAqICA+IC8vICAgYTogMSxcbiAgICogID4gLy8gICBiOiAyLFxuICAgKiAgPiAvLyAgIGM6ICczJyxcbiAgICogID4gLy8gICBkOiBbIDUgXVxuICAgKiAgPiAvLyB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3QrfSBBbnkgbnVtYmVyIG9mIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gIFRoZSBtZXJnZWQgb2JqZWN0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGssXG4gICAgICAgIHJlcyA9IHt9LFxuICAgICAgICBsID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGwgLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGZvciAoayBpbiBhcmd1bWVudHNbaV0pXG4gICAgICAgIHJlc1trXSA9IGFyZ3VtZW50c1tpXVtrXTtcblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZSAoaW4gbXMpLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZGF0ZU5vdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGFrZXMgYSBwYWNrYWdlIG5hbWUgYXMgcGFyYW1ldGVyIGFuZCBjaGVja3MgYXQgZWFjaCBsZWJlbCBpZiBpdCBleGlzdHMsXG4gICAqIGFuZCBpZiBpdCBkb2VzIG5vdCwgY3JlYXRlcyBpdC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gc2lnbWEudXRpbHMucGtnKCdhLmIuYycpO1xuICAgKiAgPiBhLmIuYztcbiAgICogID4gLy8gT2JqZWN0IHt9O1xuICAgKiAgPlxuICAgKiAgPiBzaWdtYS51dGlscy5wa2coJ2EuYi5kJyk7XG4gICAqICA+IGEuYjtcbiAgICogID4gLy8gT2JqZWN0IHsgYzoge30sIGQ6IHt9IH07XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGtnTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjcmVhdGUvZmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSByZWxhdGVkIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2cgPSBmdW5jdGlvbihwa2dOYW1lKSB7XG4gICAgcmV0dXJuIChwa2dOYW1lIHx8ICcnKS5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbihjb250ZXh0LCBvYmpOYW1lKSB7XG4gICAgICByZXR1cm4gKG9iak5hbWUgaW4gY29udGV4dCkgP1xuICAgICAgICBjb250ZXh0W29iak5hbWVdIDpcbiAgICAgICAgKGNvbnRleHRbb2JqTmFtZV0gPSB7fSk7XG4gICAgfSwgX3Jvb3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIGluY3JlbWVudGFsIG51bWJlciBJRC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcbiAgICogID4gLy8gMTtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcbiAgICogID4gLy8gMjtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcbiAgICogID4gLy8gMztcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwa2dOYW1lIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGNyZWF0ZS9maW5kLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHJlbGF0ZWQgcGFja2FnZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmlkID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKytpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gaGV4YSBjb2xvciAoZm9yIGluc3RhbmNlIFwiI2ZmY2MwMFwiIG9yIFwiI2ZjMFwiKSBvciBhXG4gICAqIHJnYiAvIHJnYmEgY29sb3IgKGxpa2UgXCJyZ2IoMjU1LDI1NSwxMilcIiBvciBcInJnYmEoMjU1LDI1NSwxMiwxKVwiKSBhbmRcbiAgICogcmV0dXJucyBhbiBpbnRlZ2VyIGVxdWFsIHRvIFwiciAqIDI1NSAqIDI1NSArIGcgKiAyNTUgKyBiXCIsIHRvIGdhaW4gc29tZVxuICAgKiBtZW1vcnkgaW4gdGhlIGRhdGEgZ2l2ZW4gdG8gV2ViR0wgc2hhZGVycy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBmdW5jdGlvbiBhY3R1YWxseSBjYWNoZXMgaXRzIHJlc3VsdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWwgVGhlIGhleGEgb3IgcmdiYSBjb2xvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIG51bWJlciB2YWx1ZS5cbiAgICovXG4gIHZhciBmbG9hdENvbG9yQ2FjaGUgPSB7fTtcblxuICBzaWdtYS51dGlscy5mbG9hdENvbG9yID0gZnVuY3Rpb24odmFsKSB7XG5cbiAgICAvLyBJcyB0aGUgY29sb3IgYWxyZWFkeSBjb21wdXRlZD9cbiAgICBpZiAoZmxvYXRDb2xvckNhY2hlW3ZhbF0pXG4gICAgICByZXR1cm4gZmxvYXRDb2xvckNhY2hlW3ZhbF07XG5cbiAgICB2YXIgb3JpZ2luYWwgPSB2YWwsXG4gICAgICAgIHIgPSAwLFxuICAgICAgICBnID0gMCxcbiAgICAgICAgYiA9IDA7XG5cbiAgICBpZiAodmFsWzBdID09PSAnIycpIHtcbiAgICAgIHZhbCA9IHZhbC5zbGljZSgxKTtcblxuICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDApLCAxNik7XG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgwKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDMpLCAxNik7XG4gICAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDQpICsgdmFsLmNoYXJBdCg1KSwgMTYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsLm1hdGNoKC9eICpyZ2JhPyAqXFwoLykpIHtcbiAgICAgIHZhbCA9IHZhbC5tYXRjaChcbiAgICAgICAgL14gKnJnYmE/ICpcXCggKihbMC05XSopICosICooWzAtOV0qKSAqLCAqKFswLTldKikgKigsLiopP1xcKSAqJC9cbiAgICAgICk7XG4gICAgICByID0gK3ZhbFsxXTtcbiAgICAgIGcgPSArdmFsWzJdO1xuICAgICAgYiA9ICt2YWxbM107XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gKFxuICAgICAgciAqIDI1NiAqIDI1NiArXG4gICAgICBnICogMjU2ICtcbiAgICAgIGJcbiAgICApO1xuXG4gICAgLy8gQ2FjaGluZyB0aGUgY29sb3JcbiAgICBmbG9hdENvbG9yQ2FjaGVbb3JpZ2luYWxdID0gY29sb3I7XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH07XG5cbiAgICAvKipcbiAgICogUGVyZm9ybSBhIHpvb20gaW50byBhIGNhbWVyYSwgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiwgdG8gdGhlXG4gICAqIGNvb3JkaW5hdGVzIGluZGljYXRlZCB1c2luZyBhIHNwZWNpZmllZCByYXRpby5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBhbmltYXRpb25cbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/bnVtYmVyfSBkdXJhdGlvbiAgICAgQW4gYW1vdW50IG9mIHRpbWUgdGhhdCBtZWFucyB0aGUgZHVyYXRpb24gb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uIElmIHRoaXMgcGFyYW1ldGVyIGRvZXNuJ3QgZXhpc3QgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tIHdpbGwgYmUgcGVyZm9ybWVkIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgKiAgIHs/ZnVuY3Rpb259IG9uQ29tcGxldGUgQSBmdW5jdGlvbiB0byBwZXJmb3JtIGl0IGFmdGVyIHRoZSBhbmltYXRpb24uIEl0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHBlcmZvcm1lZCBldmVuIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2NhbWVyYX0gICAgIFRoZSBjYW1lcmEgd2hlcmUgcGVyZm9ybSB0aGUgem9vbS5cbiAgICogQHBhcmFtIHt4fSAgICAgICAgICBUaGUgWCBjb29yZGlhbnRpb24gd2hlcmUgdGhlIHpvb20gZ29lcy5cbiAgICogQHBhcmFtIHt5fSAgICAgICAgICBUaGUgWSBjb29yZGlhbnRpb24gd2hlcmUgdGhlIHpvb20gZ29lcy5cbiAgICogQHBhcmFtIHtyYXRpb30gICAgICBUaGUgcmF0aW8gdG8gYXBwbHkgaXQgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHJhdGlvLlxuICAgKiBAcGFyYW0gez9hbmltYXRpb259IEEgZGljdGlvbmFyeSB3aXRoIG9wdGlvbnMgZm9yIGEgcG9zc2libGUgYW5pbWF0aW9uLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuem9vbVRvID0gZnVuY3Rpb24oY2FtZXJhLCB4LCB5LCByYXRpbywgYW5pbWF0aW9uKSB7XG4gICAgdmFyIHNldHRpbmdzID0gY2FtZXJhLnNldHRpbmdzLFxuICAgICAgICBjb3VudCxcbiAgICAgICAgbmV3UmF0aW8sXG4gICAgICAgIGFuaW1hdGlvblNldHRpbmdzLFxuICAgICAgICBjb29yZGluYXRlcztcblxuICAgIC8vIENyZWF0ZSB0aGUgbmV3UmF0aW8gZGVhbGluZyB3aXRoIG1pbiAvIG1heDpcbiAgICBuZXdSYXRpbyA9IE1hdGgubWF4KFxuICAgICAgc2V0dGluZ3MoJ3pvb21NaW4nKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBzZXR0aW5ncygnem9vbU1heCcpLFxuICAgICAgICBjYW1lcmEucmF0aW8gKiByYXRpb1xuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBuZXcgcmF0aW8gaXMgZGlmZmVyZW50IGZyb20gdGhlIGluaXRpYWwgb25lOlxuICAgIGlmIChuZXdSYXRpbyAhPT0gY2FtZXJhLnJhdGlvKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIGNvb3JkaW5hdGVzIHZhcmlhYmxlOlxuICAgICAgcmF0aW8gPSBuZXdSYXRpbyAvIGNhbWVyYS5yYXRpbztcbiAgICAgIGNvb3JkaW5hdGVzID0ge1xuICAgICAgICB4OiB4ICogKDEgLSByYXRpbykgKyBjYW1lcmEueCxcbiAgICAgICAgeTogeSAqICgxIC0gcmF0aW8pICsgY2FtZXJhLnksXG4gICAgICAgIHJhdGlvOiBuZXdSYXRpb1xuICAgICAgfTtcblxuICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uZHVyYXRpb24pIHtcbiAgICAgICAgLy8gQ29tcGxldGUgdGhlIGFuaW1hdGlvbiBzZXRpbmdzOlxuICAgICAgICBjb3VudCA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwoY2FtZXJhKTtcbiAgICAgICAgYW5pbWF0aW9uID0gc2lnbWEudXRpbHMuZXh0ZW5kKFxuICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmc6IGNvdW50ID8gJ3F1YWRyYXRpY091dCcgOiAncXVhZHJhdGljSW5PdXQnXG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShjYW1lcmEsIGNvb3JkaW5hdGVzLCBhbmltYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FtZXJhLmdvVG8oY29vcmRpbmF0ZXMpO1xuICAgICAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5vbkNvbXBsZXRlKVxuICAgICAgICAgIGFuaW1hdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbnRyb2wgcG9pbnQgY29vcmRpbmF0ZXMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTIgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHJldHVybiB7eCx5fSAgICAgICAgVGhlIGNvbnRyb2wgcG9pbnQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoeDEgKyB4MikgLyAyICsgKHkyIC0geTEpIC8gNCxcbiAgICAgIHk6ICh5MSArIHkyKSAvIDIgKyAoeDEgLSB4MikgLyA0XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXG4gICAgKiBhdCBsZW5ndGggdCBpbiB0aGUgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQgIEluIFswLDFdIHRoZSBzdGVwIHBlcmNlbnRhZ2UgdG8gcmVhY2hcbiAgICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHBvaW50IGluIHRoZSBjdXJ2ZSBmcm9tIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZGluZyBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geGkgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geWkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICAqIEByZXR1cm4ge29iamVjdH0gICAge3gseX0uXG4gICovXG4gIHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZSA9IGZ1bmN0aW9uKHQsIHgxLCB5MSwgeDIsIHkyLCB4aSwgeWkpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NjM0NTI4XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGgucG93KDEgLSB0LCAyKSAqIHgxICsgMiAqICgxIC0gdCkgKiB0ICogeGkgKyBNYXRoLnBvdyh0LCAyKSAqIHgyLFxuICAgICAgeTogTWF0aC5wb3coMSAtIHQsIDIpICogeTEgKyAyICogKDEgLSB0KSAqIHQgKiB5aSArIE1hdGgucG93KHQsIDIpICogeTJcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgICogQ29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IHBvc2l0aW9uZWRcbiAgICAqIGF0IGxlbmd0aCB0IGluIHRoZSBjdWJpYyBiZXppZXIgY3VydmUuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXG4gICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb2ludCBpbiB0aGUgY3VydmUgZnJvbSB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAqIEByZXR1cm4ge29iamVjdH0gICAge3gseX0gVGhlIHBvaW50IGF0IHQuXG4gICovXG4gIHNpZ21hLnV0aWxzLmdldFBvaW50T25CZXppZXJDdXJ2ZSA9XG4gICAgZnVuY3Rpb24odCwgeDEsIHkxLCB4MiwgeTIsIGN4LCBjeSwgZHgsIGR5KSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTUzOTc1OTZcbiAgICAvLyBCbGVuZGluZyBmdW5jdGlvbnM6XG4gICAgdmFyIEIwX3QgPSBNYXRoLnBvdygxIC0gdCwgMyksXG4gICAgICAgIEIxX3QgPSAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKSxcbiAgICAgICAgQjJfdCA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCksXG4gICAgICAgIEIzX3QgPSBNYXRoLnBvdyh0LCAzKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoQjBfdCAqIHgxKSArIChCMV90ICogY3gpICsgKEIyX3QgKiBkeCkgKyAoQjNfdCAqIHgyKSxcbiAgICAgIHk6IChCMF90ICogeTEpICsgKEIxX3QgKiBjeSkgKyAoQjJfdCAqIGR5KSArIChCM190ICogeTIpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzIGZvciBhIHNlbGYgbG9vcCAoaS5lLlxuICAgKiB3aGVyZSB0aGUgc3RhcnQgcG9pbnQgaXMgYWxzbyB0aGUgZW5kIHBvaW50KSBjb21wdXRlZCBhcyBhIGN1YmljIGJlemllclxuICAgKiBjdXJ2ZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHNpemUgVGhlIG5vZGUgc2l6ZS5cbiAgICogQHJldHVybiB7eDEseTEseDIseTJ9IFRoZSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oeCAsIHksIHNpemUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHggLSBzaXplICogNyxcbiAgICAgIHkxOiB5LFxuICAgICAgeDI6IHgsXG4gICAgICB5MjogeSArIHNpemUgKiA3XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzIG9mIGEgcGxhbmVcbiAgICogd2l0aCBhbiBvcnRob25vcm1hbCBiYXNpcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTIgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIGV1Y2xpZGlhbiBkaXN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIG9mIHR3byBjaXJjbGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgwICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgZmlyc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkwICBUaGUgWSBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgZmlyc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHIwICBUaGUgcmFkaXVzIG9mIHRoZSBmaXJzdCBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBzZWNvbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgc2Vjb25kXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSByMSAgVGhlIHJhZGl1cyBvZiB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgICogQHJldHVybiB7eGkseWl9ICAgICAgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0Q2lyY2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEyMjE5ODAyXG4gICAgdmFyIGEsIGR4LCBkeSwgZCwgaCwgcngsIHJ5LCB4MiwgeTI7XG5cbiAgICAvLyBkeCBhbmQgZHkgYXJlIHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgY2lyY2xlXG4gICAgLy8gY2VudGVyczpcbiAgICBkeCA9IHgxIC0geDA7XG4gICAgZHkgPSB5MSAtIHkwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzdHJhaWdodC1saW5lIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnM6XG4gICAgZCA9IE1hdGguc3FydCgoZHkgKiBkeSkgKyAoZHggKiBkeCkpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHNvbHZhYmlsaXR5OlxuICAgIGlmIChkID4gKHIwICsgcjEpKSB7XG4gICAgICAgIC8vIE5vIHNvbHV0aW9uLiBjaXJjbGVzIGRvIG5vdCBpbnRlcnNlY3QuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGQgPCBNYXRoLmFicyhyMCAtIHIxKSkge1xuICAgICAgICAvLyBObyBzb2x1dGlvbi4gb25lIGNpcmNsZSBpcyBjb250YWluZWQgaW4gdGhlIG90aGVyLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8ncG9pbnQgMicgaXMgdGhlIHBvaW50IHdoZXJlIHRoZSBsaW5lIHRocm91Z2ggdGhlIGNpcmNsZSBpbnRlcnNlY3Rpb25cbiAgICAvLyBwb2ludHMgY3Jvc3NlcyB0aGUgbGluZSBiZXR3ZWVuIHRoZSBjaXJjbGUgY2VudGVycy5cblxuICAgIC8vIERldGVybWluZSB0aGUgZGlzdGFuY2UgZnJvbSBwb2ludCAwIHRvIHBvaW50IDI6XG4gICAgYSA9ICgocjAgKiByMCkgLSAocjEgKiByMSkgKyAoZCAqIGQpKSAvICgyLjAgKiBkKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgY29vcmRpbmF0ZXMgb2YgcG9pbnQgMjpcbiAgICB4MiA9IHgwICsgKGR4ICogYSAvIGQpO1xuICAgIHkyID0geTAgKyAoZHkgKiBhIC8gZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMiB0byBlaXRoZXIgb2YgdGhlIGludGVyc2VjdGlvblxuICAgIC8vIHBvaW50czpcbiAgICBoID0gTWF0aC5zcXJ0KChyMCAqIHIwKSAtIChhICogYSkpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvZmZzZXRzIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZyb20gcG9pbnQgMjpcbiAgICByeCA9IC1keSAqIChoIC8gZCk7XG4gICAgcnkgPSBkeCAqIChoIC8gZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGFic29sdXRlIGludGVyc2VjdGlvbiBwb2ludHM6XG4gICAgdmFyIHhpID0geDIgKyByeDtcbiAgICB2YXIgeGlfcHJpbWUgPSB4MiAtIHJ4O1xuICAgIHZhciB5aSA9IHkyICsgcnk7XG4gICAgdmFyIHlpX3ByaW1lID0geTIgLSByeTtcblxuICAgIHJldHVybiB7eGk6IHhpLCB4aV9wcmltZTogeGlfcHJpbWUsIHlpOiB5aSwgeWlfcHJpbWU6IHlpX3ByaW1lfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBsaW5lIHNlZ21lbnQuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZXBzaWxvbiBUaGUgcHJlY2lzaW9uIChjb25zaWRlciB0aGUgbGluZSB0aGlja25lc3MpLlxuICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIFRydWUgaWYgcG9pbnQgaXMgXCJjbG9zZSB0b1wiIHRoZSBsaW5lXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqL1xuICBzaWdtYS51dGlscy5pc1BvaW50T25TZWdtZW50ID0gZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGVwc2lsb24pIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMjgxMjJcbiAgICB2YXIgY3Jvc3NQcm9kdWN0ID0gTWF0aC5hYnMoKHkgLSB5MSkgKiAoeDIgLSB4MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSksXG4gICAgICAgIGQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIHgyLCB5MiksXG4gICAgICAgIG5Dcm9zc1Byb2R1Y3QgPSBjcm9zc1Byb2R1Y3QgLyBkOyAvLyBub3JtYWxpemVkIGNyb3NzIHByb2R1Y3RcblxuICAgIHJldHVybiAobkNyb3NzUHJvZHVjdCA8IGVwc2lsb24gJiZcbiAgICAgTWF0aC5taW4oeDEsIHgyKSA8PSB4ICYmIHggPD0gTWF0aC5tYXgoeDEsIHgyKSAmJlxuICAgICBNYXRoLm1pbih5MSwgeTIpIDw9IHkgJiYgeSA8PSBNYXRoLm1heCh5MSwgeTIpKTtcbiAgfTtcblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIHNlZ21lbnQgd2l0aCBhIHRoaWNrbmVzcy5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B4ICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmICh4LHkpIGlzIG9uIHRoZSBjdXJ2ZSBzZWdtZW50LFxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uUXVhZHJhdGljQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSwgZXBzaWxvbikge1xuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxuICAgIC8vIHByZXZlbnRpbmcgZm9yIG1vcmUgY29zdGx5IGNvbXB1dGF0aW9uOlxuICAgIHZhciBkUDFQMiA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoTWF0aC5hYnMoeCAtIHgxKSA+IGRQMVAyIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFQMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MSwgeTEpLFxuICAgICAgICBkUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MiwgeTIpLFxuICAgICAgICB0ID0gMC41LFxuICAgICAgICByID0gKGRQMSA8IGRQMikgPyAtMC4wMSA6IDAuMDEsXG4gICAgICAgIHJUaHJlc2hvbGQgPSAwLjAwMSxcbiAgICAgICAgaSA9IDEwMCxcbiAgICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUodCwgeDEsIHkxLCB4MiwgeTIsIGNweCwgY3B5KSxcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcbiAgICAgICAgb2xkX2R0O1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXG4gICAgLy8gcG9pbnQgb2YgdGhlIGN1cnZlLCBzdGFydGluZyBmcm9tIHQ9MC41LlxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxuICAgIHdoaWxlIChpLS0gPiAwICYmXG4gICAgICB0ID49IDAgJiYgdCA8PSAxICYmXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcbiAgICAgIG9sZF9kdCA9IGR0O1xuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUodCwgeDEsIHkxLCB4MiwgeTIsIGNweCwgY3B5KTtcbiAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSk7XG5cbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xuICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IGRpcmVjdGlvbjpcbiAgICAgICAgLy8gaGFsZnN0ZXAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICByID0gLXIgLyAyO1xuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XG4gICAgICAgIC8vIG9vcHMsIHdlJ3ZlIGdvbmUgdG9vIGZhcjpcbiAgICAgICAgLy8gcmV2ZXJ0IHdpdGggYSBoYWxmc3RlcFxuICAgICAgICByID0gciAvIDI7XG4gICAgICAgIGR0ID0gb2xkX2R0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2dyZXNzOlxuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcbiAgfTtcblxuXG4gIC8qKlxuICAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBvbiBhIGN1YmljIGJlemllciBjdXJ2ZSBzZWdtZW50IHdpdGggYSB0aGlja25lc3MuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweDEgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgMXN0IGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweTEgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgMXN0IGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweDIgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgMm5kIGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweTIgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgMm5kIGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmICh4LHkpIGlzIG9uIHRoZSBjdXJ2ZSBzZWdtZW50LFxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uQmV6aWVyQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBlcHNpbG9uKSB7XG4gICAgLy8gRmFpbHMgaWYgdGhlIHBvaW50IGlzIHRvbyBmYXIgZnJvbSB0aGUgZXh0cmVtaXRpZXMgb2YgdGhlIHNlZ21lbnQsXG4gICAgLy8gcHJldmVudGluZyBmb3IgbW9yZSBjb3N0bHkgY29tcHV0YXRpb246XG4gICAgdmFyIGRQMUNQMSA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgY3B4MSwgY3B5MSk7XG4gICAgaWYgKE1hdGguYWJzKHggLSB4MSkgPiBkUDFDUDEgfHwgTWF0aC5hYnMoeSAtIHkxKSA+IGRQMUNQMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MSwgeTEpLFxuICAgICAgICBkUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MiwgeTIpLFxuICAgICAgICB0ID0gMC41LFxuICAgICAgICByID0gKGRQMSA8IGRQMikgPyAtMC4wMSA6IDAuMDEsXG4gICAgICAgIHJUaHJlc2hvbGQgPSAwLjAwMSxcbiAgICAgICAgaSA9IDEwMCxcbiAgICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgICAgdCwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIpLFxuICAgICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpLFxuICAgICAgICBvbGRfZHQ7XG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBtaW5pbWl6ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBjdXJ2ZS4gSXRcbiAgICAvLyBmaW5kIHRoZSBvcHRpbWFsIHQgdmFsdWUgd2hlcmUgdD0wIGlzIHRoZSBzdGFydCBwb2ludCBhbmQgdD0xIGlzIHRoZSBlbmRcbiAgICAvLyBwb2ludCBvZiB0aGUgY3VydmUsIHN0YXJ0aW5nIGZyb20gdD0wLjUuXG4gICAgLy8gSXQgdGVybWluYXRlcyBiZWNhdXNlIGl0IHJ1bnMgYSBtYXhpbXVtIG9mIGkgaW50ZXJhdGlvbnMuXG4gICAgd2hpbGUgKGktLSA+IDAgJiZcbiAgICAgIHQgPj0gMCAmJiB0IDw9IDEgJiZcbiAgICAgIChkdCA+IGVwc2lsb24pICYmXG4gICAgICAociA+IHJUaHJlc2hvbGQgfHwgciA8IC1yVGhyZXNob2xkKSkge1xuICAgICAgb2xkX2R0ID0gZHQ7XG4gICAgICBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25CZXppZXJDdXJ2ZShcbiAgICAgICAgdCwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIpO1xuICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KTtcblxuICAgICAgaWYgKGR0ID4gb2xkX2R0KSB7XG4gICAgICAgIC8vIG5vdCB0aGUgcmlnaHQgZGlyZWN0aW9uOlxuICAgICAgICAvLyBoYWxmc3RlcCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgIHIgPSAtciAvIDI7XG4gICAgICAgIHQgKz0gcjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHQgKyByIDwgMCB8fCB0ICsgciA+IDEpIHtcbiAgICAgICAgLy8gb29wcywgd2UndmUgZ29uZSB0b28gZmFyOlxuICAgICAgICAvLyByZXZlcnQgd2l0aCBhIGhhbGZzdGVwXG4gICAgICAgIHIgPSByIC8gMjtcbiAgICAgICAgZHQgPSBvbGRfZHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvZ3Jlc3M6XG4gICAgICAgIHQgKz0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZHQgPCBlcHNpbG9uO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqICoqKioqKioqKioqKlxuICAgKiBFVkVOVFMgVVRJTFM6XG4gICAqICoqKioqKioqKioqKlxuICAgKi9cbiAgLyoqXG4gICAqIEhlcmUgYXJlIHNvbWUgdXNlZnVsIGZ1bmN0aW9ucyB0byB1bmlmeSBleHRyYWN0aW9uIG9mIHRoZSBpbmZvcm1hdGlvbiB3ZVxuICAgKiBuZWVkIHdpdGggbW91c2UgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMsIGZyb20gZGlmZmVyZW50IGJyb3dzZXJzOlxuICAgKi9cblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWCBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFggdmFsdWUgb2YgdGhlIG1vdXNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0WCA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUub2Zmc2V0WCAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WCkgfHxcbiAgICAgIChlLmxheWVyWCAhPT0gdW5kZWZpbmVkICYmIGUubGF5ZXJYKSB8fFxuICAgICAgKGUuY2xpZW50WCAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WClcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBsb2NhbCBZIHBvc2l0aW9uIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgbG9jYWwgWSB2YWx1ZSBvZiB0aGUgbW91c2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRZID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoZS5vZmZzZXRZICE9PSB1bmRlZmluZWQgJiYgZS5vZmZzZXRZKSB8fFxuICAgICAgKGUubGF5ZXJZICE9PSB1bmRlZmluZWQgJiYgZS5sYXllclkpIHx8XG4gICAgICAoZS5jbGllbnRZICE9PSB1bmRlZmluZWQgJiYgZS5jbGllbnRZKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBwaXhlbCByYXRpbyBvZiB0aGUgc2NyZWVuLiBUYWtpbmcgem9vbSBpbnRvIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgUGl4ZWwgcmF0aW8gb2YgdGhlIHNjcmVlblxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByYXRpbyA9IDE7XG4gICAgaWYgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSA+IHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpIHtcbiAgICAgICAgcmF0aW8gPSB3aW5kb3cuc2NyZWVuLnN5c3RlbVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIHJldHVybiByYXRpbztcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgd2lkdGggZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSB3aWR0aCBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRXaWR0aCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdyA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XG4gICAgICAgICAgICAgIGUudGFyZ2V0LndpZHRoIDpcbiAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJTVkdFbGVtZW50LndpZHRoO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICh0eXBlb2YgdyA9PT0gJ251bWJlcicgJiYgdykgfHxcbiAgICAgICh3ICE9PSB1bmRlZmluZWQgJiYgdy5iYXNlVmFsICE9PSB1bmRlZmluZWQgJiYgdy5iYXNlVmFsLnZhbHVlKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGNlbnRlciBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGNlbnRlciBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRDZW50ZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHJhdGlvID0gZS50YXJnZXQubmFtZXNwYWNlVVJJLmluZGV4T2YoJ3N2ZycpICE9PSAtMSA/IDEgOlxuICAgICAgICBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHNpZ21hLnV0aWxzLmdldFdpZHRoKGUpIC8gKDIgKiByYXRpbyksXG4gICAgICB5OiBzaWdtYS51dGlscy5nZXRIZWlnaHQoZSkgLyAoMiAqIHJhdGlvKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgbW91c2UgY29vcmRzIHRvIHNpZ21hIGNvb3Jkc1xuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEBwYXJhbSAge251bWJlcj99IHggVGhlIHggY29vcmQgdG8gY29udmVydFxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB5IGNvb3JkIHRvIGNvbnZlcnRcbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICBUaGUgc3RhbmRhcmRpemVkIGV2ZW50XG4gICAqL1xuICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyA9IGZ1bmN0aW9uKGUsIHgsIHkpIHtcbiAgICB4ID0geCB8fCBzaWdtYS51dGlscy5nZXRYKGUpO1xuICAgIHkgPSB5IHx8IHNpZ21hLnV0aWxzLmdldFkoZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICB5OiB5IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBlLmFsdEtleSxcbiAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBoZWlnaHQgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBoZWlnaHQgb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBoID0gKCFlLnRhcmdldC5vd25lclNWR0VsZW1lbnQpID9cbiAgICAgICAgICAgICAgZS50YXJnZXQuaGVpZ2h0IDpcbiAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJTVkdFbGVtZW50LmhlaWdodDtcblxuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIGggPT09ICdudW1iZXInICYmIGgpIHx8XG4gICAgICAoaCAhPT0gdW5kZWZpbmVkICYmIGguYmFzZVZhbCAhPT0gdW5kZWZpbmVkICYmIGguYmFzZVZhbC52YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIHdoZWVsIGRlbHRhIG9mIHRoZSBtb3VzZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldERlbHRhID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoZS53aGVlbERlbHRhICE9PSB1bmRlZmluZWQgJiYgZS53aGVlbERlbHRhKSB8fFxuICAgICAgKGUuZGV0YWlsICE9PSB1bmRlZmluZWQgJiYgLWUuZGV0YWlsKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCBvZiBhIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb20gVGhlIGVsZW1lbnQgdG8gcmV0cmlldmUgdGhlIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIG9mZnNldCBvZiB0aGUgRE9NIGVsZW1lbnQgKHRvcCwgbGVmdCkuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRPZmZzZXQgPSBmdW5jdGlvbihkb20pIHtcbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDA7XG5cbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICB0b3AgPSB0b3AgKyBwYXJzZUludChkb20ub2Zmc2V0VG9wKTtcbiAgICAgIGxlZnQgPSBsZWZ0ICsgcGFyc2VJbnQoZG9tLm9mZnNldExlZnQpO1xuICAgICAgZG9tID0gZG9tLm9mZnNldFBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogU2ltdWxhdGVzIGEgXCJkb3VibGUgY2xpY2tcIiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNsaWNrcyA9IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBoYW5kbGVycztcblxuICAgIHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgfHwge307XG4gICAgdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXSB8fCBbXTtcbiAgICBoYW5kbGVycyA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdO1xuXG4gICAgaGFuZGxlcnMucHVzaChmdW5jdGlvbihlKSB7XG4gICAgICBjbGlja3MrKztcblxuICAgICAgaWYgKGNsaWNrcyA9PT0gMikge1xuICAgICAgICBjbGlja3MgPSAwO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICB9IGVsc2UgaWYgKGNsaWNrcyA9PT0gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsaWNrcyA9IDA7XG4gICAgICAgIH0sIHNpZ21hLnNldHRpbmdzLmRvdWJsZUNsaWNrVGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyc1toYW5kbGVycy5sZW5ndGggLSAxXSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmJpbmQgc2ltdWxhdGVkIFwiZG91YmxlIGNsaWNrXCIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgIHR5cGUgICAgIFRoZSBldmVudCB0eXBlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUpIHtcbiAgICB2YXIgaGFuZGxlcixcbiAgICAgICAgaGFuZGxlcnMgPSAodGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgfHwge30pW3R5cGVdIHx8IFtdO1xuXG4gICAgd2hpbGUgKChoYW5kbGVyID0gaGFuZGxlcnMucG9wKCkpKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBkZWxldGUgKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogSGVyZSBhcmUganVzdCBzb21lIG9mIHRoZSBtb3N0IGJhc2ljIGVhc2luZyBmdW5jdGlvbnMsIHVzZWQgZm9yIHRoZVxuICAgKiBhbmltYXRlZCBjYW1lcmEgXCJnb1RvXCIgY2FsbHMuXG4gICAqXG4gICAqIElmIHlvdSBuZWVkIHNvbWUgbW9yZSBlYXNpbmdzIGZ1bmN0aW9ucywgZG9uJ3QgaGVzaXRhdGUgdG8gYWRkIHRoZW0gdG9cbiAgICogc2lnbWEudXRpbHMuZWFzaW5ncy4gQnV0IEkgd2lsbCBub3QgYWRkIHNvbWUgbW9yZSBoZXJlIG9yIG1lcmdlIFBSc1xuICAgKiBjb250YWluaW5nLCBiZWNhdXNlIEkgZG8gbm90IHdhbnQgc2lnbWEgc291cmNlcyBmdWxsIG9mIG92ZXJraWxsIGFuZCBuZXZlclxuICAgKiB1c2VkIHN0dWZmLi4uXG4gICAqL1xuICBzaWdtYS51dGlscy5lYXNpbmdzID0gc2lnbWEudXRpbHMuZWFzaW5ncyB8fCB7fTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5saW5lYXJOb25lID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogaztcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNPdXQgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpXG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgcmV0dXJuIC0gMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5jdWJpY0luID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogayAqIGs7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNPdXQgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5jdWJpY0luT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpXG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiAqKioqKioqKioqKipcbiAgICogV0VCR0wgVVRJTFM6XG4gICAqICoqKioqKioqKioqKlxuICAgKi9cbiAgLyoqXG4gICAqIExvYWRzIGEgV2ViR0wgc2hhZGVyIGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtXZWJHTENvbnRleHR9ICAgICAgICAgICBnbCAgICAgICAgICAgVGhlIFdlYkdMQ29udGV4dCB0byB1c2UuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZSBUaGUgc2hhZGVyIHNvdXJjZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgc2hhZGVyVHlwZSAgIFRoZSB0eXBlIG9mIHNoYWRlci5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oc3RyaW5nKTogdm9pZH0gZXJyb3IgICAgICAgIENhbGxiYWNrIGZvciBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBzaGFkZXIuXG4gICAqL1xuICBzaWdtYS51dGlscy5sb2FkU2hhZGVyID0gZnVuY3Rpb24oZ2wsIHNoYWRlclNvdXJjZSwgc2hhZGVyVHlwZSwgZXJyb3IpIHtcbiAgICB2YXIgY29tcGlsZWQsXG4gICAgICAgIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcblxuICAgIC8vIExvYWQgdGhlIHNoYWRlciBzb3VyY2VcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgc2hhZGVyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNvbXBpbGUgc3RhdHVzXG4gICAgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyk7XG5cbiAgICAvLyBJZiBzb21ldGhpbmcgd2VudCB3cm9uZzpcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIGNvbXBpbGluZyBzaGFkZXIgXCInICsgc2hhZGVyICsgJ1wiOicgK1xuICAgICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwcm9ncmFtLCBhdHRhY2hlcyBzaGFkZXJzLCBiaW5kcyBhdHRyaWIgbG9jYXRpb25zLCBsaW5rcyB0aGVcbiAgICogcHJvZ3JhbSBhbmQgY2FsbHMgdXNlUHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXkuPFdlYkdMU2hhZGVyPn0gICAgc2hhZGVycyAgIFRoZSBzaGFkZXJzIHRvIGF0dGFjaC5cbiAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59ICAgICAgICAgYXR0cmlicyAgIFRoZSBhdHRyaWJzIG5hbWVzLlxuICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gICAgICAgICBsb2NhdGlvbnMgVGhlIGxvY2F0aW9ucyBmb3IgdGhlIGF0dHJpYnMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19ICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtID0gZnVuY3Rpb24oZ2wsIHNoYWRlcnMsIGF0dHJpYnMsIGxvYywgZXJyb3IpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbGlua2VkLFxuICAgICAgICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNoYWRlcnMubGVuZ3RoOyArK2kpXG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XG5cbiAgICBpZiAoYXR0cmlicylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgKytpKVxuICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oXG4gICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICBsb2NhdGlvbnMgPyBsb2NhdGlvbnNbaV0gOiBpLFxuICAgICAgICAgIG9wdF9hdHRyaWJzW2ldXG4gICAgICAgICk7XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIENoZWNrIHRoZSBsaW5rIHN0YXR1c1xuICAgIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xuICAgIGlmICghbGlua2VkKSB7XG4gICAgICBpZiAoZXJyb3IpXG4gICAgICAgIGVycm9yKCdFcnJvciBpbiBwcm9ncmFtIGxpbmtpbmc6ICcgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG5cbiAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogKioqKioqKioqXG4gICAqIE1BVFJJQ0VTOlxuICAgKiAqKioqKioqKipcbiAgICogVGhlIGZvbGxvd2luZyB1dGlscyBhcmUganVzdCBoZXJlIHRvIGhlbHAgZ2VuZXJhdGluZyB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICogbWF0cmljZXMgZm9yIHRoZSBXZWJHTCByZW5kZXJlcnMuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnV0aWxzLm1hdHJpY2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCB0cmFuc2xhdGlvbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBUaGUgWSB0cmFuc2xhdGlvbi5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXG4gICAqL1xuICBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbiA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgIHJldHVybiBbXG4gICAgICAxLCAwLCAwLFxuICAgICAgMCwgMSwgMCxcbiAgICAgIGR4LCBkeSwgMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIG9yIDJ4MiByb3RhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gIGFuZ2xlIFRoZSByb3RhdGlvbiBhbmdsZS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgMngyIG1hdHJpeC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24gPSBmdW5jdGlvbihhbmdsZSwgbTIpIHtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICByZXR1cm4gbTIgPyBbXG4gICAgICBjb3MsIC1zaW4sXG4gICAgICBzaW4sIGNvc1xuICAgIF0gOiBbXG4gICAgICBjb3MsIC1zaW4sIDAsXG4gICAgICBzaW4sIGNvcywgMCxcbiAgICAgIDAsIDAsIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgaG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gIHJhdGlvIFRoZSBzY2FsaW5nIHJhdGlvLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBtMiAgICBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSAyeDIgbWF0cml4LlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXG4gICAqL1xuICBzaWdtYS51dGlscy5tYXRyaWNlcy5zY2FsZSA9IGZ1bmN0aW9uKHJhdGlvLCBtMikge1xuICAgIHJldHVybiBtMiA/IFtcbiAgICAgIHJhdGlvLCAwLFxuICAgICAgMCwgcmF0aW9cbiAgICBdIDogW1xuICAgICAgcmF0aW8sIDAsIDAsXG4gICAgICAwLCByYXRpbywgMCxcbiAgICAgIDAsIDAsIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgaG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIGEgIFRoZSBmaXJzdCBtYXRyaXguXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIGIgIFRoZSBzZWNvbmQgbWF0cml4LlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBtMiBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCBhc3N1bWUgYm90aCBtYXRyaWNlcyBhcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgMngyLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXG4gICAqL1xuICBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseSA9IGZ1bmN0aW9uKGEsIGIsIG0yKSB7XG4gICAgdmFyIGwgPSBtMiA/IDIgOiAzLFxuICAgICAgICBhMDAgPSBhWzAgKiBsICsgMF0sXG4gICAgICAgIGEwMSA9IGFbMCAqIGwgKyAxXSxcbiAgICAgICAgYTAyID0gYVswICogbCArIDJdLFxuICAgICAgICBhMTAgPSBhWzEgKiBsICsgMF0sXG4gICAgICAgIGExMSA9IGFbMSAqIGwgKyAxXSxcbiAgICAgICAgYTEyID0gYVsxICogbCArIDJdLFxuICAgICAgICBhMjAgPSBhWzIgKiBsICsgMF0sXG4gICAgICAgIGEyMSA9IGFbMiAqIGwgKyAxXSxcbiAgICAgICAgYTIyID0gYVsyICogbCArIDJdLFxuICAgICAgICBiMDAgPSBiWzAgKiBsICsgMF0sXG4gICAgICAgIGIwMSA9IGJbMCAqIGwgKyAxXSxcbiAgICAgICAgYjAyID0gYlswICogbCArIDJdLFxuICAgICAgICBiMTAgPSBiWzEgKiBsICsgMF0sXG4gICAgICAgIGIxMSA9IGJbMSAqIGwgKyAxXSxcbiAgICAgICAgYjEyID0gYlsxICogbCArIDJdLFxuICAgICAgICBiMjAgPSBiWzIgKiBsICsgMF0sXG4gICAgICAgIGIyMSA9IGJbMiAqIGwgKyAxXSxcbiAgICAgICAgYjIyID0gYlsyICogbCArIDJdO1xuXG4gICAgcmV0dXJuIG0yID8gW1xuICAgICAgYTAwICogYjAwICsgYTAxICogYjEwLFxuICAgICAgYTAwICogYjAxICsgYTAxICogYjExLFxuICAgICAgYTEwICogYjAwICsgYTExICogYjEwLFxuICAgICAgYTEwICogYjAxICsgYTExICogYjExXG4gICAgXSA6IFtcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCArIGEwMiAqIGIyMCxcbiAgICAgIGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMSxcbiAgICAgIGEwMCAqIGIwMiArIGEwMSAqIGIxMiArIGEwMiAqIGIyMixcbiAgICAgIGExMCAqIGIwMCArIGExMSAqIGIxMCArIGExMiAqIGIyMCxcbiAgICAgIGExMCAqIGIwMSArIGExMSAqIGIxMSArIGExMiAqIGIyMSxcbiAgICAgIGExMCAqIGIwMiArIGExMSAqIGIxMiArIGExMiAqIGIyMixcbiAgICAgIGEyMCAqIGIwMCArIGEyMSAqIGIxMCArIGEyMiAqIGIyMCxcbiAgICAgIGEyMCAqIGIwMSArIGEyMSAqIGIxMSArIGEyMiAqIGIyMSxcbiAgICAgIGEyMCAqIGIwMiArIGEyMSAqIGIxMiArIGEyMiAqIGIyMlxuICAgIF07XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlci5cbiAgICogZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxuICAgKiBNSVQgbGljZW5zZVxuICAgKi9cbiAgdmFyIHgsXG4gICAgICBsYXN0VGltZSA9IDAsXG4gICAgICB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxuICBmb3IgKHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7IHgrKykge1xuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHxcbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICB9XG5cbiAgaWYgKCFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKSxcbiAgICAgICAgICBpZCA9IGdsb2JhbC5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZVRvQ2FsbFxuICAgICAgICAgICk7XG5cbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG5cbiAgaWYgKCFnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUpXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgcG9seWZpbGwgZm91bmQgb24gTUROLlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kI0NvbXBhdGliaWxpdHlcbiAgICogUHVibGljIGRvbWFpblxuICAgKi9cbiAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZClcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIC8vIENsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlXG4gICAgICAgIC8vIGZ1bmN0aW9uOlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZSdcbiAgICAgICAgKTtcblxuICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICBmTk9QLFxuICAgICAgICAgIGZCb3VuZDtcblxuICAgICAgZk5PUCA9IGZ1bmN0aW9uKCkge307XG4gICAgICBmQm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkoXG4gICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgP1xuICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICBvVGhpcyxcbiAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcblxuICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufSkodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBQYWNrYWdlcyBpbml0aWFsaXphdGlvbjpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zZXR0aW5ncycpO1xuXG4gIHZhciBzZXR0aW5ncyA9IHtcbiAgICAvKipcbiAgICAgKiBHUkFQSCBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBkYXRhIGhhdmUgdG8gYmUgY2xvbmVkIGluIG1ldGhvZHMgdG8gYWRkXG4gICAgLy8gICAgICAgICAgIG5vZGVzIG9yIGVkZ2VzLlxuICAgIGNsb25lOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLCBcInNvdXJjZVwiIGFuZFxuICAgIC8vICAgICAgICAgICBcInRhcmdldFwiIHZhbHVlcyBtdXN0IGJlIHNldCBhcyBpbW11dGFibGUuXG4gICAgaW1tdXRhYmxlOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgc2lnbWEgY2FuIGxvZyBpdHMgZXJyb3JzIGFuZCB3YXJuaW5ncy5cbiAgICB2ZXJib3NlOiBmYWxzZSxcblxuXG4gICAgLyoqXG4gICAgICogUkVOREVSRVJTIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7c3RyaW5nfVxuICAgIGNsYXNzUHJlZml4OiAnc2lnbWEnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdE5vZGVUeXBlOiAnZGVmJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRFZGdlVHlwZTogJ2RlZicsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0TGFiZWxDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEVkZ2VDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdE5vZGVDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsU2l6ZTogMTQsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGVkZ2VzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwic291cmNlXCIsIFwidGFyZ2V0XCIsIFwiZGVmYXVsdFwiXG4gICAgZWRnZUNvbG9yOiAnc291cmNlJyxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIHRoZSBtaW5pbWFsIGVkZ2UncyBhcnJvdyBkaXNwbGF5IHNpemUuXG4gICAgbWluQXJyb3dTaXplOiAwLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZm9udDogJ2FyaWFsJyxcbiAgICAvLyB7c3RyaW5nfSBFeGFtcGxlOiAnYm9sZCdcbiAgICBmb250U3R5bGU6ICcnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBsYWJlbHMgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxDb2xvcjogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBsYWJlbHMgc2l6ZS4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcImZpeGVkXCIsIFwicHJvcG9ydGlvbmFsXCJcbiAgICBsYWJlbFNpemU6ICdmaXhlZCcsXG4gICAgLy8ge3N0cmluZ30gVGhlIHJhdGlvIGJldHdlZW4gdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGFiZWwgYW5kIHRoZSBub2RlIHNpemUuXG4gICAgbGFiZWxTaXplUmF0aW86IDEsXG4gICAgLy8ge251bWJlcn0gVGhlIG1pbmltdW0gc2l6ZSBhIG5vZGUgbXVzdCBoYXZlIHRvIHNlZSBpdHMgbGFiZWwgZGlzcGxheWVkLlxuICAgIGxhYmVsVGhyZXNob2xkOiA4LFxuICAgIC8vIHtudW1iZXJ9IFRoZSBvdmVyc2FtcGxpbmcgZmFjdG9yIHVzZWQgaW4gV2ViR0wgcmVuZGVyZXIuXG4gICAgd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbzogMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiB0aGUgYm9yZGVyIG9mIGhvdmVyZWQgbm9kZXMuXG4gICAgYm9yZGVyU2l6ZTogMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBob3ZlcmVkIG5vZGUgYm9yZGVyJ3MgY29sb3IuXG4gICAgZGVmYXVsdE5vZGVCb3JkZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBob3ZlcmVkIG5vZGUncyBsYWJlbCBmb250LiBJZiBub3Qgc3BlY2lmaWVkLCB3aWxsIGhlcml0YXRlXG4gICAgLy8gICAgICAgICAgdGhlIFwiZm9udFwiIHZhbHVlLlxuICAgIGhvdmVyRm9udDogJycsXG4gICAgLy8ge2Jvb2xlYW59IElmIHRydWUsIHRoZW4gb25seSBvbmUgbm9kZSBjYW4gYmUgaG92ZXJlZCBhdCBhIHRpbWUuXG4gICAgc2luZ2xlSG92ZXI6IHRydWUsXG4gICAgLy8ge3N0cmluZ30gRXhhbXBsZTogJ2JvbGQnXG4gICAgaG92ZXJGb250U3R5bGU6ICcnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIHNoYWRvdyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyU2hhZG93OiAnZGVmYXVsdCcsXG4gICAgLy8ge3N0cmluZ31cbiAgICBsYWJlbEhvdmVyU2hhZG93Q29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBub2RlSG92ZXJDb2xvcjogJ25vZGUnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdE5vZGVIb3ZlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgYmFja2dyb3VuZCBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyQkdDb2xvcjogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEhvdmVyTGFiZWxCR0NvbG9yOiAnI2ZmZicsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbGFiZWxzIGNvbG9yLlxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsSG92ZXJDb2xvcjogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsSG92ZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBob3ZlciBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcImVkZ2VcIiwgXCJkZWZhdWx0XCJcbiAgICBlZGdlSG92ZXJDb2xvcjogJ2VkZ2UnLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBzaXplIG11bHRpcGxpY2F0b3Igb2YgaG92ZXJlZCBlZGdlcy5cbiAgICBlZGdlSG92ZXJTaXplUmF0aW86IDEsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0RWRnZUhvdmVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlIGV4dHJlbWl0aWVzIG11c3QgYmUgaG92ZXJlZCB3aGVuIHRoZVxuICAgIC8vICAgICAgICAgICBlZGdlIGlzIGhvdmVyZWQuXG4gICAgZWRnZUhvdmVyRXh0cmVtaXRpZXM6IGZhbHNlLFxuICAgIC8vIHtib29sZWFuc30gVGhlIGRpZmZlcmVudCBkcmF3aW5nIG1vZGVzOlxuICAgIC8vICAgICAgICAgICBmYWxzZTogTGF5ZXJlZCBub3QgZGlzcGxheWVkLlxuICAgIC8vICAgICAgICAgICB0cnVlOiBMYXllcmVkIGRpc3BsYXllZC5cbiAgICBkcmF3RWRnZXM6IHRydWUsXG4gICAgZHJhd05vZGVzOiB0cnVlLFxuICAgIGRyYXdMYWJlbHM6IHRydWUsXG4gICAgZHJhd0VkZ2VMYWJlbHM6IGZhbHNlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2VzIG11c3QgYmUgZHJhd24gaW4gc2V2ZXJhbCBmcmFtZXMgb3IgaW5cbiAgICAvLyAgICAgICAgICAgb25lIGZyYW1lLCBhcyB0aGUgbm9kZXMgYW5kIGxhYmVscyBhcmUgZHJhd24uXG4gICAgYmF0Y2hFZGdlc0RyYXdpbmc6IGZhbHNlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2VzIG11c3QgYmUgaGlkZGVuIGR1cmluZyBkcmFnZ2luZyBhbmRcbiAgICAvLyAgICAgICAgICAgYW5pbWF0aW9ucy5cbiAgICBoaWRlRWRnZXNPbk1vdmU6IGZhbHNlLFxuICAgIC8vIHtudW1iZXJzfSBUaGUgZGlmZmVyZW50IGJhdGNoIHNpemVzLCB3aGVuIGVsZW1lbnRzIGFyZSBkaXNwbGF5ZWQgaW5cbiAgICAvLyAgICAgICAgICAgc2V2ZXJhbCBmcmFtZXMuXG4gICAgY2FudmFzRWRnZXNCYXRjaFNpemU6IDUwMCxcbiAgICB3ZWJnbEVkZ2VzQmF0Y2hTaXplOiAxMDAwLFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogUkVTQ0FMRSBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBvZiB0byBzY2FsZSB0aGUgZ3JhcGggcmVsYXRpdmVseSB0byBpdHMgY29udGFpbmVyLlxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwiaW5zaWRlXCIsIFwib3V0c2lkZVwiXG4gICAgc2NhbGluZ01vZGU6ICdpbnNpZGUnLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXJnaW4gdG8ga2VlcCBhcm91bmQgdGhlIGdyYXBoLlxuICAgIHNpZGVNYXJnaW46IDAsXG4gICAgLy8ge251bWJlcn0gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBzbWFsbGVzdCBhbmQgdGhlIGJpZ2dlc3Qgbm9kZSAvIGVkZ2VzXG4gICAgLy8gICAgICAgICAgb24gdGhlIHNjcmVlbi4gVGhpcyBtYXBwaW5nIG1ha2VzIGVhc2llciB0byBkaXNwbGF5IHRoZSBncmFwaCxcbiAgICAvLyAgICAgICAgICBhdm9pZGluZyB0b28gYmlnIG5vZGVzIHRoYXQgdGFrZSBoYWxmIG9mIHRoZSBzY3JlZW4sIG9yIHRvb1xuICAgIC8vICAgICAgICAgIHNtYWxsIG9uZXMgdGhhdCBhcmUgbm90IHJlYWRhYmxlLiBJZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlXG4gICAgLy8gICAgICAgICAgZXF1YWxzLCB0aGVuIHRoZSBtaW5pbWFsIGRpc3BsYXkgc2l6ZSB3aWxsIGJlIDAuIEFuZCBpZiB0aGV5XG4gICAgLy8gICAgICAgICAgYXJlIGJvdGggZXF1YWwgdG8gMCwgdGhlbiB0aGVyZSBpcyBubyBtYXBwaW5nLCBhbmQgdGhlIHJhZGl1c1xuICAgIC8vICAgICAgICAgIG9mIHRoZSBub2RlcyB3aWxsIGJlIHRoZWlyIHNpemUuXG4gICAgbWluRWRnZVNpemU6IDAuNSxcbiAgICBtYXhFZGdlU2l6ZTogMSxcbiAgICBtaW5Ob2RlU2l6ZTogMSxcbiAgICBtYXhOb2RlU2l6ZTogOCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIENBUFRPUlMgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7Ym9vbGVhbn1cbiAgICB0b3VjaEVuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgbW91c2VFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIG1vdXNlV2hlZWxFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIGRvdWJsZUNsaWNrRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGVmaW5lcyB3aGV0aGVyIHRoZSBjdXN0b20gZXZlbnRzIHN1Y2ggYXMgXCJjbGlja05vZGVcIiBjYW4gYmVcbiAgICAvLyAgICAgICAgICAgdXNlZC5cbiAgICBldmVudHNFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtudW1iZXJ9IERlZmluZXMgYnkgaG93IG11Y2ggbXVsdGlwbGljYXRpbmcgdGhlIHpvb21pbmcgbGV2ZWwgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICB1c2VyIHpvb21zIHdpdGggdGhlIG1vdXNlLXdoZWVsLlxuICAgIHpvb21pbmdSYXRpbzogMS43LFxuICAgIC8vIHtudW1iZXJ9IERlZmluZXMgYnkgaG93IG11Y2ggbXVsdGlwbGljYXRpbmcgdGhlIHpvb21pbmcgbGV2ZWwgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICB1c2VyIHpvb21zIGJ5IGRvdWJsZSBjbGlja2luZy5cbiAgICBkb3VibGVDbGlja1pvb21pbmdSYXRpbzogMi4yLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHpvb21pbmcgbGV2ZWwuXG4gICAgem9vbU1pbjogMC4wNjI1LFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHpvb21pbmcgbGV2ZWwuXG4gICAgem9vbU1heDogMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBzY3JvbGxpbmcuXG4gICAgbW91c2Vab29tRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBkb3VibGUgY2xpY2suXG4gICAgZG91YmxlQ2xpY2tab29tRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBkcm9wcGluZy5cbiAgICBtb3VzZUluZXJ0aWFEdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBpbmVydGlhIHBvd2VyIChtb3VzZSBjYXB0b3IpLlxuICAgIG1vdXNlSW5lcnRpYVJhdGlvOiAzLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb25zIGZvbGxvd2luZyBhIHRvdWNoIGRyb3BwaW5nLlxuICAgIHRvdWNoSW5lcnRpYUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGluZXJ0aWEgcG93ZXIgKHRvdWNoIGNhcHRvcikuXG4gICAgdG91Y2hJbmVydGlhUmF0aW86IDMsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byBjbGlja3MgdG8gbWFrZSBpdCBhIGRvdWJsZSBjbGljay5cbiAgICBkb3VibGVDbGlja1RpbWVvdXQ6IDMwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB0aW1lIGJldHdlZW4gdHdvIHRhcHMgdG8gbWFrZSBpdCBhIGRvdWJsZSB0YXAuXG4gICAgZG91YmxlVGFwVGltZW91dDogMzAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgb2YgZHJhZ2dpbmcgdG8gdHJpZ2dlciBpbnRlcnRpYS5cbiAgICBkcmFnVGltZW91dDogMjAwLFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogR0xPQkFMIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBoYXMgdG8gcmVmcmVzaCBpdHNlbGZcbiAgICAvLyAgICAgICAgICAgYXV0b21hdGljYWxseSB3aGVuIGEgXCJyZXNpemVcIiBldmVudCBpcyBkaXNwYXRjaGVkIGZyb20gdGhlXG4gICAgLy8gICAgICAgICAgIHdpbmRvdyBvYmplY3QuXG4gICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBcInJlc2NhbGVcIiBtaWRkbGV3YXJlIGhhcyB0byBiZSBjYWxsZWRcbiAgICAvLyAgICAgICAgICAgYXV0b21hdGljYWxseSBmb3IgZWFjaCBjYW1lcmEgb24gcmVmcmVzaC5cbiAgICBhdXRvUmVzY2FsZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIGZhbHNlLCB0aGUgY2FtZXJhIG1ldGhvZCBcImdvVG9cIiB3aWxsIGJhc2ljYWxseSBkb1xuICAgIC8vICAgICAgICAgICBub3RoaW5nLlxuICAgIGVuYWJsZUNhbWVyYTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIGZhbHNlLCB0aGUgbm9kZXMgY2Fubm90IGJlIGhvdmVyZWQuXG4gICAgZW5hYmxlSG92ZXJpbmc6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgZWRnZXMgY2FuIGJlIGhvdmVyZWQuXG4gICAgZW5hYmxlRWRnZUhvdmVyaW5nOiBmYWxzZSxcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiB0aGUgYXJlYSBhcm91bmQgdGhlIGVkZ2VzIHRvIGFjdGl2YXRlIGhvdmVyaW5nLlxuICAgIGVkZ2VIb3ZlclByZWNpc2lvbjogNSxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIHRydWUsIHRoZSByZXNjYWxlIG1pZGRsZXdhcmUgd2lsbCBpZ25vcmUgbm9kZSBzaXplc1xuICAgIC8vICAgICAgICAgICB0byBkZXRlcm1pbmUgdGhlIGdyYXBocyBib3VuZGluZ3MuXG4gICAgcmVzY2FsZUlnbm9yZVNpemU6IGZhbHNlLFxuICAgIC8vIHtib29sZWFufSBEZXRlcm1pbmVzIGlmIHRoZSBjb3JlIGhhcyB0byB0cnkgdG8gY2F0Y2ggZXJyb3JzIG9uXG4gICAgLy8gICAgICAgICAgIHJlbmRlcmluZy5cbiAgICBza2lwRXJyb3JzOiBmYWxzZSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIENBTUVSQSBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge251bWJlcn0gVGhlIHBvd2VyIGRlZ3JlZXMgYXBwbGllZCB0byB0aGUgbm9kZXMvZWRnZXMgc2l6ZSByZWxhdGl2ZWx5IHRvXG4gICAgLy8gICAgICAgICAgdGhlIHpvb21pbmcgbGV2ZWwuIEJhc2ljYWxseTpcbiAgICAvLyAgICAgICAgICAgPiBvblNjcmVlblIgPSBNYXRoLnBvdyh6b29tLCBub2Rlc1Bvd1JhdGlvKSAqIFJcbiAgICAvLyAgICAgICAgICAgPiBvblNjcmVlblQgPSBNYXRoLnBvdyh6b29tLCBlZGdlc1Bvd1JhdGlvKSAqIFRcbiAgICBub2Rlc1Bvd1JhdGlvOiAwLjUsXG4gICAgZWRnZXNQb3dSYXRpbzogMC41LFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogQU5JTUFUSU9OUyBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtudW1iZXJ9IFRoZSBkZWZhdWx0IGFuaW1hdGlvbiB0aW1lLlxuICAgIGFuaW1hdGlvbnNUaW1lOiAyMDBcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIHByZXZpb3VzbHkgZGVzaWduZWQgc2V0dGluZ3M6XG4gIHNpZ21hLnNldHRpbmdzID0gc2lnbWEudXRpbHMuZXh0ZW5kKHNpZ21hLnNldHRpbmdzIHx8IHt9LCBzZXR0aW5ncyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXIgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9IFRoZSBuZXcgZGlzcGF0Y2hlciBpbnN0YW5jZS5cbiAgICovXG4gIHZhciBkaXNwYXRjaGVyID0gZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfaGFuZGxlcnMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogV2lsbCBleGVjdXRlIHRoZSBoYW5kbGVyIGV2ZXJ5dGltZSB0aGF0IHRoZSBpbmRpY2F0ZWQgZXZlbnQgKG9yIHRoZVxuICAgKiBpbmRpY2F0ZWQgZXZlbnRzKSB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheTtcblxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnXG4gICAgKVxuICAgICAgZm9yIChldmVudHMgaW4gYXJndW1lbnRzWzBdKVxuICAgICAgICB0aGlzLmJpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XG4gICAgZWxzZSBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBlQXJyYXkgPSB0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJyA/IGV2ZW50cy5zcGxpdCgnICcpIDogZXZlbnRzO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgZXZlbnQgaXMgbm90ICcnOlxuICAgICAgICBpZiAoIWV2ZW50KVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnRdKVxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xuXG4gICAgICAgIC8vIFVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHRoZSBoYW5kbGVyIHdpbGwgbWFrZSBwb3NzaWJsZVxuICAgICAgICAvLyBsYXRlciB0byBhZGQgZmxhZ3NcbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyAnYmluZDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgaGFuZGxlciBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50IChvciBzcGVjaWZpZWQgZXZlbnRzKS5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGhhbmRsZXJzIGFyZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gIHs/ZnVuY3Rpb24ob2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byB1bmJpbmQuIElmIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudCBvciB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4sXG4gICAgICAgIGosXG4gICAgICAgIG0sXG4gICAgICAgIGssXG4gICAgICAgIGEsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXkgPSB0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJyA/IGV2ZW50cy5zcGxpdCgnICcpIDogZXZlbnRzO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGsgaW4gdGhpcy5faGFuZGxlcnMpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1trXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBuID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbjsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgIGZvciAoaiA9IDAsIG0gPSB0aGlzLl9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBtOyBqICs9IDEpXG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdW2pdLmhhbmRsZXIgIT09IGhhbmRsZXIpXG4gICAgICAgICAgICAgIGEucHVzaCh0aGlzLl9oYW5kbGVyc1tldmVudF1bal0pO1xuXG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5faGFuZGxlcnNbZXZlbnRdLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSlcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2VBcnJheVtpXV07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBldmVudHMgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzIHNlcGFyYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgZGF0YSAgIFRoZSBjb250ZW50IG9mIHRoZSBldmVudCAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50cywgZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuLFxuICAgICAgICBqLFxuICAgICAgICBtLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IGRhdGE7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbjsgaSArPSAxKSB7XG4gICAgICBldmVudE5hbWUgPSBlQXJyYXlbaV07XG5cbiAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIGV2ZW50ID0gc2VsZi5nZXRFdmVudChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICBhID0gW107XG5cbiAgICAgICAgZm9yIChqID0gMCwgbSA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBtOyBqICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2pdLmhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5vbmUpXG4gICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gYTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGFuIGV2ZW50IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtICB7P29iamVjdH0gZGF0YSAgIFRoZSBjb250ZW50IG9mIHRoZSBldmVudCAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUuZ2V0RXZlbnQgPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBldmVudCxcbiAgICAgIGRhdGE6IGRhdGEgfHwge30sXG4gICAgICB0YXJnZXQ6IHRoaXNcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHVzZWZ1bCBmdW5jdGlvbiB0byBkZWFsIHdpdGggaW5oZXJpdGFuY2UuIEl0IHdpbGwgbWFrZSB0aGUgdGFyZ2V0XG4gICAqIGluaGVyaXQgdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3MgZGlzcGF0Y2hlciBhcyB3ZWxsIGFzIGl0cyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0LlxuICAgKi9cbiAgZGlzcGF0Y2hlci5leHRlbmQgPSBmdW5jdGlvbih0YXJnZXQsIGFyZ3MpIHtcbiAgICB2YXIgaztcblxuICAgIGZvciAoayBpbiBkaXNwYXRjaGVyLnByb3RvdHlwZSlcbiAgICAgIGlmIChkaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgdGFyZ2V0W2tdID0gZGlzcGF0Y2hlci5wcm90b3R5cGVba107XG5cbiAgICBkaXNwYXRjaGVyLmFwcGx5KHRhcmdldCwgYXJncyk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGlzcGF0Y2hlcjtcbiAgICBleHBvcnRzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICB9IGVsc2VcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUaGlzIHV0aWxzIGFpbXMgdG8gZmFjaWxpdGF0ZSB0aGUgbWFuaXB1bGF0aW9uIG9mIGVhY2ggaW5zdGFuY2Ugc2V0dGluZy5cbiAgICogVXNpbmcgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGFuIG9iamVjdCBicmluZ3MgdHdvIG1haW4gYWR2YW50YWdlczogRmlyc3QsXG4gICAqIGl0IHdpbGwgYmUgZWFzaWVyIGluIHRoZSBmdXR1cmUgdG8gY2F0Y2ggc2V0dGluZ3MgdXBkYXRlcyB0aHJvdWdoIGFcbiAgICogZnVuY3Rpb24gdGhhbiBhbiBvYmplY3QuIFNlY29uZCwgZ2l2aW5nIGl0IGEgZnVsbCBvYmplY3Qgd2lsbCBcIm1lcmdlXCIgaXRcbiAgICogdG8gdGhlIHNldHRpbmdzIG9iamVjdCBwcm9wZXJseSwga2VlcGluZyB1cyB0byBoYXZlIHRvIGFsd2F5cyBhZGQgYSBsb29wLlxuICAgKlxuICAgKiBAcmV0dXJuIHtjb25maWd1cmFibGV9IFRoZSBcInNldHRpbmdzXCIgZnVuY3Rpb24uXG4gICAqL1xuICB2YXIgY29uZmlndXJhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGRhdGEgPSB7fSxcbiAgICAgICAgZGF0YXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0byB1c2UgdG8gc2V0IG9yIGdldCBhbnkgcHJvcGVydHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9ICAgIGExIElmIGl0IGlzIGEgc3RyaW5nIGFuZCBpZiBhMiBpcyB1bmRlZmluZWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBpdCB3aWxsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LiBJZiBpdCBpcyBhIHN0cmluZyBhbmQgaWYgYTIgaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQsIHRoZW4gaXQgd2lsbCBzZXQgYTIgYXMgdGhlIHByb3BlcnR5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZGluZyB0byBhMSwgYW5kIHJldHVybiB0aGlzLiBJZlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IGlzIGFuIG9iamVjdCwgdGhlbiBlYWNoIHBhaXIgc3RyaW5nICtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qob3IgYW55IG90aGVyIHR5cGUpIHdpbGwgYmUgc2V0IGFzIGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gIHsqP30gICAgICAgICAgICAgICBhMiBUaGUgbmV3IHByb3BlcnR5IGNvcnJlc3BvbmRpbmcgdG8gYTEgaWYgYTFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHsqfGNvbmZpZ3VyYWJsZX0gICAgICBSZXR1cm5zIGl0c2VsZiBvciB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogUG9seW1vcnBoaXNtOlxuICAgICAqICoqKioqKioqKioqKipcbiAgICAgKiBIZXJlIGFyZSBzb21lIGJhc2ljIHVzZSBleGFtcGxlczpcbiAgICAgKlxuICAgICAqICA+IHNldHRpbmdzID0gbmV3IGNvbmZpZ3VyYWJsZSgpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnLCA0Mik7XG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycpOyAvLyBMb2dzOiA0MlxuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnLCAxMjMpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogMTIzXG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogNDU2fSk7XG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycpOyAvLyBMb2dzOiA0NTZcbiAgICAgKlxuICAgICAqIEFsc28sIGl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGUgZnVuY3Rpb24gYXMgYSBmYWxsYmFjazpcbiAgICAgKiAgPiBzZXR0aW5ncyh7bXlTZXR0aW5nOiAnYWJjJ30sICdteVNldHRpbmcnKTsgIC8vIExvZ3M6ICdhYmMnXG4gICAgICogID4gc2V0dGluZ3Moe2hpc1NldHRpbmc6ICdhYmMnfSwgJ215U2V0dGluZycpOyAvLyBMb2dzOiA0NTZcbiAgICAgKi9cbiAgICB2YXIgc2V0dGluZ3MgPSBmdW5jdGlvbihhMSwgYTIpIHtcbiAgICAgIHZhciBvLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBrO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYTEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkYXRhW2ExXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBkYXRhW2ExXTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGRhdGFzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBpZiAoZGF0YXNbaV1bYTFdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZGF0YXNbaV1bYTFdO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhMiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIChhMSB8fCB7fSlbYTJdICE9PSB1bmRlZmluZWQgPyBhMVthMl0gOiBzZXR0aW5ncyhhMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvID0gKHR5cGVvZiBhMSA9PT0gJ29iamVjdCcgJiYgYTIgPT09IHVuZGVmaW5lZCkgPyBhMSA6IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYTEgPT09ICdzdHJpbmcnKVxuICAgICAgICAgIG9bYTFdID0gYTI7XG5cbiAgICAgICAgZm9yIChpID0gMCwgayA9IE9iamVjdC5rZXlzKG8pLCBsID0gay5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgZGF0YVtrW2ldXSA9IG9ba1tpXV07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgY29uZmlndXJhYmxlIGZ1bmN0aW9uLCB3aXRoIG5ldyBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3QqfSAgQW55IG51bWJlciBvZiBvYmplY3RzIHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gUmV0dXJucyB0aGUgZnVuY3Rpb24uIENoZWNrIGl0cyBkb2N1bWVudGF0aW9uIHRvIGtub3dcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbW9yZSBhYm91dCBob3cgaXQgd29ya3MuXG4gICAgICovXG4gICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGRhdGFzLmNvbmNhdChcbiAgICAgICAgZGF0YVxuICAgICAgKS5jb25jYXQoXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY29uZmlndXJhYmxlLmFwcGx5KHt9LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZVxuICAgIGZvciAoaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgc2V0dGluZ3MoYXJndW1lbnRzW2ldKTtcblxuICAgIHJldHVybiBzZXR0aW5ncztcbiAgfTtcblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xuICAgIHRoaXMuc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29uZmlndXJhYmxlO1xuICAgIGV4cG9ydHMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xuICB9IGVsc2VcbiAgICB0aGlzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX21ldGhvZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX2luZGV4ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX2luaXRCaW5kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfbWV0aG9kQmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9kZWZhdWx0U2V0dGluZ3MgPSB7XG4gICAgICAgIGltbXV0YWJsZTogdHJ1ZSxcbiAgICAgICAgY2xvbmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0U2V0dGluZ3Nba2V5XTtcbiAgICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSBncmFwaCBjb25zdHJ1Y3Rvci4gSXQgaW5pdGlhbGl6ZXMgdGhlIGRhdGEgYW5kIHRoZSBpbmRleGVzLCBhbmQgYmluZHNcbiAgICogdGhlIGN1c3RvbSBpbmRleGVzIGFuZCBtZXRob2RzIHRvIGl0cyBvd24gc2NvcGUuXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHtib29sZWFufSBjbG9uZSAgICAgSW5kaWNhdGVzIGlmIHRoZSBkYXRhIGhhdmUgdG8gYmUgY2xvbmVkIGluIG1ldGhvZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHRvIGFkZCBub2RlcyBvciBlZGdlcy5cbiAgICogICB7Ym9vbGVhbn0gaW1tdXRhYmxlIEluZGljYXRlcyBpZiBub2RlcyBcImlkXCIgdmFsdWVzIGFuZCBlZGdlcyBcImlkXCIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBcInNvdXJjZVwiIGFuZCBcInRhcmdldFwiIHZhbHVlcyBtdXN0IGJlIHNldCBhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBFdmVudHVhbGx5IGEgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2dyYXBofSAgICAgICAgICAgICAgICAgIFRoZSBuZXcgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICB2YXIgZ3JhcGggPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgIHZhciBrLFxuICAgICAgICBmbixcbiAgICAgICAgZGF0YTtcblxuICAgIC8qKlxuICAgICAqIERBVEE6XG4gICAgICogKioqKipcbiAgICAgKiBFdmVyeSBkYXRhIHRoYXQgaXMgY2FsbGFibGUgZnJvbSBncmFwaCBtZXRob2RzIGFyZSBzdG9yZWQgaW4gdGhpcyBcImRhdGFcIlxuICAgICAqIG9iamVjdC4gVGhpcyBvYmplY3Qgd2lsbCBiZSBzZXJ2ZWQgYXMgY29udGV4dCBmb3IgYWxsIHRoZXNlIG1ldGhvZHMsXG4gICAgICogYW5kIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCBvdGhlciB0eXBlIG9mIGRhdGEgaW4gaXQuXG4gICAgICovXG4gICAgZGF0YSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogU0VUVElOR1MgRlVOQ1RJT046XG4gICAgICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICAgICAqL1xuICAgICAgc2V0dGluZ3M6IHNldHRpbmdzIHx8IF9kZWZhdWx0U2V0dGluZ3NGdW5jdGlvbixcblxuICAgICAgLyoqXG4gICAgICAgKiBNQUlOIERBVEE6XG4gICAgICAgKiAqKioqKioqKioqXG4gICAgICAgKi9cbiAgICAgIG5vZGVzQXJyYXk6IFtdLFxuICAgICAgZWRnZXNBcnJheTogW10sXG5cbiAgICAgIC8qKlxuICAgICAgICogR0xPQkFMIElOREVYRVM6XG4gICAgICAgKiAqKioqKioqKioqKioqKipcbiAgICAgICAqIFRoZXNlIGluZGV4ZXMganVzdCBpbmRleCBkYXRhIGJ5IGlkcy5cbiAgICAgICAqL1xuICAgICAgbm9kZXNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGVkZ2VzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgIC8qKlxuICAgICAgICogTE9DQUwgSU5ERVhFUzpcbiAgICAgICAqICoqKioqKioqKioqKioqXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIHJlZmVyIGZyb20gbm9kZSB0byBub2Rlcy4gRWFjaCBrZXkgaXMgYW4gaWQsIGFuZCBlYWNoXG4gICAgICAgKiB2YWx1ZSBpcyB0aGUgYXJyYXkgb2YgdGhlIGlkcyBvZiByZWxhdGVkIG5vZGVzLlxuICAgICAgICovXG4gICAgICBpbk5laWdoYm9yc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgb3V0TmVpZ2hib3JzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBhbGxOZWlnaGJvcnNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgICAgaW5OZWlnaGJvcnNDb3VudDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG91dE5laWdoYm9yc0NvdW50OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYWxsTmVpZ2hib3JzQ291bnQ6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuXG4gICAgLy8gRXhlY3V0ZSBiaW5kaW5nczpcbiAgICBmb3IgKGsgaW4gX2luaXRCaW5kaW5ncylcbiAgICAgIF9pbml0QmluZGluZ3Nba10uY2FsbChkYXRhKTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGJvdGggdGhlIHNjb3BlIGFuZCB0aGUgZGF0YSBvYmplY3RzOlxuICAgIGZvciAoayBpbiBfbWV0aG9kcykge1xuICAgICAgZm4gPSBfX2JpbmRHcmFwaE1ldGhvZChrLCBkYXRhLCBfbWV0aG9kc1trXSk7XG4gICAgICB0aGlzW2tdID0gZm47XG4gICAgICBkYXRhW2tdID0gZm47XG4gICAgfVxuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSB0b29sIHRvIGJpbmQgbWV0aG9kcyBzdWNoIHRoYXQgZnVuY3Rpb24gdGhhdCBhcmUgYm91bmQgdG8gaXQgd2lsbFxuICAgKiBiZSBleGVjdXRlZCBhbnl0aW1lIHRoZSBtZXRob2QgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGJpbmQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBzY29wZSAgICAgIFRoZSBzY29wZSB3aGVyZSB0aGUgbWV0aG9kIG11c3QgYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmbiAgICAgICAgIFRoZSBtZXRob2QgaXRzZWxmLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgICBUaGUgbmV3IG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fYmluZEdyYXBoTWV0aG9kKG1ldGhvZE5hbWUsIHNjb3BlLCBmbikge1xuICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrLFxuICAgICAgICAgIHJlcztcblxuICAgICAgLy8gRXhlY3V0ZSBcImJlZm9yZVwiIGJvdW5kIGZ1bmN0aW9uczpcbiAgICAgIGZvciAoayBpbiBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgIF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXVtrXS5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gQXBwbHkgdGhlIG1ldGhvZDpcbiAgICAgIHJlcyA9IGZuLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xuXG4gICAgICAvLyBFeGVjdXRlIGJvdW5kIGZ1bmN0aW9uczpcbiAgICAgIGZvciAoayBpbiBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXVtrXS5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gUmV0dXJuIHJlczpcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBjdXN0b20gdG9vbCBmdW5jdGlvbiByZW1vdmVzIGV2ZXJ5IHBhaXIga2V5L3ZhbHVlIGZyb20gYW4gaGFzaC4gVGhlXG4gICAqIGdvYWwgaXMgdG8gYXZvaWQgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHdoaWxlIHNvbWUgb3RoZXIgcmVmZXJlbmNlcyBhcmVcbiAgICogc3RpbGwgaGFuZ2luZyBpbiBzb21lIHNjb3Blcy4uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgZW1wdHkgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX19lbXB0eU9iamVjdChvYmopIHtcbiAgICB2YXIgaztcblxuICAgIGZvciAoayBpbiBvYmopXG4gICAgICBpZiAoISgnaGFzT3duUHJvcGVydHknIGluIG9iaikgfHwgb2JqLmhhc093blByb3BlcnR5KGspKVxuICAgICAgICBkZWxldGUgb2JqW2tdO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2QgYWRkcyBhIG1ldGhvZCB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhlIGZ1dHVybHkgY3JlYXRlZFxuICAgKiBncmFwaCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIFNpbmNlIHRoZXNlIG1ldGhvZHMgd2lsbCBiZSBib3VuZCB0byB0aGVpciBzY29wZSB3aGVuIHRoZSBpbnN0YW5jZXMgYXJlXG4gICAqIGNyZWF0ZWQsIGl0IGRvZXMgbm90IHVzZSB0aGUgcHJvdG90eXBlLiBCZWNhdXNlIG9mIHRoYXQsIG1ldGhvZHMgaGF2ZSB0b1xuICAgKiBiZSBhZGRlZCBiZWZvcmUgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIHRvIG1ha2UgdGhlbSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZTpcbiAgICpcbiAgICogID4gZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgcmV0dXJuIHRoaXMubm9kZXNBcnJheS5sZW5ndGg7XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLmdldE5vZGVzQ291bnQoKSk7IC8vIG91dHB1dHMgMFxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgVGhlIGdsb2JhbCBncmFwaCBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGZuKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG1ldGhvZE5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcbiAgICApXG4gICAgICB0aHJvdyAnYWRkTWV0aG9kOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmIChfbWV0aG9kc1ttZXRob2ROYW1lXSB8fCBncmFwaFttZXRob2ROYW1lXSlcbiAgICAgIHRocm93ICdUaGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIF9tZXRob2RzW21ldGhvZE5hbWVdID0gZm47XG4gICAgX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIG1ldGhvZCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLCBhbmRcbiAgICogZmFsc2UgZWxzZS5cbiAgICpcbiAgICogSGVyZSBhcmUgc29tZSBleGFtcGxlczpcbiAgICpcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCdhZGROb2RlJyk7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgPiBncmFwaC5oYXNNZXRob2QoJ2hhc01ldGhvZCcpOyAvLyByZXR1cm5zIHRydWVcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCd1bmV4aXN0aW5nTWV0aG9kJyk7IC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgIFRoZSByZXN1bHQuXG4gICAqL1xuICBncmFwaC5oYXNNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuICEhKF9tZXRob2RzW21ldGhvZE5hbWVdIHx8IGdyYXBoW21ldGhvZE5hbWVdKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kcyBhdHRhY2hlcyBhIGZ1bmN0aW9uIHRvIGEgbWV0aG9kLiBBbnl0aW1lIHRoZSBzcGVjaWZpZWRcbiAgICogbWV0aG9kIGlzIGNhbGxlZCwgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBhZnRlciwgd2l0aCB0aGVcbiAgICogc2FtZSBhcmd1bWVudHMgYW5kIGluIHRoZSBzYW1lIHNjb3BlLiBUaGUgYXR0YWNoZWQgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAqIHJpZ2h0IGJlZm9yZSBpZiB0aGUgbGFzdCBhcmd1bWVudCBpcyB0cnVlLCB1bmxlc3MgdGhlIG1ldGhvZCBpcyB0aGUgZ3JhcGhcbiAgICogY29uc3RydWN0b3IuXG4gICAqXG4gICAqIFRvIGF0dGFjaCBhIGZ1bmN0aW9uIHRvIHRoZSBncmFwaCBjb25zdHJ1Y3RvciwgdXNlICdjb25zdHJ1Y3RvcicgYXMgdGhlXG4gICAqIG1ldGhvZCBuYW1lIChmaXJzdCBhcmd1bWVudCkuXG4gICAqXG4gICAqIFRoZSBtYWluIGlkZWEgaXMgdG8gaGF2ZSBhIGNsZWFuIHdheSB0byBrZWVwIGN1c3RvbSBpbmRleGVzIHVwIHRvIGRhdGUsXG4gICAqIGZvciBpbnN0YW5jZTpcbiAgICpcbiAgICogID4gdmFyIHRpbWVzQWRkTm9kZUNhbGxlZCA9IDA7XG4gICAqICA+IGdyYXBoLmF0dGFjaCgnYWRkTm9kZScsICd0aW1lc0FkZE5vZGVDYWxsZWRJbmMnLCBmdW5jdGlvbigpIHtcbiAgICogID4gICB0aW1lc0FkZE5vZGVDYWxsZWQrKztcbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XG4gICAqICA+IGNvbnNvbGUubG9nKHRpbWVzQWRkTm9kZUNhbGxlZCk7IC8vIG91dHB1dHMgMFxuICAgKiAgPlxuICAgKiAgPiBteUdyYXBoLmFkZE5vZGUoeyBpZDogJzEnIH0pLmFkZE5vZGUoeyBpZDogJzInIH0pO1xuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDJcbiAgICpcbiAgICogVGhlIGlkZWEgZm9yIGNhbGxpbmcgYSBmdW5jdGlvbiBiZWZvcmUgaXMgdG8gcHJvdmlkZSBwcmUtcHJvY2Vzc29ycywgZm9yXG4gICAqIGluc3RhbmNlOlxuICAgKlxuICAgKiAgPiB2YXIgY29sb3JQYWxldHRlID0geyBQZXJzb246ICcjQzNDQkUxJywgUGxhY2U6ICcjOUJERUJEJyB9O1xuICAgKiAgPiBncmFwaC5hdHRhY2goJ2FkZE5vZGUnLCAnYXBwbHlOb2RlQ29sb3JQYWxldHRlJywgZnVuY3Rpb24obikge1xuICAgKiAgPiAgIG4uY29sb3IgPSBjb2xvclBhbGV0dGVbbi5jYXRlZ29yeV07XG4gICAqICA+IH0sIHRydWUpO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBteUdyYXBoLmFkZE5vZGUoeyBpZDogJ24wJywgY2F0ZWdvcnk6ICdQZXJzb24nIH0pO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLm5vZGVzKCduMCcpLmNvbG9yKTsgLy8gb3V0cHV0cyAnI0MzQ0JFMSdcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIHJlbGF0ZWQgbWV0aG9kIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29uc3RydWN0b3JcIi5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIGtleSAgICAgICAgVGhlIGtleSB0byBpZGVudGlmeSB0aGUgZnVuY3Rpb24gdG8gYXR0YWNoLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGJlZm9yZSAgICAgSWYgdHJ1ZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgVGhlIGdsb2JhbCBncmFwaCBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdyYXBoLmF0dGFjaCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGtleSwgZm4sIGJlZm9yZSkge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtZXRob2ROYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDMgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiA0XG4gICAgKVxuICAgICAgdGhyb3cgJ2F0dGFjaDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICB2YXIgYmluZGluZ3M7XG5cbiAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2NvbnN0cnVjdG9yJylcbiAgICAgIGJpbmRpbmdzID0gX2luaXRCaW5kaW5ncztcbiAgICBlbHNlIHtcbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgaWYgKCFfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgIHRocm93ICdUaGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgICAgICBiaW5kaW5ncyA9IF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoIV9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSlcbiAgICAgICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICAgICAgYmluZGluZ3MgPSBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJpbmRpbmdzW2tleV0pXG4gICAgICB0aHJvdyAnQSBmdW5jdGlvbiBcIicgKyBrZXkgKyAnXCIgaXMgYWxyZWFkeSBhdHRhY2hlZCAnICtcbiAgICAgICAgICAgICd0byB0aGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIuJztcblxuICAgIGJpbmRpbmdzW2tleV0gPSBmbjtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbGlhcyBvZiBhdHRhY2gobWV0aG9kTmFtZSwga2V5LCBmbiwgdHJ1ZSkuXG4gICAqL1xuICBncmFwaC5hdHRhY2hCZWZvcmUgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBrZXksIGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgaXMganVzdCBhbiBoZWxwZXIgdG8gZGVhbCB3aXRoIGN1c3RvbSBpbmRleGVzLiBJdCB0YWtlcyBhc1xuICAgKiBhcmd1bWVudHMgdGhlIG5hbWUgb2YgdGhlIGluZGV4IGFuZCBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGRpZmZlcmVudFxuICAgKiBmdW5jdGlvbnMgdG8gYmluZCB0byB0aGUgbWV0aG9kcy5cbiAgICpcbiAgICogSGVyZSBpcyBhIGJhc2ljIGV4YW1wbGUsIHRoYXQgY3JlYXRlcyBhbiBpbmRleCB0byBrZWVwIHRoZSBudW1iZXIgb2Ygbm9kZXNcbiAgICogaW4gdGhlIGN1cnJlbnQgZ3JhcGguIEl0IGFsc28gYWRkcyBhIG1ldGhvZCB0byBwcm92aWRlIGEgZ2V0dGVyIG9uIHRoYXRcbiAgICogbmV3IGluZGV4OlxuICAgKlxuICAgKiAgPiBzaWdtYS5jbGFzc2VzLmdyYXBoLmFkZEluZGV4KCdub2Rlc0NvdW50Jywge1xuICAgKiAgPiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudCA9IDA7XG4gICAqICA+ICAgfSxcbiAgICogID4gICBhZGROb2RlOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudCsrO1xuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgZHJvcE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgICAgdGhpcy5ub2Rlc0NvdW50LS07XG4gICAqICA+ICAgfVxuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRNZXRob2QoJ2dldE5vZGVzQ291bnQnLCBmdW5jdGlvbigpIHtcbiAgICogID4gICByZXR1cm4gdGhpcy5ub2Rlc0NvdW50O1xuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLmdldE5vZGVzQ291bnQoKSk7IC8vIG91dHB1dHMgMFxuICAgKiAgPlxuICAgKiAgPiBteUdyYXBoLmFkZE5vZGUoeyBpZDogJzEnIH0pLmFkZE5vZGUoeyBpZDogJzInIH0pO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLmdldE5vZGVzQ291bnQoKSk7IC8vIG91dHB1dHMgMlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgIFRoZSBuYW1lIG9mIHRoZSBpbmRleC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBiaW5kaW5ncyBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZ1bmN0aW9ucyB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hZGRJbmRleCA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdzKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICBPYmplY3QoYmluZGluZ3MpICE9PSBiaW5kaW5ncyB8fFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMlxuICAgIClcbiAgICAgIHRocm93ICdhZGRJbmRleDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoX2luZGV4ZXNbbmFtZV0pXG4gICAgICB0aHJvdyAnVGhlIGluZGV4IFwiJyArIG5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIHZhciBrO1xuXG4gICAgLy8gU3RvcmUgdGhlIGJpbmRpbmdzOlxuICAgIF9pbmRleGVzW25hbWVdID0gYmluZGluZ3M7XG5cbiAgICAvLyBBdHRhY2ggdGhlIGJpbmRpbmdzOlxuICAgIGZvciAoayBpbiBiaW5kaW5ncylcbiAgICAgIGlmICh0eXBlb2YgYmluZGluZ3Nba10gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdUaGUgYmluZGluZ3MgbXVzdCBiZSBmdW5jdGlvbnMuJztcbiAgICAgIGVsc2VcbiAgICAgICAgZ3JhcGguYXR0YWNoKGssIG5hbWUsIGJpbmRpbmdzW2tdKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGEgbm9kZSB0byB0aGUgZ3JhcGguIFRoZSBub2RlIG11c3QgYmUgYW4gb2JqZWN0LCB3aXRoIGFcbiAgICogc3RyaW5nIHVuZGVyIHRoZSBrZXkgXCJpZFwiLiBFeGNlcHQgZm9yIHRoaXMsIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCBhbnlcbiAgICogb3RoZXIgYXR0cmlidXRlLCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkIGFsbCBhbG9uZyB0aGUgbWFuaXB1bGF0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIGdyYXBoIG9wdGlvbiBcImNsb25lXCIgaGFzIGEgdHJ1dGh5IHZhbHVlLCB0aGUgbm9kZSB3aWxsIGJlIGNsb25lZFxuICAgKiB3aGVuIGFkZGVkIHRvIHRoZSBncmFwaC4gQWxzbywgaWYgdGhlIGdyYXBoIG9wdGlvbiBcImltbXV0YWJsZVwiIGhhcyBhXG4gICAqIHRydXRoeSB2YWx1ZSwgaXRzIGlkIHdpbGwgYmUgZGVmaW5lZCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gbm9kZSBUaGUgbm9kZSB0byBhZGQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2FkZE5vZGUnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgbm9kZSBpcyBhbiBvYmplY3QgYW5kIGhhcyBhbiBpZDpcbiAgICBpZiAoT2JqZWN0KG5vZGUpICE9PSBub2RlIHx8IGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnYWRkTm9kZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAodHlwZW9mIG5vZGUuaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBub2RlLmlkICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93ICdUaGUgbm9kZSBtdXN0IGhhdmUgYSBzdHJpbmcgb3IgbnVtYmVyIGlkLic7XG5cbiAgICBpZiAodGhpcy5ub2Rlc0luZGV4W25vZGUuaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIG5vZGUuaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIHZhciBrLFxuICAgICAgICBpZCA9IG5vZGUuaWQsXG4gICAgICAgIHZhbGlkTm9kZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xuICAgICAgZm9yIChrIGluIG5vZGUpXG4gICAgICAgIGlmIChrICE9PSAnaWQnKVxuICAgICAgICAgIHZhbGlkTm9kZVtrXSA9IG5vZGVba107XG4gICAgfSBlbHNlXG4gICAgICB2YWxpZE5vZGUgPSBub2RlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdpbW11dGFibGUnKSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZE5vZGUsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB2YWxpZE5vZGUuaWQgPSBpZDtcblxuICAgIC8vIEFkZCBlbXB0eSBjb250YWluZXJzIGZvciBlZGdlcyBpbmRleGVzOlxuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbaWRdID0gMDtcbiAgICB0aGlzLm91dE5laWdoYm9yc0NvdW50W2lkXSA9IDA7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtpZF0gPSAwO1xuXG4gICAgLy8gQWRkIHRoZSBub2RlIHRvIGluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc0FycmF5LnB1c2godmFsaWROb2RlKTtcbiAgICB0aGlzLm5vZGVzSW5kZXhbdmFsaWROb2RlLmlkXSA9IHZhbGlkTm9kZTtcblxuICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpbnN0YW5jZTpcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGFkZHMgYW4gZWRnZSB0byB0aGUgZ3JhcGguIFRoZSBlZGdlIG11c3QgYmUgYW4gb2JqZWN0LCB3aXRoIGFcbiAgICogc3RyaW5nIHVuZGVyIHRoZSBrZXkgXCJpZFwiLCBhbmQgc3RyaW5ncyB1bmRlciB0aGUga2V5cyBcInNvdXJjZVwiIGFuZFxuICAgKiBcInRhcmdldFwiIHRoYXQgZGVzaWduIGV4aXN0aW5nIG5vZGVzLiBFeGNlcHQgZm9yIHRoaXMsIGl0IGlzIHBvc3NpYmxlIHRvXG4gICAqIGFkZCBhbnkgb3RoZXIgYXR0cmlidXRlLCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkIGFsbCBhbG9uZyB0aGVcbiAgICogbWFuaXB1bGF0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIGdyYXBoIG9wdGlvbiBcImNsb25lXCIgaGFzIGEgdHJ1dGh5IHZhbHVlLCB0aGUgZWRnZSB3aWxsIGJlIGNsb25lZFxuICAgKiB3aGVuIGFkZGVkIHRvIHRoZSBncmFwaC4gQWxzbywgaWYgdGhlIGdyYXBoIG9wdGlvbiBcImltbXV0YWJsZVwiIGhhcyBhXG4gICAqIHRydXRoeSB2YWx1ZSwgaXRzIGlkLCBzb3VyY2UgYW5kIHRhcmdldCB3aWxsIGJlIGRlZmluZWQgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVkZ2UgVGhlIGVkZ2UgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdhZGRFZGdlJywgZnVuY3Rpb24oZWRnZSkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGVkZ2UgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYW4gaWQ6XG4gICAgaWYgKE9iamVjdChlZGdlKSAhPT0gZWRnZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2FkZEVkZ2U6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKHR5cGVvZiBlZGdlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5pZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgbXVzdCBoYXZlIGEgc3RyaW5nIG9yIG51bWJlciBpZC4nO1xuXG4gICAgaWYgKCh0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBlZGdlLnNvdXJjZSAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgICF0aGlzLm5vZGVzSW5kZXhbZWRnZS5zb3VyY2VdKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIHNvdXJjZSBtdXN0IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBpZC4nO1xuXG4gICAgaWYgKCh0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBlZGdlLnRhcmdldCAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgICF0aGlzLm5vZGVzSW5kZXhbZWRnZS50YXJnZXRdKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIHRhcmdldCBtdXN0IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBpZC4nO1xuXG4gICAgaWYgKHRoaXMuZWRnZXNJbmRleFtlZGdlLmlkXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBcIicgKyBlZGdlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgdmFsaWRFZGdlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIENoZWNrIHRoZSBcImNsb25lXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdjbG9uZScpKSB7XG4gICAgICBmb3IgKGsgaW4gZWRnZSlcbiAgICAgICAgaWYgKGsgIT09ICdpZCcgJiYgayAhPT0gJ3NvdXJjZScgJiYgayAhPT0gJ3RhcmdldCcpXG4gICAgICAgICAgdmFsaWRFZGdlW2tdID0gZWRnZVtrXTtcbiAgICB9IGVsc2VcbiAgICAgIHZhbGlkRWRnZSA9IGVkZ2U7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJpbW11dGFibGVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2ltbXV0YWJsZScpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRFZGdlLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLmlkLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ3NvdXJjZScsIHtcbiAgICAgICAgdmFsdWU6IGVkZ2Uuc291cmNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ3RhcmdldCcsIHtcbiAgICAgICAgdmFsdWU6IGVkZ2UudGFyZ2V0LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRFZGdlLmlkID0gZWRnZS5pZDtcbiAgICAgIHZhbGlkRWRnZS5zb3VyY2UgPSBlZGdlLnNvdXJjZTtcbiAgICAgIHZhbGlkRWRnZS50YXJnZXQgPSBlZGdlLnRhcmdldDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGVkZ2UgdG8gaW5kZXhlczpcbiAgICB0aGlzLmVkZ2VzQXJyYXkucHVzaCh2YWxpZEVkZ2UpO1xuICAgIHRoaXMuZWRnZXNJbmRleFt2YWxpZEVkZ2UuaWRdID0gdmFsaWRFZGdlO1xuXG4gICAgaWYgKCF0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0pXG4gICAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0gPVxuICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgIHZhbGlkRWRnZTtcblxuICAgIGlmICghdGhpcy5vdXROZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSlcbiAgICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0gPVxuICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICB2YWxpZEVkZ2U7XG5cbiAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0pXG4gICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgdmFsaWRFZGdlO1xuXG4gICAgaWYgKHZhbGlkRWRnZS50YXJnZXQgIT09IHZhbGlkRWRnZS5zb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXSlcbiAgICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXSA9XG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICAgIHZhbGlkRWRnZTtcbiAgICB9XG5cbiAgICAvLyBLZWVwIGNvdW50cyB1cCB0byBkYXRlOlxuICAgIHRoaXMuaW5OZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2UudGFyZ2V0XSsrO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnNvdXJjZV0rKztcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS50YXJnZXRdKys7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2Uuc291cmNlXSsrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkcm9wcyBhIG5vZGUgZnJvbSB0aGUgZ3JhcGguIEl0IGFsc28gcmVtb3ZlcyBlYWNoIGVkZ2UgdGhhdCBpc1xuICAgKiBib3VuZCB0byBpdCwgdGhyb3VnaCB0aGUgZHJvcEVkZ2UgbWV0aG9kLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIG5vZGVcbiAgICogZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgVGhlIG5vZGUgaWQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkcm9wTm9kZScsIGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdkcm9wTm9kZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIXRoaXMubm9kZXNJbmRleFtpZF0pXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgXCInICsgaWQgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgIHZhciBpLCBrLCBsO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gaW5kZXhlczpcbiAgICBkZWxldGUgdGhpcy5ub2Rlc0luZGV4W2lkXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLm5vZGVzQXJyYXlbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMubm9kZXNBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZXM6XG4gICAgZm9yIChpID0gdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgaWYgKHRoaXMuZWRnZXNBcnJheVtpXS5zb3VyY2UgPT09IGlkIHx8IHRoaXMuZWRnZXNBcnJheVtpXS50YXJnZXQgPT09IGlkKVxuICAgICAgICB0aGlzLmRyb3BFZGdlKHRoaXMuZWRnZXNBcnJheVtpXS5pZCk7XG5cbiAgICAvLyBSZW1vdmUgcmVsYXRlZCBlZGdlIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtpZF07XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2lkXTtcblxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzQ291bnRbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0NvdW50W2lkXTtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtpZF07XG5cbiAgICBmb3IgKGsgaW4gdGhpcy5ub2Rlc0luZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4W2tdW2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2tdW2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2tdW2lkXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGRyb3BzIGFuIGVkZ2UgZnJvbSB0aGUgZ3JhcGguIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgZWRnZVxuICAgKiBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCBUaGUgZWRnZSBpZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2Ryb3BFZGdlJywgZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBhcmd1bWVudHMgYXJlIHZhbGlkOlxuICAgIGlmICgodHlwZW9mIGlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB8fFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2Ryb3BFZGdlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICghdGhpcy5lZGdlc0luZGV4W2lkXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBcIicgKyBpZCArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgdmFyIGksIGwsIGVkZ2U7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGVkZ2UgZnJvbSBpbmRleGVzOlxuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmVkZ2VzSW5kZXhbaWRdO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMuZWRnZXNBcnJheVtpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy5lZGdlc0FycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmluTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXSkubGVuZ3RoKVxuICAgICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdO1xuXG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XVtlZGdlLmlkXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XSkubGVuZ3RoKVxuICAgICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XTtcblxuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF07XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgIT09IGVkZ2Uuc291cmNlKSB7XG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdW2VkZ2UuaWRdO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV0pLmxlbmd0aClcbiAgICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXTtcbiAgICB9XG5cbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbZWRnZS50YXJnZXRdLS07XG4gICAgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtlZGdlLnNvdXJjZV0tLTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2VkZ2Uuc291cmNlXS0tO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbZWRnZS50YXJnZXRdLS07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGRlc3Ryb3lzIHRoZSBjdXJyZW50IGluc3RhbmNlLiBJdCBiYXNpY2FsbHkgZW1wdGllcyBlYWNoIGluZGV4XG4gICAqIGFuZCBtZXRob2RzIGF0dGFjaGVkIHRvIHRoZSBncmFwaC5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgIC8vIERlbGV0ZSBhcnJheXM6XG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgZGVsZXRlIHRoaXMubm9kZXNBcnJheTtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0FycmF5O1xuXG4gICAgLy8gRGVsZXRlIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMubm9kZXNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNDb3VudDtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNDb3VudDtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNDb3VudDtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGVtcHRpZXMgdGhlIG5vZGVzIGFuZCBlZGdlcyBhcnJheXMsIGFzIHdlbGwgYXMgdGhlIGRpZmZlcmVudFxuICAgKiBpbmRleGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnY2xlYXInLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoID0gMDtcbiAgICB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoID0gMDtcblxuICAgIC8vIER1ZSB0byBHQyBpc3N1ZXMsIEkgcHJlZmVyIG5vdCB0byBjcmVhdGUgbmV3IG9iamVjdC4gVGhlc2Ugb2JqZWN0cyBhcmVcbiAgICAvLyBvbmx5IGF2YWlsYWJsZSBmcm9tIHRoZSBtZXRob2RzIGFuZCBhdHRhY2hlZCBmdW5jdGlvbnMsIGJ1dCBzdGlsbCwgaXQgaXNcbiAgICAvLyBiZXR0ZXIgdG8gcHJldmVudCBnaG9zdCByZWZlcmVuY2VzIHRvIHVucmVsZXZhbnQgZGF0YS4uLlxuICAgIF9fZW1wdHlPYmplY3QodGhpcy5ub2Rlc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuZWRnZXNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm5vZGVzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5pbk5laWdoYm9yc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMub3V0TmVpZ2hib3JzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5hbGxOZWlnaGJvcnNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmluTmVpZ2hib3JzQ291bnQpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5vdXROZWlnaGJvcnNDb3VudCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmFsbE5laWdoYm9yc0NvdW50KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVhZHMgYW4gb2JqZWN0IGFuZCBhZGRzIHRoZSBub2RlcyBhbmQgZWRnZXMsIHRocm91Z2ggdGhlXG4gICAqIHByb3BlciBtZXRob2RzIFwiYWRkTm9kZVwiIGFuZCBcImFkZEVkZ2VcIi5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlOlxuICAgKlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBteUdyYXBoLnJlYWQoe1xuICAgKiAgPiAgIG5vZGVzOiBbXG4gICAqICA+ICAgICB7IGlkOiAnbjAnIH0sXG4gICAqICA+ICAgICB7IGlkOiAnbjEnIH1cbiAgICogID4gICBdLFxuICAgKiAgPiAgIGVkZ2VzOiBbXG4gICAqICA+ICAgICB7XG4gICAqICA+ICAgICAgIGlkOiAnZTAnLFxuICAgKiAgPiAgICAgICBzb3VyY2U6ICduMCcsXG4gICAqICA+ICAgICAgIHRhcmdldDogJ24xJ1xuICAgKiAgPiAgICAgfVxuICAgKiAgPiAgIF1cbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IGNvbnNvbGUubG9nKFxuICAgKiAgPiAgIG15R3JhcGgubm9kZXMoKS5sZW5ndGgsXG4gICAqICA+ICAgbXlHcmFwaC5lZGdlcygpLmxlbmd0aFxuICAgKiAgPiApOyAvLyBvdXRwdXRzIDIgMVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGcgVGhlIGdyYXBoIG9iamVjdC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgncmVhZCcsIGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgYSxcbiAgICAgICAgbDtcblxuICAgIGEgPSBnLm5vZGVzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkTm9kZShhW2ldKTtcblxuICAgIGEgPSBnLmVkZ2VzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkRWRnZShhW2ldKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgb25lIG9yIHNldmVyYWwgbm9kZXMsIGRlcGVuZGluZyBvbiBob3cgaXQgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBUbyBnZXQgdGhlIGFycmF5IG9mIG5vZGVzLCBjYWxsIFwibm9kZXNcIiB3aXRob3V0IGFyZ3VtZW50LiBUbyBnZXQgYVxuICAgKiBzcGVjaWZpYyBub2RlLCBjYWxsIGl0IHdpdGggdGhlIGlkIG9mIHRoZSBub2RlLiBUaGUgZ2V0IG11bHRpcGxlIG5vZGUsXG4gICAqIGNhbGwgaXQgd2l0aCBhbiBhcnJheSBvZiBpZHMsIGFuZCBpdCB3aWxsIHJldHVybiB0aGUgYXJyYXkgb2Ygbm9kZXMsIGluXG4gICAqIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xhcnJheSl9IHYgRXZlbnR1YWxseSBvbmUgaWQsIGFuIGFycmF5IG9mIGlkcy5cbiAgICogQHJldHVybiB7b2JqZWN0fGFycmF5fSAgICAgIFRoZSByZWxhdGVkIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ25vZGVzJywgZnVuY3Rpb24odikge1xuICAgIC8vIENsb25lIHRoZSBhcnJheSBvZiBub2RlcyBhbmQgcmV0dXJuIGl0OlxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkuc2xpY2UoMCk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJykpXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0luZGV4W3ZdO1xuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEgPSBbXTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHYubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodHlwZW9mIHZbaV0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2W2ldID09PSAnbnVtYmVyJylcbiAgICAgICAgICBhLnB1c2godGhpcy5ub2Rlc0luZGV4W3ZbaV1dKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93ICdub2RlczogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHRocm93ICdub2RlczogV3JvbmcgYXJndW1lbnRzLic7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyB0aGUgZGVncmVlIG9mIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93XG4gICAqIGl0IGlzIGNhbGxlZC4gSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBnZXQgaW5jb21pbmcgb3Igb3V0Y29taW5nIGRlZ3JlZXNcbiAgICogaW5zdGVhZCBieSBzcGVjaWZ5aW5nICdpbicgb3IgJ291dCcgYXMgYSBzZWNvbmQgYXJndW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xhcnJheX0gdiAgICAgT25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgd2hpY2ggV2hpY2ggZGVncmVlIGlzIHJlcXVpcmVkLiBWYWx1ZXMgYXJlICdpbicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ291dCcsIGFuZCBieSBkZWZhdWx0IHRoZSBub3JtYWwgZGVncmVlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8YXJyYXl9ICAgICAgIFRoZSByZWxhdGVkIGRlZ3JlZSBvciBhcnJheSBvZiBkZWdyZWVzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkZWdyZWUnLCBmdW5jdGlvbih2LCB3aGljaCkge1xuICAgIC8vIENoZWNrIHdoaWNoIGRlZ3JlZSBpcyByZXF1aXJlZDpcbiAgICB3aGljaCA9IHtcbiAgICAgICdpbic6IHRoaXMuaW5OZWlnaGJvcnNDb3VudCxcbiAgICAgICdvdXQnOiB0aGlzLm91dE5laWdoYm9yc0NvdW50XG4gICAgfVt3aGljaCB8fCAnJ10gfHwgdGhpcy5hbGxOZWlnaGJvcnNDb3VudDtcblxuICAgIC8vIFJldHVybiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKVxuICAgICAgcmV0dXJuIHdoaWNoW3ZdO1xuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHdoaWNoW3ZbaV1dKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93ICdkZWdyZWU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnZGVncmVlOiBXcm9uZyBhcmd1bWVudHMuJztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIGVkZ2VzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cbiAgICpcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBlZGdlcywgY2FsbCBcImVkZ2VzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcbiAgICogc3BlY2lmaWMgZWRnZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgZWRnZS4gVGhlIGdldCBtdWx0aXBsZSBlZGdlLFxuICAgKiBjYWxsIGl0IHdpdGggYW4gYXJyYXkgb2YgaWRzLCBhbmQgaXQgd2lsbCByZXR1cm4gdGhlIGFycmF5IG9mIGVkZ2VzLCBpblxuICAgKiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8YXJyYXkpfSB2IEV2ZW50dWFsbHkgb25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBlZGdlIG9yIGFycmF5IG9mIGVkZ2VzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdlZGdlcycsIGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2YgZWRnZXMgYW5kIHJldHVybiBpdDpcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5lZGdlc0FycmF5LnNsaWNlKDApO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIGVkZ2U6XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNJbmRleFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBlZGdlOlxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHRoaXMuZWRnZXNJbmRleFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnZWRnZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnZWRnZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2Ygc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2lnbWEuY2xhc3NlcyA9IHNpZ21hLmNsYXNzZXMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBzaWdtYS5jbGFzc2VzLmdyYXBoID0gZ3JhcGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ3JhcGg7XG4gICAgZXhwb3J0cy5ncmFwaCA9IGdyYXBoO1xuICB9IGVsc2VcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jbGFzc2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBjYW1lcmEgY29uc3RydWN0b3IuIEl0IGp1c3QgaW5pdGlhbGl6ZXMgaXRzIGF0dHJpYnV0ZXMgYW5kIG1ldGhvZHMuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgaWQgICAgICAgVGhlIGlkLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgZ3JhcGggICAgVGhlIGdyYXBoLlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICBvcHRpb25zICBFdmVudHVhbGx5IHNvbWUgb3ZlcnJpZGluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGZyZXNoIG5ldyBjYW1lcmEgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYSA9IGZ1bmN0aW9uKGlkLCBncmFwaCwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcbiAgICAgIHZhbHVlOiBncmFwaFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG4gICAgICB2YWx1ZTogaWRcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWRQcmVmaXgnLCB7XG4gICAgICB2YWx1ZTogJ3JlYWRfY2FtJyArIGlkICsgJzonXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmVmaXgnLCB7XG4gICAgICB2YWx1ZTogJ2NhbScgKyBpZCArICc6J1xuICAgIH0pO1xuXG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMucmF0aW8gPSAxO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMuaXNBbmltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMpID9cbiAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0KG9wdGlvbnMpIDpcbiAgICAgIHNldHRpbmdzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYW1lcmEgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29vcmRpbmF0ZXMgVGhlIG5ldyBjb29yZGluYXRlcyBvYmplY3QuXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgICAgICAgUmV0dXJucyB0aGUgY2FtZXJhLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdvVG8gPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGlmICghdGhpcy5zZXR0aW5ncygnZW5hYmxlQ2FtZXJhJykpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBjID0gY29vcmRpbmF0ZXMgfHwge30sXG4gICAgICAgIGtleXMgPSBbJ3gnLCAneScsICdyYXRpbycsICdhbmdsZSddO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKGNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNba2V5c1tpXV0gPT09ICdudW1iZXInICYmICFpc05hTihjW2tleXNbaV1dKSlcbiAgICAgICAgICB0aGlzW2tleXNbaV1dID0gY1trZXlzW2ldXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93ICdWYWx1ZSBmb3IgXCInICsga2V5c1tpXSArICdcIiBpcyBub3QgYSBudW1iZXIuJztcbiAgICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnY29vcmRpbmF0ZXNVcGRhdGVkJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgZ3JhcGggYW5kIGNvbXB1dGVzIGZvciBlYWNoIG5vZGUgYW5kIGVkZ2VzIGl0c1xuICAgKiBjb29yZGluYXRlcyByZWxhdGl2ZWx5IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNhbWVyYS4gQmFzaWNhbGx5LCBpdCB3aWxsXG4gICAqIGNvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBncmFwaGljIHJlbmRlcmVycy5cbiAgICpcbiAgICogU2luY2UgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBkaWZmZXJlbnQgY2FtZXJhcyBhbmQgZGlmZmVyZW50XG4gICAqIHJlbmRlcmVycywgaXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBhIHByZWZpeCB0byBwdXQgYmVmb3JlIHRoZSBuZXdcbiAgICogY29vcmRpbmF0ZXMgKHRvIGdldCBzb21ldGhpbmcgbGlrZSBcIm5vZGUuY2FtZXJhMV94XCIpXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IHJlYWQgICAgVGhlIHByZWZpeCBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gcmVhZC5cbiAgICogQHBhcmFtICB7P3N0cmluZ30gd3JpdGUgICBUaGUgcHJlZml4IG9mIHRoZSBjb29yZGluYXRlcyB0byB3cml0ZS5cbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLiBUaG9zZSBjYW4gYmU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHJlc3RyaWN0ZWQgbm9kZXMgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHJlc3RyaWN0ZWQgZWRnZXMgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHdpZHRoLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgIFJldHVybnMgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5hcHBseVZpZXcgPSBmdW5jdGlvbihyZWFkLCB3cml0ZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHdyaXRlID0gd3JpdGUgIT09IHVuZGVmaW5lZCA/IHdyaXRlIDogdGhpcy5wcmVmaXg7XG4gICAgcmVhZCA9IHJlYWQgIT09IHVuZGVmaW5lZCA/IHJlYWQgOiB0aGlzLnJlYWRQcmVmaXg7XG5cbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLm5vZGVzIHx8IHRoaXMuZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgZWRnZXMgPSBvcHRpb25zLmVkZ2VzIHx8IHRoaXMuZ3JhcGguZWRnZXMoKTtcblxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBub2RlLFxuICAgICAgICByZWxDb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXG4gICAgICAgIHJlbFNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpIC8gdGhpcy5yYXRpbyxcbiAgICAgICAgbm9kZVJhdGlvID0gTWF0aC5wb3codGhpcy5yYXRpbywgdGhpcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKSxcbiAgICAgICAgZWRnZVJhdGlvID0gTWF0aC5wb3codGhpcy5yYXRpbywgdGhpcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKSxcbiAgICAgICAgeE9mZnNldCA9IChvcHRpb25zLndpZHRoIHx8IDApIC8gMiAtIHRoaXMueCAqIHJlbENvcyAtIHRoaXMueSAqIHJlbFNpbixcbiAgICAgICAgeU9mZnNldCA9IChvcHRpb25zLmhlaWdodCB8fCAwKSAvIDIgLSB0aGlzLnkgKiByZWxDb3MgKyB0aGlzLnggKiByZWxTaW47XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBub2RlW3dyaXRlICsgJ3gnXSA9XG4gICAgICAgIChub2RlW3JlYWQgKyAneCddIHx8IDApICogcmVsQ29zICtcbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxTaW4gK1xuICAgICAgICB4T2Zmc2V0O1xuICAgICAgbm9kZVt3cml0ZSArICd5J10gPVxuICAgICAgICAobm9kZVtyZWFkICsgJ3knXSB8fCAwKSAqIHJlbENvcyAtXG4gICAgICAgIChub2RlW3JlYWQgKyAneCddIHx8IDApICogcmVsU2luICtcbiAgICAgICAgeU9mZnNldDtcbiAgICAgIG5vZGVbd3JpdGUgKyAnc2l6ZSddID1cbiAgICAgICAgKG5vZGVbcmVhZCArICdzaXplJ10gfHwgMCkgL1xuICAgICAgICBub2RlUmF0aW87XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZWRnZXNbaV1bd3JpdGUgKyAnc2l6ZSddID1cbiAgICAgICAgKGVkZ2VzW2ldW3JlYWQgKyAnc2l6ZSddIHx8IDApIC9cbiAgICAgICAgZWRnZVJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiBjYW1lcmEgdG8gdGhlIGZyYW1lIG9mIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGNhbWVyYS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGNhbWVyYS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBwb2ludCBjb29yZGluYXRlcyBpbiB0aGUgZnJhbWUgb2YgdGhlIGdyYXBoLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdyYXBoUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB2ZWN0b3IpIHtcbiAgICB2YXIgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9yaWdpbiBkaWZmZXJlbnRpYWwgdmVjdG9yOlxuICAgIGlmICghdmVjdG9yKSB7XG4gICAgICBYID0gLSAodGhpcy54ICogY29zICsgdGhpcy55ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgICBZID0gLSAodGhpcy55ICogY29zIC0gdGhpcy54ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICh4ICogY29zICsgeSAqIHNpbikgLyB0aGlzLnJhdGlvICsgWCxcbiAgICAgIHk6ICh5ICogY29zIC0geCAqIHNpbikgLyB0aGlzLnJhdGlvICsgWVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgZnJhbWUgb2YgdGhlXG4gICAqIGdyYXBoIHRvIHRoZSBmcmFtZSBvZiB0aGUgY2FtZXJhLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgZ3JhcGguXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBncmFwaC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBwb2ludCBjb29yZGluYXRlcyBpbiB0aGUgZnJhbWUgb2YgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5jYW1lcmFQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHZlY3Rvcikge1xuICAgIHZhciBYID0gMCxcbiAgICAgICAgWSA9IDAsXG4gICAgICAgIGNvcyA9IE1hdGguY29zKHRoaXMuYW5nbGUpLFxuICAgICAgICBzaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKTtcblxuICAgIC8vIFJldmVydCB0aGUgb3JpZ2luIGRpZmZlcmVudGlhbCB2ZWN0b3I6XG4gICAgaWYgKCF2ZWN0b3IpIHtcbiAgICAgIFggPSAtICh0aGlzLnggKiBjb3MgKyB0aGlzLnkgKiBzaW4pIC8gdGhpcy5yYXRpbztcbiAgICAgIFkgPSAtICh0aGlzLnkgKiBjb3MgLSB0aGlzLnggKiBzaW4pIC8gdGhpcy5yYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKCh4IC0gWCkgKiBjb3MgLSAoeSAtIFkpICogc2luKSAqIHRoaXMucmF0aW8sXG4gICAgICB5OiAoKHkgLSBZKSAqIGNvcyArICh4IC0gWCkgKiBzaW4pICogdGhpcy5yYXRpb1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgY2FtZXJhLiBUaGlzIGlzXG4gICAqIGVzcGVjaWFsbHkgdXNlZnVsIHRvIGFwcGx5IHRoZSBjYW1lcmEgdmlldyBkaXJlY3RseSBpbiBzaGFkZXJzLCBpbiBjYXNlIG9mXG4gICAqIFdlYkdMIHJlbmRlcmluZy5cbiAgICpcbiAgICogQHJldHVybiB7YXJyYXl9IFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuZ2V0TWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUoMSAvIHRoaXMucmF0aW8pLFxuICAgICAgICByb3RhdGlvbiA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKHRoaXMuYW5nbGUpLFxuICAgICAgICB0cmFuc2xhdGlvbiA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnRyYW5zbGF0aW9uKC10aGlzLngsIC10aGlzLnkpLFxuICAgICAgICBtYXRyaXggPSBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseShcbiAgICAgICAgICB0cmFuc2xhdGlvbixcbiAgICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseShcbiAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgc2NhbGVcbiAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICByZXR1cm4gbWF0cml4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtpbmcgYSB3aWR0aCBhbmQgYSBoZWlnaHQgYXMgcGFyYW1ldGVycywgdGhpcyBtZXRob2QgcmV0dXJucyB0aGVcbiAgICogY29vcmRpbmF0ZXMgb2YgdGhlIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhlIGNhbWVyYSBvbiBzY3JlZW4sIGluIHRoZVxuICAgKiBncmFwaCdzIHJlZmVyZW50aWVsLlxuICAgKlxuICAgKiBUbyBrZWVwIGRpc3BsYXlpbmcgbGFiZWxzIG9mIG5vZGVzIGdvaW5nIG91dCBvZiB0aGUgc2NyZWVuLCB0aGUgbWV0aG9kXG4gICAqIGtlZXBzIGEgbWFyZ2luIGFyb3VuZCB0aGUgc2NyZWVuIGluIHRoZSByZXR1cm5lZCByZWN0YW5nbGUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGggIFRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzY3JlZW4uXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSByZWN0YW5nbGUgYXMgeDEsIHkxLCB4MiBhbmQgeTIsIHJlcHJlc2VudGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0d28gb3Bwb3NpdGUgcG9pbnRzLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldFJlY3RhbmdsZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgd2lkdGhWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCwgMCwgdHJ1ZSksXG4gICAgICAgIGhlaWdodFZlY3QgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKDAsIGhlaWdodCwgdHJ1ZSksXG4gICAgICAgIGNlbnRlclZlY3QgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgdHJ1ZSksXG4gICAgICAgIG1hcmdpblggPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoIC8gNCwgMCwgdHJ1ZSkueCxcbiAgICAgICAgbWFyZ2luWSA9IHRoaXMuY2FtZXJhUG9zaXRpb24oMCwgaGVpZ2h0IC8gNCwgdHJ1ZSkueTtcblxuICAgIHJldHVybiB7XG4gICAgICB4MTogdGhpcy54IC0gY2VudGVyVmVjdC54IC0gbWFyZ2luWCxcbiAgICAgIHkxOiB0aGlzLnkgLSBjZW50ZXJWZWN0LnkgLSBtYXJnaW5ZLFxuICAgICAgeDI6IHRoaXMueCAtIGNlbnRlclZlY3QueCArIG1hcmdpblggKyB3aWR0aFZlY3QueCxcbiAgICAgIHkyOiB0aGlzLnkgLSBjZW50ZXJWZWN0LnkgLSBtYXJnaW5ZICsgd2lkdGhWZWN0LnksXG4gICAgICBoZWlnaHQ6IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3coaGVpZ2h0VmVjdC54LCAyKSArXG4gICAgICAgIE1hdGgucG93KGhlaWdodFZlY3QueSArIDIgKiBtYXJnaW5ZLCAyKVxuICAgICAgKVxuICAgIH07XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWR0cmVlIE1vZHVsZVxuICAgKiA9PT09PT09PT09PT09PT09PT09PT1cbiAgICpcbiAgICogQXV0aG9yOiBHdWlsbGF1bWUgUGxpcXVlIChZb21ndWl0aGVyZWFsKVxuICAgKiBWZXJzaW9uOiAwLjJcbiAgICovXG5cblxuXG4gIC8qKlxuICAgKiBRdWFkIEdlb21ldHJpYyBPcGVyYXRpb25zXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogQSB1c2VmdWwgYmF0Y2ggb2YgZ2VvbWV0cmljIG9wZXJhdGlvbnMgdXNlZCBieSB0aGUgcXVhZHRyZWUuXG4gICAqL1xuXG4gIHZhciBfZ2VvbSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBub2RlIHdpdGggeCwgeSBhbmQgc2l6ZSBpbnRvIGFuXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBncmFwaCBub2RlIHdpdGggYXQgbGVhc3QgYSBwb2ludCAoeCwgeSkgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHBvaW50VG9TcXVhcmU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBuLnggLSBuLnNpemUsXG4gICAgICAgIHkxOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIHgyOiBuLnggKyBuLnNpemUsXG4gICAgICAgIHkyOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIGhlaWdodDogbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICovXG4gICAgaXNBeGlzQWxpZ25lZDogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIueDEgPT09IHIueDIgfHwgci55MSA9PT0gci55MjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0b3AgcG9pbnRzIG9mIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUuIFRoaXMgaXMgdXNlZnVsIGluXG4gICAgICogY2FzZXMgd2hlbiB0aGUgcmVjdGFuZ2xlIGhhcyBiZWVuIHJvdGF0ZWQgKGxlZnQsIHJpZ2h0IG9yIGJvdHRvbSB1cCkgYW5kXG4gICAgICogbGF0ZXIgb3BlcmF0aW9ucyBuZWVkIHRvIGtub3cgdGhlIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmVjdGFuZ2xlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGF4aXNBbGlnbmVkVG9wUG9pbnRzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgIC8vIEJhc2ljXG4gICAgICBpZiAoci55MSA9PT0gci55MiAmJiByLngxIDwgci54MilcbiAgICAgICAgcmV0dXJuIHI7XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gcmlnaHRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPiByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxIC0gci5oZWlnaHQsIHkxOiByLnkxLFxuICAgICAgICAgIHgyOiByLngxLCB5Mjogci55MSxcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gbGVmdFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA8IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEsIHkxOiByLnkyLFxuICAgICAgICAgIHgyOiByLngyICsgci5oZWlnaHQsIHkyOiByLnkyLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gQm90dG9tJ3MgdXBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiByLngyLCB5MTogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICB4Mjogci54MSwgeTI6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgbGVmdCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyTGVmdENvb3I6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB3aWR0aCA9IChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KHIueDIgLSByLngxLCAyKSArXG4gICAgICAgICAgTWF0aC5wb3coci55MiAtIHIueTEsIDIpXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHIueDEgLSAoci55MiAtIHIueTEpICogci5oZWlnaHQgLyB3aWR0aCxcbiAgICAgICAgeTogci55MSArIChyLngyIC0gci54MSkgKiByLmhlaWdodCAvIHdpZHRoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciByaWdodCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50c1xuICAgICAqIGFuZCBpdHMgbG93ZXIgbGVmdCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGNvcm5lcidzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyUmlnaHRDb29yOiBmdW5jdGlvbihyLCBsbGMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxsYy54IC0gci54MSArIHIueDIsXG4gICAgICAgIHk6IGxsYy55IC0gci55MSArIHIueTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYWxsIHRoZSBjb3JuZXJzIG9mIGEgcmVjdGFuZ2xlIGZyb20gaXRzIHRvcCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIHRoZSBmb3VyIGNvcm5lcnMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb3JuZXJzOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgbGxjID0gdGhpcy5sb3dlckxlZnRDb29yKHIpLFxuICAgICAgICAgIGxyYyA9IHRoaXMubG93ZXJSaWdodENvb3IociwgbGxjKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IHIueDEsIHk6IHIueTF9LFxuICAgICAgICB7eDogci54MiwgeTogci55Mn0sXG4gICAgICAgIHt4OiBsbGMueCwgeTogbGxjLnl9LFxuICAgICAgICB7eDogbHJjLngsIHk6IGxyYy55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzcXVhcmUgZGVmaW5lZCBieSBpdHMgYm91bmRhcmllcyBpbnRvIGZvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEJvdW5kYXJpZXMgb2YgdGhlIHNxdWFyZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb3VyIG5ldyBzcXVhcmVzLCB0aGVtc2VsdmVzXG4gICAgICogICAgICAgICAgICAgICAgICBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHRoZWlyIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICovXG4gICAgc3BsaXRTcXVhcmU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBmb3VyIGF4aXMgYmV0d2VlbiBjb3JuZXJzIG9mIHJlY3RhbmdsZSBBIGFuZCBjb3JuZXJzIG9mXG4gICAgICogcmVjdGFuZ2xlIEIuIFRoaXMgaXMgbmVlZGVkIGxhdGVyIHRvIGNoZWNrIGFuIGV2ZW50dWFsIGNvbGxpc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQSdzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBCJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgZm91ciBheGlzIGRlZmluZWQgYnkgdGhlaXIgY29vcmRpbmF0ZXMgKHgseSkuXG4gICAgICovXG4gICAgYXhpczogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzBdLngsIHk6IGMxWzFdLnkgLSBjMVswXS55fSxcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVszXS54LCB5OiBjMVsxXS55IC0gYzFbM10ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMl0ueCwgeTogYzJbMF0ueSAtIGMyWzJdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzFdLngsIHk6IGMyWzBdLnkgLSBjMlsxXS55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdCBhIHJlY3RhbmdsZSdzIGNvcm5lciBvbiBhbiBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIGNvcm5lciAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhbiBheGlzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9qZWN0aW9uIGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKGMsIGEpIHtcbiAgICAgIHZhciBsID0gKFxuICAgICAgICAoYy54ICogYS54ICsgYy55ICogYS55KSAvXG4gICAgICAgIChNYXRoLnBvdyhhLngsIDIpICsgTWF0aC5wb3coYS55LCAyKSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGwgKiBhLngsXG4gICAgICAgIHk6IGwgKiBhLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBvbmUgcGFydGljdWxhciBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgIEFuIGF4aXMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZSBvbiB0aGUgYXhpcy5cbiAgICAgKi9cbiAgICBheGlzQ29sbGlzaW9uOiBmdW5jdGlvbihhLCBjMSwgYzIpIHtcbiAgICAgIHZhciBzYzEgPSBbXSxcbiAgICAgICAgICBzYzIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IDQ7IGNpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9qZWN0aW9uKGMxW2NpXSwgYSksXG4gICAgICAgICAgICBwMiA9IHRoaXMucHJvamVjdGlvbihjMltjaV0sIGEpO1xuXG4gICAgICAgIHNjMS5wdXNoKHAxLnggKiBhLnggKyBwMS55ICogYS55KTtcbiAgICAgICAgc2MyLnB1c2gocDIueCAqIGEueCArIHAyLnkgKiBhLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4YzEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1heGMyID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MyKSxcbiAgICAgICAgICBtaW5jMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWluYzIgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzIpO1xuXG4gICAgICByZXR1cm4gKG1pbmMyIDw9IG1heGMxICYmIG1heGMyID49IG1pbmMxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIGVhY2ggb25lIG9mIHRoZWlyIGZvdXIgYXhpcy4gSWZcbiAgICAgKiBhbGwgYXhpcyBjb2xsaWRlLCB0aGVuIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBjb2xsaWRlIG9uIHRoZSBwbGFuZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbjogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyhjMSwgYzIpLFxuICAgICAgICAgIGNvbCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBjb2wgPSBjb2wgJiYgdGhpcy5heGlzQ29sbGlzaW9uKGF4aXNbaV0sIGMxLCBjMik7XG5cbiAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFF1YWQgRnVuY3Rpb25zXG4gICAqIC0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgUXVhZHRyZWUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMuXG4gICAqIEZvciBlYWNoIG9mIHRob3NlIGZ1bmN0aW9ucywgd2UgY29uc2lkZXIgdGhhdCBpbiBhIHNwbGl0dGVkIHF1YWQsIHRoZVxuICAgKiBpbmRleCBvZiBlYWNoIG5vZGUgaXMgdGhlIGZvbGxvd2luZzpcbiAgICogMDogdG9wIGxlZnRcbiAgICogMTogdG9wIHJpZ2h0XG4gICAqIDI6IGJvdHRvbSBsZWZ0XG4gICAqIDM6IGJvdHRvbSByaWdodFxuICAgKlxuICAgKiBNb3Jlb3ZlciwgdGhlIGhlcmVhZnRlciBxdWFkJ3MgcGhpbG9zb3BoeSBpcyB0byBjb25zaWRlciB0aGF0IGlmIGFuIGVsZW1lbnRcbiAgICogY29sbGlkZXMgd2l0aCBtb3JlIHRoYW4gb25lIG5vZGVzLCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byBlYWNoIG9mIHRoZVxuICAgKiBub2RlcyBpdCBjb2xsaWRlcyB3aXRoIHdoZXJlIG90aGVyIHdvdWxkIGxldCBpdCBsaWUgb24gYSBoaWdoZXIgbm9kZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQgaW4gdGhlIHF1YWRcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgICAgICBBIHBvaW50IGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkQm91bmRzIEJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgKHgsIHksIHdpZHRoLCBoZWlndGgpLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXgocG9pbnQsIHF1YWRCb3VuZHMpIHtcbiAgICB2YXIgeG1wID0gcXVhZEJvdW5kcy54ICsgcXVhZEJvdW5kcy53aWR0aCAvIDIsXG4gICAgICAgIHltcCA9IHF1YWRCb3VuZHMueSArIHF1YWRCb3VuZHMuaGVpZ2h0IC8gMixcbiAgICAgICAgdG9wID0gKHBvaW50LnkgPCB5bXApLFxuICAgICAgICBsZWZ0ID0gKHBvaW50LnggPCB4bXApO1xuXG4gICAgaWYgKHRvcCkge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHJlY3RhbmdsZSAgIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgcXVhZENvcm5lcnMgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXhlcyhyZWN0YW5nbGUsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoKHJlY3RhbmdsZS54MiA+PSBxdWFkQ29ybmVyc1tpXVswXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueDEgPD0gcXVhZENvcm5lcnNbaV1bMV0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxICsgcmVjdGFuZ2xlLmhlaWdodCA+PSBxdWFkQ29ybmVyc1tpXVswXS55KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgPD0gcXVhZENvcm5lcnNbaV1bMl0ueSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGEgbm9uLWF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBjb3JuZXJzICAgICAgQW4gYXJyYXkgY29udGFpbmluZyBlYWNoIGNvcm5lciBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7YXJyYXl9ICBxdWFkQ29ybmVycyAgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkQ29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoX2dlb20uY29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzW2ldKSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogU3ViZGl2aWRlIGEgcXVhZCBieSBjcmVhdGluZyBhIG5vZGUgYXQgYSBwcmVjaXNlIGluZGV4LiBUaGUgZnVuY3Rpb24gZG9lc1xuICAgKiBub3QgZ2VuZXJhdGUgYWxsIGZvdXIgbm9kZXMgbm90IHRvIHBvdGVudGlhbGx5IGNyZWF0ZSB1bnVzZWQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY3JlYXRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgcXVhZCAgVGhlIHF1YWQgb2JqZWN0IHRvIHN1YmRpdmlkZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIEEgbmV3IHF1YWQgcmVwcmVzZW50aW5nIHRoZSBub2RlIGNyZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFN1YmRpdmlkZShpbmRleCwgcXVhZCkge1xuICAgIHZhciBuZXh0ID0gcXVhZC5sZXZlbCArIDEsXG4gICAgICAgIHN1YncgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLndpZHRoIC8gMiksXG4gICAgICAgIHN1YmggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLmhlaWdodCAvIDIpLFxuICAgICAgICBxeCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueCksXG4gICAgICAgIHF5ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy55KSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1YWRUcmVlKFxuICAgICAge3g6IHgsIHk6IHksIHdpZHRoOiBzdWJ3LCBoZWlnaHQ6IHN1Ymh9LFxuICAgICAgbmV4dCxcbiAgICAgIHF1YWQubWF4RWxlbWVudHMsXG4gICAgICBxdWFkLm1heExldmVsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBpbnNlcnQgYW4gZWxlbWVudCBpbnRvIHRoZSBxdWFkdHJlZS4gT25seSBwb2ludHNcbiAgICogd2l0aCBzaXplLCBpLmUuIGF4aXMtYWxpZ25lZCBzcXVhcmVzLCBtYXkgYmUgaW5zZXJ0ZWQgd2l0aCB0aGlzXG4gICAqIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgZWwgICAgICAgICBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHF1YWR0cmVlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzaXplZFBvaW50IEEgc2l6ZWQgcG9pbnQgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICAgICAgIFRoZSBxdWFkIGluIHdoaWNoIHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcblxuICAgICAgLy8gU2VhcmNoaW5nIGFwcHJvcHJpYXRlIHF1YWRzXG4gICAgICB2YXIgaW5kZXhlcyA9IF9xdWFkSW5kZXhlcyhzaXplZFBvaW50LCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICAvLyBJdGVyYXRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBTdWJkaXZpZGluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID0gX3F1YWRTdWJkaXZpZGUoaW5kZXhlc1tpXSwgcXVhZCk7XG5cbiAgICAgICAgLy8gUmVjdXJzaW9uXG4gICAgICAgIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIFB1c2hpbmcgdGhlIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGVcbiAgICAgIHF1YWQuZWxlbWVudHMucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGhlbGQgYnkgdGhlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50IFRoZSBzZWFyY2hlZCBwb2ludCAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIHJlbGV2YW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleCA9IF9xdWFkSW5kZXgocG9pbnQsIHF1YWQuYm91bmRzKTtcblxuICAgICAgLy8gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW4gZW1wdHkgbGlzdFxuICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZC5ub2Rlc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcXVhZC5lbGVtZW50cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiBhbiByZWN0YW5ndWxhciBhcmVhXG4gICAqIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYXhpcy1hbGlnbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R8YXJyYXl9IHJlY3REYXRhICAgICAgIFRoZSBzZWFyY2hlZCBhcmVhIGRlZmluZWQgZWl0aGVyIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgZm91ciBjb3JuZXJzICh4LCB5KSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjYXNlIG9mIGEgbm9uLWF4aXMtYWxpZ25lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBvciBhbiBvYmplY3Qgd2l0aCB0d28gdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIHF1YWQgICAgICAgICAgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIGNvbGxpc2lvbkZ1bmMgIFRoZSBjb2xsaXNpb24gZnVuY3Rpb24gdXNlZCB0byBzZWFyY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igbm9kZSBpbmRleGVzLlxuICAgKiBAcGFyYW0gIHthcnJheT99ICAgICAgIGVscyAgICAgICAgICAgIFRoZSByZXRyaWV2ZWQgZWxlbWVudHMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlQXJlYShyZWN0RGF0YSwgcXVhZCwgY29sbGlzaW9uRnVuYywgZWxzKSB7XG4gICAgZWxzID0gZWxzIHx8IHt9O1xuXG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IGNvbGxpc2lvbkZ1bmMocmVjdERhdGEsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0sXG4gICAgICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICAgICAgZWxzXG4gICAgICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcXVhZC5lbGVtZW50cy5sZW5ndGg7IGogPCBtOyBqKyspXG4gICAgICAgIGlmIChlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPSBxdWFkLmVsZW1lbnRzW2pdO1xuXG4gICAgcmV0dXJuIGVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBxdWFkdHJlZSBvYmplY3QgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgYm91bmRzICAgICAgIFRoZSBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gKHgsIHkpLCB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbGV2ZWwgICAgICAgIFRoZSBsZXZlbCBvZiB0aGUgcXVhZCBpbiB0aGUgdHJlZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heEVsZW1lbnRzICBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIGEgbGVhZiBub2RlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4TGV2ZWwgICAgIFRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFRyZWUoYm91bmRzLCBsZXZlbCwgbWF4RWxlbWVudHMsIG1heExldmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICBjb3JuZXJzOiBfZ2VvbS5zcGxpdFNxdWFyZShib3VuZHMpLFxuICAgICAgbWF4RWxlbWVudHM6IG1heEVsZW1lbnRzIHx8IDIwLFxuICAgICAgbWF4TGV2ZWw6IG1heExldmVsIHx8IDQsXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICBub2RlczogW11cbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogU2lnbWEgUXVhZCBDb25zdHJ1Y3RvclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBxdWFkIEFQSSBhcyBleHBvc2VkIHRvIHNpZ21hLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIHF1YWQgY29yZSB0aGF0IHdpbGwgYmVjb21lIHRoZSBzaWdtYSBpbnRlcmZhY2Ugd2l0aCB0aGUgcXVhZHRyZWUuXG4gICAqXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF90cmVlICBQcm9wZXJ0eSBob2xkaW5nIHRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9nZW9tICBFeHBvc2l0aW9uIG9mIHRoZSBfZ2VvbSBuYW1lc3BhY2UgZm9yIHRlc3RpbmcuXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9jYWNoZSBDYWNoZSBmb3IgdGhlIGFyZWEgbWV0aG9kLlxuICAgKi9cbiAgdmFyIHF1YWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW9tID0gX2dlb207XG4gICAgdGhpcy5fdHJlZSA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW5kZXggYSBncmFwaCBieSBpbnNlcnRpbmcgaXRzIG5vZGVzIGludG8gdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gIG5vZGVzICAgQW4gYXJyYXkgb2Ygbm9kZXMgdG8gaW5kZXguXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICBBbiBvYmplY3Qgb2YgcGFyYW1ldGVycyB3aXRoIGF0IGxlYXN0IHRoZSBxdWFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKiAtLS0tLS0tLS0tXG4gICAqIGJvdW5kczogICAgICB7b2JqZWN0fSAgIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBpdHMgb3JpZ2luICh4LCB5KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBwcmVmaXg6ICAgICAge3N0cmluZz99ICBhIHByZWZpeCBmb3Igbm9kZSBnZW9tZXRyaWMgYXR0cmlidXRlcy5cbiAgICogbWF4RWxlbWVudHM6IHtpbnRlZ2VyP30gdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBsZWFmIG5vZGUuXG4gICAqIG1heExldmVsOiAgICB7aW50ZWdlcj99IHRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKi9cbiAgcXVhZC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihub2RlcywgcGFyYW1zKSB7XG5cbiAgICAvLyBFbmZvcmNpbmcgcHJlc2VuY2Ugb2YgYm91bmRhcmllc1xuICAgIGlmICghcGFyYW1zLmJvdW5kcylcbiAgICAgIHRocm93ICdzaWdtYS5jbGFzc2VzLnF1YWQuaW5kZXg6IGJvdW5kcyBpbmZvcm1hdGlvbiBub3QgZ2l2ZW4uJztcblxuICAgIC8vIFByZWZpeFxuICAgIHZhciBwcmVmaXggPSBwYXJhbXMucHJlZml4IHx8ICcnO1xuXG4gICAgLy8gQnVpbGRpbmcgdGhlIHRyZWVcbiAgICB0aGlzLl90cmVlID0gX3F1YWRUcmVlKFxuICAgICAgcGFyYW1zLmJvdW5kcyxcbiAgICAgIDAsXG4gICAgICBwYXJhbXMubWF4RWxlbWVudHMsXG4gICAgICBwYXJhbXMubWF4TGV2ZWxcbiAgICApO1xuXG4gICAgLy8gSW5zZXJ0aW5nIGdyYXBoIG5vZGVzIGludG8gdGhlIHRyZWVcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAvLyBJbnNlcnRpbmcgbm9kZVxuICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgIG5vZGVzW2ldLFxuICAgICAgICBfZ2VvbS5wb2ludFRvU3F1YXJlKHtcbiAgICAgICAgICB4OiBub2Rlc1tpXVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHk6IG5vZGVzW2ldW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgc2l6ZTogbm9kZXNbaV1bcHJlZml4ICsgJ3NpemUnXVxuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy5fdHJlZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBjYWNoZTpcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcbiAgICAgIHJlc3VsdDogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlP1xuICAgIHJldHVybiB0aGlzLl90cmVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBub2RlcyBoZWxkIGJ5IHRoZSBxdWFkdHJlZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggb2YgdGhlIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgb2YgdGhlIHBvaW50LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIG5vZGVzIHJldHJpZXZlZC5cbiAgICovXG4gIHF1YWQucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVQb2ludCh7eDogeCwgeTogeX0sIHRoaXMuX3RyZWUpIHx8IFtdIDpcbiAgICAgIFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBub2RlcyB3aXRoaW4gYSByZWN0YW5ndWxhciBhcmVhLiBUaGUgbWV0aG9kcyBrZWVwIHRoZVxuICAgKiBsYXN0IGFyZWEgcXVlcmllZCBpbiBjYWNoZSBmb3Igb3B0aW1pemF0aW9uIHJlYXNvbiBhbmQgd2lsbCBhY3QgZGlmZmVyZW50bHlcbiAgICogZm9yIHRoZSBzYW1lIHJlYXNvbiBpZiB0aGUgYXJlYSBpcyBheGlzLWFsaWduZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpXG4gICAqICAgICAgICAgICAgICAgICAgYW5kIGhlaWdodC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBxdWFkLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVjdCksXG4gICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgIHJlY3REYXRhO1xuXG4gICAgLy8gUmV0dXJuaW5nIGNhY2hlP1xuICAgIGlmICh0aGlzLl9jYWNoZS5xdWVyeSA9PT0gc2VyaWFsaXplZClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5yZXN1bHQ7XG5cbiAgICAvLyBBeGlzIGFsaWduZWQgP1xuICAgIGlmIChfZ2VvbS5pc0F4aXNBbGlnbmVkKHJlY3QpKSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRJbmRleGVzO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5heGlzQWxpZ25lZFRvcFBvaW50cyhyZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRDb2xsaXNpb247XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLnJlY3RhbmdsZUNvcm5lcnMocmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmluZyBub2Rlc1xuICAgIHZhciBub2RlcyA9IHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgIHJlY3REYXRhLFxuICAgICAgICB0aGlzLl90cmVlLFxuICAgICAgICBjb2xsaXNpb25GdW5jXG4gICAgICApIDpcbiAgICAgIFtdO1xuXG4gICAgLy8gT2JqZWN0IHRvIGFycmF5XG4gICAgdmFyIG5vZGVzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG5vZGVzKVxuICAgICAgbm9kZXNBcnJheS5wdXNoKG5vZGVzW2ldKTtcblxuICAgIC8vIENhY2hpbmdcbiAgICB0aGlzLl9jYWNoZS5xdWVyeSA9IHNlcmlhbGl6ZWQ7XG4gICAgdGhpcy5fY2FjaGUucmVzdWx0ID0gbm9kZXNBcnJheTtcblxuICAgIHJldHVybiBub2Rlc0FycmF5O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMucXVhZCA9IHF1YWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcXVhZDtcbiAgICBleHBvcnRzLnF1YWQgPSBxdWFkO1xuICB9IGVsc2VcbiAgICB0aGlzLnF1YWQgPSBxdWFkO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkdHJlZSBNb2R1bGUgZm9yIGVkZ2VzXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICpcbiAgICogQXV0aG9yOiBTw6liYXN0aWVuIEhleW1hbm4sXG4gICAqICAgZnJvbSB0aGUgcXVhZCBvZiBHdWlsbGF1bWUgUGxpcXVlIChZb21ndWl0aGVyZWFsKVxuICAgKiBWZXJzaW9uOiAwLjJcbiAgICovXG5cblxuXG4gIC8qKlxuICAgKiBRdWFkIEdlb21ldHJpYyBPcGVyYXRpb25zXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogQSB1c2VmdWwgYmF0Y2ggb2YgZ2VvbWV0cmljIG9wZXJhdGlvbnMgdXNlZCBieSB0aGUgcXVhZHRyZWUuXG4gICAqL1xuXG4gIHZhciBfZ2VvbSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBub2RlIHdpdGggeCwgeSBhbmQgc2l6ZSBpbnRvIGFuXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBncmFwaCBub2RlIHdpdGggYXQgbGVhc3QgYSBwb2ludCAoeCwgeSkgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHBvaW50VG9TcXVhcmU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBuLnggLSBuLnNpemUsXG4gICAgICAgIHkxOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIHgyOiBuLnggKyBuLnNpemUsXG4gICAgICAgIHkyOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIGhlaWdodDogbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIGVkZ2Ugd2l0aCB4MSwgeTEsIHgyLCB5MiBhbmQgc2l6ZSBpbnRvIGFuXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBncmFwaCBlZGdlIHdpdGggYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBsaW5lVG9TcXVhcmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnkxIDwgZS55Mikge1xuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gdG9wXG4gICAgICAgIGlmIChlLngxIDwgZS54Mikge1xuICAgICAgICAgIC8vIChlLngxLCBlLnkxKSBvbiBsZWZ0XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBlLngxIC0gZS5zaXplLFxuICAgICAgICAgICAgeTE6IGUueTEgLSBlLnNpemUsXG4gICAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcbiAgICAgICAgICAgIHkyOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBlLnkyIC0gZS55MSArIGUuc2l6ZSAqIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIChlLngxLCBlLnkxKSBvbiByaWdodFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiBlLngyIC0gZS5zaXplLFxuICAgICAgICAgIHkxOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxuICAgICAgICAgIHkyOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgIGhlaWdodDogZS55MiAtIGUueTEgKyBlLnNpemUgKiAyXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIChlLngyLCBlLnkyKSBvbiB0b3BcbiAgICAgIGlmIChlLngxIDwgZS54Mikge1xuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gbGVmdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiBlLngxIC0gZS5zaXplLFxuICAgICAgICAgIHkxOiBlLnkyIC0gZS5zaXplLFxuICAgICAgICAgIHgyOiBlLngyICsgZS5zaXplLFxuICAgICAgICAgIHkyOiBlLnkyIC0gZS5zaXplLFxuICAgICAgICAgIGhlaWdodDogZS55MSAtIGUueTIgKyBlLnNpemUgKiAyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyAoZS54MiwgZS55Mikgb24gcmlnaHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBlLngyIC0gZS5zaXplLFxuICAgICAgICB5MTogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgeDI6IGUueDEgKyBlLnNpemUsXG4gICAgICAgIHkyOiBlLnkyIC0gZS5zaXplLFxuICAgICAgICBoZWlnaHQ6IGUueTEgLSBlLnkyICsgZS5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIGVkZ2Ugb2YgdHlwZSAnY3VydmUnIHdpdGggeDEsIHkxLCB4MiwgeTIsXG4gICAgICogY29udHJvbCBwb2ludCBhbmQgc2l6ZSBpbnRvIGFuIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGUgIEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgYSBzaXplLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gY3AgQSBjb250cm9sIHBvaW50ICh4LHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgcXVhZHJhdGljQ3VydmVUb1NxdWFyZTogZnVuY3Rpb24oZSwgY3ApIHtcbiAgICAgIHZhciBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZShcbiAgICAgICAgMC41LFxuICAgICAgICBlLngxLFxuICAgICAgICBlLnkxLFxuICAgICAgICBlLngyLFxuICAgICAgICBlLnkyLFxuICAgICAgICBjcC54LFxuICAgICAgICBjcC55XG4gICAgICApO1xuXG4gICAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHR3byBwb2ludHMgYW5kIHRoZSBwb2ludCBhdCB0aGUgbWlkZGxlIG9mIHRoZVxuICAgICAgLy8gY3VydmU6XG4gICAgICB2YXIgbWluWCA9IE1hdGgubWluKGUueDEsIGUueDIsIHB0LngpLFxuICAgICAgICAgIG1heFggPSBNYXRoLm1heChlLngxLCBlLngyLCBwdC54KSxcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4oZS55MSwgZS55MiwgcHQueSksXG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KGUueTEsIGUueTIsIHB0LnkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbWluWCAtIGUuc2l6ZSxcbiAgICAgICAgeTE6IG1pblkgLSBlLnNpemUsXG4gICAgICAgIHgyOiBtYXhYICsgZS5zaXplLFxuICAgICAgICB5MjogbWluWSAtIGUuc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSArIGUuc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBzZWxmIGxvb3AgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBuIEEgZ3JhcGggbm9kZSB3aXRoIGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgIEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHNlbGZMb29wVG9TcXVhcmU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIEZpdHRpbmcgdG8gdGhlIGN1cnZlIGlzIHRvbyBjb3N0bHksIHdlIGNvbXB1dGUgYSBsYXJnZXIgYm91bmRpbmcgYm94XG4gICAgICAvLyB1c2luZyB0aGUgY29udHJvbCBwb2ludHM6XG4gICAgICB2YXIgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMobi54LCBuLnksIG4uc2l6ZSk7XG5cbiAgICAgIC8vIEJvdW5kaW5nIGJveCBvZiB0aGUgcG9pbnQgYW5kIHRoZSB0d28gY29udHJvbCBwb2ludHM6XG4gICAgICB2YXIgbWluWCA9IE1hdGgubWluKG4ueCwgY3AueDEsIGNwLngyKSxcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobi54LCBjcC54MSwgY3AueDIpLFxuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihuLnksIGNwLnkxLCBjcC55MiksXG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG4ueSwgY3AueTEsIGNwLnkyKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG1pblggLSBuLnNpemUsXG4gICAgICAgIHkxOiBtaW5ZIC0gbi5zaXplLFxuICAgICAgICB4MjogbWF4WCArIG4uc2l6ZSxcbiAgICAgICAgeTI6IG1pblkgLSBuLnNpemUsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBuLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKi9cbiAgICBpc0F4aXNBbGlnbmVkOiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gci54MSA9PT0gci54MiB8fCByLnkxID09PSByLnkyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRvcCBwb2ludHMgb2YgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZS4gVGhpcyBpcyB1c2VmdWwgaW5cbiAgICAgKiBjYXNlcyB3aGVuIHRoZSByZWN0YW5nbGUgaGFzIGJlZW4gcm90YXRlZCAobGVmdCwgcmlnaHQgb3IgYm90dG9tIHVwKSBhbmRcbiAgICAgKiBsYXRlciBvcGVyYXRpb25zIG5lZWQgdG8ga25vdyB0aGUgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSByZWN0YW5nbGU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgYXhpc0FsaWduZWRUb3BQb2ludHM6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgLy8gQmFzaWNcbiAgICAgIGlmIChyLnkxID09PSByLnkyICYmIHIueDEgPCByLngyKVxuICAgICAgICByZXR1cm4gcjtcblxuICAgICAgLy8gUm90YXRlZCB0byByaWdodFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA+IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEgLSByLmhlaWdodCwgeTE6IHIueTEsXG4gICAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gUm90YXRlZCB0byBsZWZ0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyIDwgci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSwgeTE6IHIueTIsXG4gICAgICAgICAgeDI6IHIueDIgKyByLmhlaWdodCwgeTI6IHIueTIsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBCb3R0b20ncyB1cFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHIueDIsIHkxOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIHgyOiByLngxLCB5Mjogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciBsZWZ0IGNvcm5lciBmcm9tIGl0cyB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lciAoeCwgeSkuXG4gICAgICovXG4gICAgbG93ZXJMZWZ0Q29vcjogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHdpZHRoID0gKFxuICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgTWF0aC5wb3coci54MiAtIHIueDEsIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhyLnkyIC0gci55MSwgMilcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogci54MSAtIChyLnkyIC0gci55MSkgKiByLmhlaWdodCAvIHdpZHRoLFxuICAgICAgICB5OiByLnkxICsgKHIueDIgLSByLngxKSAqIHIuaGVpZ2h0IC8gd2lkdGhcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIHJpZ2h0IGNvcm5lciBmcm9tIGl0cyB0b3AgcG9pbnRzXG4gICAgICogYW5kIGl0cyBsb3dlciBsZWZ0IGNvcm5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgY29ybmVyJ3MgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lciAoeCwgeSkuXG4gICAgICovXG4gICAgbG93ZXJSaWdodENvb3I6IGZ1bmN0aW9uKHIsIGxsYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbGxjLnggLSByLngxICsgci54MixcbiAgICAgICAgeTogbGxjLnkgLSByLnkxICsgci55MlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiBhbGwgdGhlIGNvcm5lcnMgb2YgYSByZWN0YW5nbGUgZnJvbSBpdHMgdG9wIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2YgdGhlIGZvdXIgY29ybmVycycgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHJlY3RhbmdsZUNvcm5lcnM6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBsbGMgPSB0aGlzLmxvd2VyTGVmdENvb3IociksXG4gICAgICAgICAgbHJjID0gdGhpcy5sb3dlclJpZ2h0Q29vcihyLCBsbGMpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogci54MSwgeTogci55MX0sXG4gICAgICAgIHt4OiByLngyLCB5OiByLnkyfSxcbiAgICAgICAge3g6IGxsYy54LCB5OiBsbGMueX0sXG4gICAgICAgIHt4OiBscmMueCwgeTogbHJjLnl9XG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIHNxdWFyZSBkZWZpbmVkIGJ5IGl0cyBib3VuZGFyaWVzIGludG8gZm91ci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQm91bmRhcmllcyBvZiB0aGUgc3F1YXJlICh4LCB5LCB3aWR0aCwgaGVpZ2h0KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZvdXIgbmV3IHNxdWFyZXMsIHRoZW1zZWx2ZXNcbiAgICAgKiAgICAgICAgICAgICAgICAgIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgdGhlaXIgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKi9cbiAgICBzcGxpdFNxdWFyZTogZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGZvdXIgYXhpcyBiZXR3ZWVuIGNvcm5lcnMgb2YgcmVjdGFuZ2xlIEEgYW5kIGNvcm5lcnMgb2ZcbiAgICAgKiByZWN0YW5nbGUgQi4gVGhpcyBpcyBuZWVkZWQgbGF0ZXIgdG8gY2hlY2sgYW4gZXZlbnR1YWwgY29sbGlzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBBJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEIncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBmb3VyIGF4aXMgZGVmaW5lZCBieSB0aGVpciBjb29yZGluYXRlcyAoeCx5KS5cbiAgICAgKi9cbiAgICBheGlzOiBmdW5jdGlvbihjMSwgYzIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbMF0ueCwgeTogYzFbMV0ueSAtIGMxWzBdLnl9LFxuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzNdLngsIHk6IGMxWzFdLnkgLSBjMVszXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsyXS54LCB5OiBjMlswXS55IC0gYzJbMl0ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMV0ueCwgeTogYzJbMF0ueSAtIGMyWzFdLnl9XG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0IGEgcmVjdGFuZ2xlJ3MgY29ybmVyIG9uIGFuIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgY29ybmVyICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIGFuIGF4aXMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHByb2plY3Rpb24gZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcHJvamVjdGlvbjogZnVuY3Rpb24oYywgYSkge1xuICAgICAgdmFyIGwgPSAoXG4gICAgICAgIChjLnggKiBhLnggKyBjLnkgKiBhLnkpIC9cbiAgICAgICAgKE1hdGgucG93KGEueCwgMikgKyBNYXRoLnBvdyhhLnksIDIpKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbCAqIGEueCxcbiAgICAgICAgeTogbCAqIGEueVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIG9uZSBwYXJ0aWN1bGFyIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgQW4gYXhpcycgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIHRoZSBheGlzLlxuICAgICAqL1xuICAgIGF4aXNDb2xsaXNpb246IGZ1bmN0aW9uKGEsIGMxLCBjMikge1xuICAgICAgdmFyIHNjMSA9IFtdLFxuICAgICAgICAgIHNjMiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgNDsgY2krKykge1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnByb2plY3Rpb24oYzFbY2ldLCBhKSxcbiAgICAgICAgICAgIHAyID0gdGhpcy5wcm9qZWN0aW9uKGMyW2NpXSwgYSk7XG5cbiAgICAgICAgc2MxLnB1c2gocDEueCAqIGEueCArIHAxLnkgKiBhLnkpO1xuICAgICAgICBzYzIucHVzaChwMi54ICogYS54ICsgcDIueSAqIGEueSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhjMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWF4YzIgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzIpLFxuICAgICAgICAgIG1pbmMxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtaW5jMiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMik7XG5cbiAgICAgIHJldHVybiAobWluYzIgPD0gbWF4YzEgJiYgbWF4YzIgPj0gbWluYzEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gZWFjaCBvbmUgb2YgdGhlaXIgZm91ciBheGlzLiBJZlxuICAgICAqIGFsbCBheGlzIGNvbGxpZGUsIHRoZW4gdGhlIHR3byByZWN0YW5nbGVzIGRvIGNvbGxpZGUgb24gdGhlIHBsYW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUuXG4gICAgICovXG4gICAgY29sbGlzaW9uOiBmdW5jdGlvbihjMSwgYzIpIHtcbiAgICAgIHZhciBheGlzID0gdGhpcy5heGlzKGMxLCBjMiksXG4gICAgICAgICAgY29sID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgIGNvbCA9IGNvbCAmJiB0aGlzLmF4aXNDb2xsaXNpb24oYXhpc1tpXSwgYzEsIGMyKTtcblxuICAgICAgcmV0dXJuIGNvbDtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogUXVhZCBGdW5jdGlvbnNcbiAgICogLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBRdWFkdHJlZSBmdW5jdGlvbnMgdGhlbXNlbHZlcy5cbiAgICogRm9yIGVhY2ggb2YgdGhvc2UgZnVuY3Rpb25zLCB3ZSBjb25zaWRlciB0aGF0IGluIGEgc3BsaXR0ZWQgcXVhZCwgdGhlXG4gICAqIGluZGV4IG9mIGVhY2ggbm9kZSBpcyB0aGUgZm9sbG93aW5nOlxuICAgKiAwOiB0b3AgbGVmdFxuICAgKiAxOiB0b3AgcmlnaHRcbiAgICogMjogYm90dG9tIGxlZnRcbiAgICogMzogYm90dG9tIHJpZ2h0XG4gICAqXG4gICAqIE1vcmVvdmVyLCB0aGUgaGVyZWFmdGVyIHF1YWQncyBwaGlsb3NvcGh5IGlzIHRvIGNvbnNpZGVyIHRoYXQgaWYgYW4gZWxlbWVudFxuICAgKiBjb2xsaWRlcyB3aXRoIG1vcmUgdGhhbiBvbmUgbm9kZXMsIHRoaXMgZWxlbWVudCBiZWxvbmdzIHRvIGVhY2ggb2YgdGhlXG4gICAqIG5vZGVzIGl0IGNvbGxpZGVzIHdpdGggd2hlcmUgb3RoZXIgd291bGQgbGV0IGl0IGxpZSBvbiBhIGhpZ2hlciBub2RlLlxuICAgKi9cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludCBpbiB0aGUgcXVhZFxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCAgICAgIEEgcG9pbnQgZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWRCb3VuZHMgQm91bmRhcmllcyBvZiB0aGUgcXVhZCAoeCwgeSwgd2lkdGgsIGhlaWd0aCkuXG4gICAqIEByZXR1cm4ge2ludGVnZXJ9ICAgICAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbmRleChwb2ludCwgcXVhZEJvdW5kcykge1xuICAgIHZhciB4bXAgPSBxdWFkQm91bmRzLnggKyBxdWFkQm91bmRzLndpZHRoIC8gMixcbiAgICAgICAgeW1wID0gcXVhZEJvdW5kcy55ICsgcXVhZEJvdW5kcy5oZWlnaHQgLyAyLFxuICAgICAgICB0b3AgPSAocG9pbnQueSA8IHltcCksXG4gICAgICAgIGxlZnQgPSAocG9pbnQueCA8IHhtcCk7XG5cbiAgICBpZiAodG9wKSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcmVjdGFuZ2xlICAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBxdWFkQ29ybmVycyBBbiBhcnJheSBvZiB0aGUgcXVhZCBub2RlcycgY29ybmVycy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5kZXhlcyBjb250YWluaW5nIG9uZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbmRleGVzKHJlY3RhbmdsZSwgcXVhZENvcm5lcnMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0aW5nIHRocm91Z2ggcXVhZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGlmICgocmVjdGFuZ2xlLngyID49IHF1YWRDb3JuZXJzW2ldWzBdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS54MSA8PSBxdWFkQ29ybmVyc1tpXVsxXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgKyByZWN0YW5nbGUuaGVpZ2h0ID49IHF1YWRDb3JuZXJzW2ldWzBdLnkpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSA8PSBxdWFkQ29ybmVyc1tpXVsyXS55KSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYSBub24tYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gIGNvcm5lcnMgICAgICBBbiBhcnJheSBjb250YWluaW5nIGVhY2ggY29ybmVyIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgZGVmaW5lZCBieSBpdHMgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHthcnJheX0gIHF1YWRDb3JuZXJzICBBbiBhcnJheSBvZiB0aGUgcXVhZCBub2RlcycgY29ybmVycy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5kZXhlcyBjb250YWluaW5nIG9uZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRDb2xsaXNpb24oY29ybmVycywgcXVhZENvcm5lcnMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0aW5nIHRocm91Z2ggcXVhZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGlmIChfZ2VvbS5jb2xsaXNpb24oY29ybmVycywgcXVhZENvcm5lcnNbaV0pKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJkaXZpZGUgYSBxdWFkIGJ5IGNyZWF0aW5nIGEgbm9kZSBhdCBhIHByZWNpc2UgaW5kZXguIFRoZSBmdW5jdGlvbiBkb2VzXG4gICAqIG5vdCBnZW5lcmF0ZSBhbGwgZm91ciBub2RlcyBub3QgdG8gcG90ZW50aWFsbHkgY3JlYXRlIHVudXNlZCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBxdWFkICBUaGUgcXVhZCBvYmplY3QgdG8gc3ViZGl2aWRlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgQSBuZXcgcXVhZCByZXByZXNlbnRpbmcgdGhlIG5vZGUgY3JlYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkU3ViZGl2aWRlKGluZGV4LCBxdWFkKSB7XG4gICAgdmFyIG5leHQgPSBxdWFkLmxldmVsICsgMSxcbiAgICAgICAgc3VidyA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMud2lkdGggLyAyKSxcbiAgICAgICAgc3ViaCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMuaGVpZ2h0IC8gMiksXG4gICAgICAgIHF4ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy54KSxcbiAgICAgICAgcXkgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLnkpLFxuICAgICAgICB4LFxuICAgICAgICB5O1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHggPSBxeCArIHN1Ync7XG4gICAgICAgIHkgPSBxeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHggPSBxeCArIHN1Ync7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVhZFRyZWUoXG4gICAgICB7eDogeCwgeTogeSwgd2lkdGg6IHN1YncsIGhlaWdodDogc3ViaH0sXG4gICAgICBuZXh0LFxuICAgICAgcXVhZC5tYXhFbGVtZW50cyxcbiAgICAgIHF1YWQubWF4TGV2ZWxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGluc2VydCBhbiBlbGVtZW50IGludG8gdGhlIHF1YWR0cmVlLiBPbmx5IHBvaW50c1xuICAgKiB3aXRoIHNpemUsIGkuZS4gYXhpcy1hbGlnbmVkIHNxdWFyZXMsIG1heSBiZSBpbnNlcnRlZCB3aXRoIHRoaXNcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBlbCAgICAgICAgIFRoZSBlbGVtZW50IHRvIGluc2VydCBpbiB0aGUgcXVhZHRyZWUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHNpemVkUG9pbnQgQSBzaXplZCBwb2ludCBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgICAgICAgVGhlIHF1YWQgaW4gd2hpY2ggdG8gaW5zZXJ0IHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgICAgIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZCkge1xuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuXG4gICAgICAvLyBTZWFyY2hpbmcgYXBwcm9wcmlhdGUgcXVhZHNcbiAgICAgIHZhciBpbmRleGVzID0gX3F1YWRJbmRleGVzKHNpemVkUG9pbnQsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgIC8vIFN1YmRpdmlkaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPSBfcXVhZFN1YmRpdmlkZShpbmRleGVzW2ldLCBxdWFkKTtcblxuICAgICAgICAvLyBSZWN1cnNpb25cbiAgICAgICAgX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgLy8gUHVzaGluZyB0aGUgZWxlbWVudCBpbiBhIGxlYWYgbm9kZVxuICAgICAgcXVhZC5lbGVtZW50cy5wdXNoKGVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgaGVsZCBieSB0aGUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgVGhlIHNlYXJjaGVkIHBvaW50ICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgVGhlIHNlYXJjaGVkIHF1YWQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgcmVsZXZhbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZCkge1xuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ID0gX3F1YWRJbmRleChwb2ludCwgcXVhZC5ib3VuZHMpO1xuXG4gICAgICAvLyBJZiBub2RlIGRvZXMgbm90IGV4aXN0IHdlIHJldHVybiBhbiBlbXB0eSBsaXN0XG4gICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkLm5vZGVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBxdWFkLmVsZW1lbnRzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBjb250YWluZWQgd2l0aGluIGFuIHJlY3Rhbmd1bGFyIGFyZWFcbiAgICogdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBheGlzLWFsaWduZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdHxhcnJheX0gcmVjdERhdGEgICAgICAgVGhlIHNlYXJjaGVkIGFyZWEgZGVmaW5lZCBlaXRoZXIgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvZiBmb3VyIGNvcm5lcnMgKHgsIHkpIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNhc2Ugb2YgYSBub24tYXhpcy1hbGlnbmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIG9yIGFuIG9iamVjdCB3aXRoIHR3byB0b3BcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgcXVhZCAgICAgICAgICAgVGhlIHNlYXJjaGVkIHF1YWQuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICAgY29sbGlzaW9uRnVuYyAgVGhlIGNvbGxpc2lvbiBmdW5jdGlvbiB1c2VkIHRvIHNlYXJjaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBub2RlIGluZGV4ZXMuXG4gICAqIEBwYXJhbSAge2FycmF5P30gICAgICAgZWxzICAgICAgICAgICAgVGhlIHJldHJpZXZlZCBlbGVtZW50cy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYS5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkUmV0cmlldmVBcmVhKHJlY3REYXRhLCBxdWFkLCBjb2xsaXNpb25GdW5jLCBlbHMpIHtcbiAgICBlbHMgPSBlbHMgfHwge307XG5cbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleGVzID0gY29sbGlzaW9uRnVuYyhyZWN0RGF0YSwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICBfcXVhZFJldHJpZXZlQXJlYShcbiAgICAgICAgICAgIHJlY3REYXRhLFxuICAgICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgICAgICBlbHNcbiAgICAgICAgICApO1xuICAgIH0gZWxzZVxuICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBxdWFkLmVsZW1lbnRzLmxlbmd0aDsgaiA8IG07IGorKylcbiAgICAgICAgaWYgKGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9IHF1YWQuZWxlbWVudHNbal07XG5cbiAgICByZXR1cm4gZWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHF1YWR0cmVlIG9iamVjdCBpdHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBib3VuZHMgICAgICAgVGhlIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiAoeCwgeSksIHdpZHRoIGFuZCBoZWlndGguXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBsZXZlbCAgICAgICAgVGhlIGxldmVsIG9mIHRoZSBxdWFkIGluIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4RWxlbWVudHMgIFRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhMZXZlbCAgICAgVGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkVHJlZShib3VuZHMsIGxldmVsLCBtYXhFbGVtZW50cywgbWF4TGV2ZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IGxldmVsIHx8IDAsXG4gICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgIGNvcm5lcnM6IF9nZW9tLnNwbGl0U3F1YXJlKGJvdW5kcyksXG4gICAgICBtYXhFbGVtZW50czogbWF4RWxlbWVudHMgfHwgNDAsXG4gICAgICBtYXhMZXZlbDogbWF4TGV2ZWwgfHwgOCxcbiAgICAgIGVsZW1lbnRzOiBbXSxcbiAgICAgIG5vZGVzOiBbXVxuICAgIH07XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkIENvbnN0cnVjdG9yXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIGVkZ2VxdWFkIEFQSSBhcyBleHBvc2VkIHRvIHNpZ21hLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGVkZ2VxdWFkIGNvcmUgdGhhdCB3aWxsIGJlY29tZSB0aGUgc2lnbWEgaW50ZXJmYWNlIHdpdGggdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfdHJlZSAgICAgUHJvcGVydHkgaG9sZGluZyB0aGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfZ2VvbSAgICAgRXhwb3NpdGlvbiBvZiB0aGUgX2dlb20gbmFtZXNwYWNlIGZvciB0ZXN0aW5nLlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfY2FjaGUgICAgQ2FjaGUgZm9yIHRoZSBhcmVhIG1ldGhvZC5cbiAgICogcHJvcGVydHkge2Jvb2xlYW59IF9lbmFibGVkIENhbiBpbmRleCBhbmQgcmV0cmVpdmUgZWxlbWVudHMuXG4gICAqL1xuICB2YXIgZWRnZXF1YWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW9tID0gX2dlb207XG4gICAgdGhpcy5fdHJlZSA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSW5kZXggYSBncmFwaCBieSBpbnNlcnRpbmcgaXRzIGVkZ2VzIGludG8gdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGdyYXBoICAgQSBncmFwaCBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXJzIHdpdGggYXQgbGVhc3QgdGhlIHF1YWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqXG4gICAqIFBhcmFtZXRlcnM6XG4gICAqIC0tLS0tLS0tLS1cbiAgICogYm91bmRzOiAgICAgIHtvYmplY3R9ICAgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGl0cyBvcmlnaW4gKHgsIHkpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIGFuZCBoZWlndGguXG4gICAqIHByZWZpeDogICAgICB7c3RyaW5nP30gIGEgcHJlZml4IGZvciBlZGdlIGdlb21ldHJpYyBhdHRyaWJ1dGVzLlxuICAgKiBtYXhFbGVtZW50czoge2ludGVnZXI/fSB0aGUgbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiBhIGxlYWYgbm9kZS5cbiAgICogbWF4TGV2ZWw6ICAgIHtpbnRlZ2VyP30gdGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAqL1xuICBlZGdlcXVhZC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihncmFwaCwgcGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG5cbiAgICAvLyBFbmZvcmNpbmcgcHJlc2VuY2Ugb2YgYm91bmRhcmllc1xuICAgIGlmICghcGFyYW1zLmJvdW5kcylcbiAgICAgIHRocm93ICdzaWdtYS5jbGFzc2VzLmVkZ2VxdWFkLmluZGV4OiBib3VuZHMgaW5mb3JtYXRpb24gbm90IGdpdmVuLic7XG5cbiAgICAvLyBQcmVmaXhcbiAgICB2YXIgcHJlZml4ID0gcGFyYW1zLnByZWZpeCB8fCAnJyxcbiAgICAgICAgY3AsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBuLFxuICAgICAgICBlO1xuXG4gICAgLy8gQnVpbGRpbmcgdGhlIHRyZWVcbiAgICB0aGlzLl90cmVlID0gX3F1YWRUcmVlKFxuICAgICAgcGFyYW1zLmJvdW5kcyxcbiAgICAgIDAsXG4gICAgICBwYXJhbXMubWF4RWxlbWVudHMsXG4gICAgICBwYXJhbXMubWF4TGV2ZWxcbiAgICApO1xuXG4gICAgdmFyIGVkZ2VzID0gZ3JhcGguZWRnZXMoKTtcblxuICAgIC8vIEluc2VydGluZyBncmFwaCBlZGdlcyBpbnRvIHRoZSB0cmVlXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGdyYXBoLm5vZGVzKGVkZ2VzW2ldLnNvdXJjZSk7XG4gICAgICB0YXJnZXQgPSBncmFwaC5ub2RlcyhlZGdlc1tpXS50YXJnZXQpO1xuICAgICAgZSA9IHtcbiAgICAgICAgeDE6IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICB5MTogc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHgyOiB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgeTI6IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBzaXplOiBlZGdlc1tpXVtwcmVmaXggKyAnc2l6ZSddIHx8IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIEluc2VydGluZyBlZGdlXG4gICAgICBpZiAoZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlJyB8fCBlZGdlc1tpXS50eXBlID09PSAnY3VydmVkQXJyb3cnKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgICAgIG4gPSB7XG4gICAgICAgICAgICB4OiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgIHk6IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgc2l6ZTogc291cmNlW3ByZWZpeCArICdzaXplJ10gfHwgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICAgIF9nZW9tLnNlbGZMb29wVG9TcXVhcmUobiksXG4gICAgICAgICAgICB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChlLngxLCBlLnkxLCBlLngyLCBlLnkyKTtcbiAgICAgICAgICBfcXVhZEluc2VydChcbiAgICAgICAgICAgIGVkZ2VzW2ldLFxuICAgICAgICAgICAgX2dlb20ucXVhZHJhdGljQ3VydmVUb1NxdWFyZShlLCBjcCksXG4gICAgICAgICAgICB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICAgIGVkZ2VzW2ldLFxuICAgICAgICAgIF9nZW9tLmxpbmVUb1NxdWFyZShlKSxcbiAgICAgICAgICB0aGlzLl90cmVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNldCBjYWNoZTpcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcbiAgICAgIHJlc3VsdDogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlP1xuICAgIHJldHVybiB0aGlzLl90cmVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBlZGdlcyBoZWxkIGJ5IHRoZSBxdWFkdHJlZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggb2YgdGhlIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgb2YgdGhlIHBvaW50LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIGVkZ2VzIHJldHJpZXZlZC5cbiAgICovXG4gIGVkZ2VxdWFkLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpXG4gICAgICByZXR1cm4gW107XG5cbiAgICByZXR1cm4gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlUG9pbnQoe3g6IHgsIHk6IHl9LCB0aGlzLl90cmVlKSB8fCBbXSA6XG4gICAgICBbXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggZWRnZXMgd2l0aGluIGEgcmVjdGFuZ3VsYXIgYXJlYS4gVGhlIG1ldGhvZHMga2VlcCB0aGVcbiAgICogbGFzdCBhcmVhIHF1ZXJpZWQgaW4gY2FjaGUgZm9yIG9wdGltaXphdGlvbiByZWFzb24gYW5kIHdpbGwgYWN0IGRpZmZlcmVudGx5XG4gICAqIGZvciB0aGUgc2FtZSByZWFzb24gaWYgdGhlIGFyZWEgaXMgYXhpcy1hbGlnbmVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKVxuICAgKiAgICAgICAgICAgICAgICAgIGFuZCBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2YgZWRnZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgZWRnZXF1YWQucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShyZWN0KSxcbiAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgcmVjdERhdGE7XG5cbiAgICAvLyBSZXR1cm5pbmcgY2FjaGU/XG4gICAgaWYgKHRoaXMuX2NhY2hlLnF1ZXJ5ID09PSBzZXJpYWxpemVkKVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLnJlc3VsdDtcblxuICAgIC8vIEF4aXMgYWxpZ25lZCA/XG4gICAgaWYgKF9nZW9tLmlzQXhpc0FsaWduZWQocmVjdCkpIHtcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZEluZGV4ZXM7XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLmF4aXNBbGlnbmVkVG9wUG9pbnRzKHJlY3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZENvbGxpc2lvbjtcbiAgICAgIHJlY3REYXRhID0gX2dlb20ucmVjdGFuZ2xlQ29ybmVycyhyZWN0KTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2aW5nIGVkZ2VzXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlQXJlYShcbiAgICAgICAgcmVjdERhdGEsXG4gICAgICAgIHRoaXMuX3RyZWUsXG4gICAgICAgIGNvbGxpc2lvbkZ1bmNcbiAgICAgICkgOlxuICAgICAgW107XG5cbiAgICAvLyBPYmplY3QgdG8gYXJyYXlcbiAgICB2YXIgZWRnZXNBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gZWRnZXMpXG4gICAgICBlZGdlc0FycmF5LnB1c2goZWRnZXNbaV0pO1xuXG4gICAgLy8gQ2FjaGluZ1xuICAgIHRoaXMuX2NhY2hlLnF1ZXJ5ID0gc2VyaWFsaXplZDtcbiAgICB0aGlzLl9jYWNoZS5yZXN1bHQgPSBlZGdlc0FycmF5O1xuXG4gICAgcmV0dXJuIGVkZ2VzQXJyYXk7XG4gIH07XG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xuICAgIHRoaXMuc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCA9IGVkZ2VxdWFkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVkZ2VxdWFkO1xuICAgIGV4cG9ydHMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbiAgfSBlbHNlXG4gICAgdGhpcy5lZGdlcXVhZCA9IGVkZ2VxdWFkO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FwdG9ycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgdXNlciBpbnB1dHMgZGVmYXVsdCBjYXB0b3IuIEl0IGRlYWxzIHdpdGggbW91c2UgZXZlbnRzLCBrZXlib2FyZHNcbiAgICogZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgdGFyZ2V0ICAgVGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kLlxuICAgKiBAcGFyYW0gIHtjYW1lcmF9ICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEgcmVsYXRlZCB0byB0aGUgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7c2lnbWEuY2FwdG9yfSAgICAgICAgICBUaGUgZnJlc2ggbmV3IGNhcHRvciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLmNhcHRvcnMubW91c2UgPSBmdW5jdGlvbih0YXJnZXQsIGNhbWVyYSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfdGFyZ2V0ID0gdGFyZ2V0LFxuICAgICAgICBfY2FtZXJhID0gY2FtZXJhLFxuICAgICAgICBfc2V0dGluZ3MgPSBzZXR0aW5ncyxcblxuICAgICAgICAvLyBDQU1FUkEgTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFRoZSBjYW1lcmEgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydENhbWVyYVgsXG4gICAgICAgIF9zdGFydENhbWVyYVksXG4gICAgICAgIF9zdGFydENhbWVyYUFuZ2xlLFxuXG4gICAgICAgIC8vIFRoZSBsYXRlc3Qgc3RhZ2UgcG9zaXRpb246XG4gICAgICAgIF9sYXN0Q2FtZXJhWCxcbiAgICAgICAgX2xhc3RDYW1lcmFZLFxuICAgICAgICBfbGFzdENhbWVyYUFuZ2xlLFxuICAgICAgICBfbGFzdENhbWVyYVJhdGlvLFxuXG4gICAgICAgIC8vIE1PVVNFIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZzpcbiAgICAgICAgX3N0YXJ0TW91c2VYLFxuICAgICAgICBfc3RhcnRNb3VzZVksXG5cbiAgICAgICAgX2lzTW91c2VEb3duLFxuICAgICAgICBfaXNNb3ZpbmcsXG4gICAgICAgIF9oYXNEcmFnZ2VkLFxuICAgICAgICBfZG93blN0YXJ0VGltZSxcbiAgICAgICAgX21vdmluZ1RpbWVvdXRJZDtcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhfdGFyZ2V0LCAnY2xpY2snLCBfZG91YmxlQ2xpY2tIYW5kbGVyKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgX3doZWVsSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIF93aGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9tb3ZlSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Rvd25IYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF9jbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgX291dEhhbmRsZXIsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3VwSGFuZGxlciwgZmFsc2UpO1xuXG5cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdW5iaW5kcyBldmVyeSBoYW5kbGVycyB0aGF0IG1ha2VzIHRoZSBjYXB0b3Igd29yay5cbiAgICAgKi9cbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrKF90YXJnZXQsICdjbGljaycpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIF93aGVlbEhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgX3doZWVsSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9tb3ZlSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9kb3duSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2NsaWNrSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgX291dEhhbmRsZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF91cEhhbmRsZXIpO1xuICAgIH07XG5cblxuXG5cbiAgICAvLyBNT1VTRSBFVkVOVFM6XG4gICAgLy8gKioqKioqKioqKioqKlxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnbW92ZScgbW91c2UgZXZlbnQuIEl0IHdpbGwgZWZmZWN0aXZlbHlcbiAgICAgKiBkcmFnIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbW92ZUhhbmRsZXIoZSkge1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBwb3M7XG5cbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50OlxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vtb3ZlJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XG5cbiAgICAgICAgaWYgKF9pc01vdXNlRG93bikge1xuICAgICAgICAgIF9pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgX2hhc0RyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG5cbiAgICAgICAgICBfbW92aW5nVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgIH0sIF9zZXR0aW5ncygnZHJhZ1RpbWVvdXQnKSk7XG5cbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKF9jYW1lcmEpO1xuXG4gICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgcG9zID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFgoZSkgLSBfc3RhcnRNb3VzZVgsXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRZKGUpIC0gX3N0YXJ0TW91c2VZLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB4ID0gX3N0YXJ0Q2FtZXJhWCAtIHBvcy54O1xuICAgICAgICAgIHkgPSBfc3RhcnRDYW1lcmFZIC0gcG9zLnk7XG5cbiAgICAgICAgICBpZiAoeCAhPT0gX2NhbWVyYS54IHx8IHkgIT09IF9jYW1lcmEueSkge1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3VwJyBtb3VzZSBldmVudC4gSXQgd2lsbCBzdG9wIGRyYWdnaW5nIHRoZVxuICAgICAqIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF91cEhhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykgJiYgX2lzTW91c2VEb3duKSB7XG4gICAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZClcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG5cbiAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHZhciB4ID0gc2lnbWEudXRpbHMuZ2V0WChlKSxcbiAgICAgICAgICAgIHkgPSBzaWdtYS51dGlscy5nZXRZKGUpO1xuXG4gICAgICAgIGlmIChfaXNNb3ZpbmcpIHtcbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKF9jYW1lcmEpO1xuICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcbiAgICAgICAgICAgIF9jYW1lcmEsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXG4gICAgICAgICAgICAgICAgX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFSYXRpbycpICogKF9jYW1lcmEueCAtIF9sYXN0Q2FtZXJhWCksXG4gICAgICAgICAgICAgIHk6IF9jYW1lcmEueSArXG4gICAgICAgICAgICAgICAgX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFSYXRpbycpICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlSW5lcnRpYUR1cmF0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIF9zdGFydE1vdXNlWCAhPT0geCB8fFxuICAgICAgICAgIF9zdGFydE1vdXNlWSAhPT0geVxuICAgICAgICApXG4gICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgIHg6IF9jYW1lcmEueCxcbiAgICAgICAgICAgIHk6IF9jYW1lcmEueVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNldXAnLFxuICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpKTtcblxuICAgICAgICAvLyBVcGRhdGUgX2lzTW92aW5nIGZsYWc6XG4gICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ2Rvd24nIG1vdXNlIGV2ZW50LiBJdCB3aWxsIHN0YXJ0IG9ic2VydmluZ1xuICAgICAqIHRoZSBtb3VzZSBwb3NpdGlvbiBmb3IgZHJhZ2dpbmcgdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9kb3duSGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xuICAgICAgICBfc3RhcnRDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgIF9zdGFydE1vdXNlWCA9IHNpZ21hLnV0aWxzLmdldFgoZSk7XG4gICAgICAgIF9zdGFydE1vdXNlWSA9IHNpZ21hLnV0aWxzLmdldFkoZSk7XG5cbiAgICAgICAgX2hhc0RyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgX2Rvd25TdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIE1pZGRsZSBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIC8vIFJpZ2h0IG1vdXNlIGJ1dHRvbiBwcmVzc2VkXG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodGNsaWNrJyxcbiAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIGNhc2UgMTpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTGVmdCBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgX2lzTW91c2VEb3duID0gdHJ1ZTtcblxuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ291dCcgbW91c2UgZXZlbnQuIEl0IHdpbGwganVzdCByZWRpc3BhdGNoXG4gICAgICogdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9vdXRIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKVxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW91dCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ2NsaWNrJyBtb3VzZSBldmVudC4gSXQgd2lsbCByZWRpc3BhdGNoIHRoZVxuICAgICAqIGNsaWNrIGV2ZW50LCBidXQgd2l0aCBub3JtYWxpemVkIFggYW5kIFkgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2NsaWNrSGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKTtcbiAgICAgICAgZXZlbnQuaXNEcmFnZ2luZyA9XG4gICAgICAgICAgKCgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gX2Rvd25TdGFydFRpbWUpID4gMTAwKSAmJiBfaGFzRHJhZ2dlZDtcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlbHNlXG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlIGRvdWJsZSBjbGljayBjdXN0b20gZXZlbnQuIEl0IHdpbGxcbiAgICAgKiBiYXNpY2FsbHkgem9vbSBpbnRvIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG91YmxlQ2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBwb3MsXG4gICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgYW5pbWF0aW9uO1xuXG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xuICAgICAgICByYXRpbyA9IDEgLyBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbWluZ1JhdGlvJyk7XG5cbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlY2xpY2snLFxuICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcblxuICAgICAgICBpZiAoX3NldHRpbmdzKCdkb3VibGVDbGlja0VuYWJsZWQnKSkge1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRZKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbUR1cmF0aW9uJylcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2lnbWEudXRpbHMuem9vbVRvKF9jYW1lcmEsIHBvcy54LCBwb3MueSwgcmF0aW8sIGFuaW1hdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3doZWVsJyBtb3VzZSBldmVudC4gSXQgd2lsbCBiYXNpY2FsbHkgem9vbVxuICAgICAqIGluIG9yIG5vdCBpbnRvIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfd2hlZWxIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBwb3MsXG4gICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgIHdoZWVsRGVsdGEgPSBzaWdtYS51dGlscy5nZXREZWx0YShlKTtcblxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykgJiYgX3NldHRpbmdzKCdtb3VzZVdoZWVsRW5hYmxlZCcpICYmIHdoZWVsRGVsdGEgIT09IDApIHtcbiAgICAgICAgcmF0aW8gPSB3aGVlbERlbHRhID4gMCA/XG4gICAgICAgICAgMSAvIF9zZXR0aW5ncygnem9vbWluZ1JhdGlvJykgOlxuICAgICAgICAgIF9zZXR0aW5ncygnem9vbWluZ1JhdGlvJyk7XG5cbiAgICAgICAgcG9zID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICBhbmltYXRpb24gPSB7XG4gICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnbW91c2Vab29tRHVyYXRpb24nKVxuICAgICAgICB9O1xuXG4gICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FwdG9ycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgdXNlciBpbnB1dHMgZGVmYXVsdCBjYXB0b3IuIEl0IGRlYWxzIHdpdGggbW91c2UgZXZlbnRzLCBrZXlib2FyZHNcbiAgICogZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgdGFyZ2V0ICAgVGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kLlxuICAgKiBAcGFyYW0gIHtjYW1lcmF9ICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEgcmVsYXRlZCB0byB0aGUgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7c2lnbWEuY2FwdG9yfSAgICAgICAgICBUaGUgZnJlc2ggbmV3IGNhcHRvciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLmNhcHRvcnMudG91Y2ggPSBmdW5jdGlvbih0YXJnZXQsIGNhbWVyYSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfdGFyZ2V0ID0gdGFyZ2V0LFxuICAgICAgICBfY2FtZXJhID0gY2FtZXJhLFxuICAgICAgICBfc2V0dGluZ3MgPSBzZXR0aW5ncyxcblxuICAgICAgICAvLyBDQU1FUkEgTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFRoZSBjYW1lcmEgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydENhbWVyYVgsXG4gICAgICAgIF9zdGFydENhbWVyYVksXG4gICAgICAgIF9zdGFydENhbWVyYUFuZ2xlLFxuICAgICAgICBfc3RhcnRDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBUaGUgbGF0ZXN0IHN0YWdlIHBvc2l0aW9uOlxuICAgICAgICBfbGFzdENhbWVyYVgsXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcbiAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSxcbiAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBUT1VDSCBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUb3VjaGVzIHRoYXQgYXJlIGRvd246XG4gICAgICAgIF9kb3duVG91Y2hlcyA9IFtdLFxuXG4gICAgICAgIF9zdGFydFRvdWNoWDAsXG4gICAgICAgIF9zdGFydFRvdWNoWTAsXG4gICAgICAgIF9zdGFydFRvdWNoWDEsXG4gICAgICAgIF9zdGFydFRvdWNoWTEsXG4gICAgICAgIF9zdGFydFRvdWNoQW5nbGUsXG4gICAgICAgIF9zdGFydFRvdWNoRGlzdGFuY2UsXG5cbiAgICAgICAgX3RvdWNoTW9kZSxcblxuICAgICAgICBfaXNNb3ZpbmcsXG4gICAgICAgIF9kb3VibGVUYXAsXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnLCBfZG91YmxlVGFwSGFuZGxlcik7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX2hhbmRsZVN0YXJ0LCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF9oYW5kbGVMZWF2ZSwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9oYW5kbGVNb3ZlLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbihlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2lnbWEudXRpbHMuZ2V0T2Zmc2V0KF90YXJnZXQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQsXG4gICAgICAgIHk6IGUucGFnZVkgLSBvZmZzZXQudG9wXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVuYmluZHMgZXZlcnkgaGFuZGxlcnMgdGhhdCBtYWtlcyB0aGUgY2FwdG9yIHdvcmsuXG4gICAgICovXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayhfdGFyZ2V0LCAndG91Y2hzdGFydCcpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX2hhbmRsZVN0YXJ0KTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF9oYW5kbGVMZWF2ZSk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSk7XG4gICAgfTtcblxuICAgIC8vIFRPVUNIIEVWRU5UUzpcbiAgICAvLyAqKioqKioqKioqKioqXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2hzdGFydCcgZXZlbnQuIEl0IHdpbGwgc2V0IHRoZSB0b3VjaFxuICAgICAqIG1vZGUgKFwiX3RvdWNoTW9kZVwiKSBhbmQgc3RhcnQgb2JzZXJ2aW5nIHRoZSB1c2VyIHRvdWNoIG1vdmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9oYW5kbGVTdGFydChlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xuICAgICAgICB2YXIgeDAsXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkwLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBwb3MwLFxuICAgICAgICAgICAgcG9zMTtcblxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG5cbiAgICAgICAgc3dpdGNoIChfZG93blRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgICBfdG91Y2hNb2RlID0gMTtcblxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgwID0gcG9zMC54O1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMCA9IHBvczAueTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgICBfdG91Y2hNb2RlID0gMjtcblxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBwb3MxID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XG4gICAgICAgICAgICB4MSA9IHBvczEueDtcbiAgICAgICAgICAgIHkxID0gcG9zMS55O1xuXG4gICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYUFuZ2xlID0gX2NhbWVyYS5hbmdsZTtcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVJhdGlvID0gX2NhbWVyYS5yYXRpbztcblxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIF9zdGFydFRvdWNoWDAgPSB4MDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSB5MDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWDEgPSB4MTtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTEgPSB5MTtcblxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hBbmdsZSA9IE1hdGguYXRhbjIoXG4gICAgICAgICAgICAgIF9zdGFydFRvdWNoWTEgLSBfc3RhcnRUb3VjaFkwLFxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFgxIC0gX3N0YXJ0VG91Y2hYMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoRGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCkgKlxuICAgICAgICAgICAgICAgIChfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCkgK1xuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDApICpcbiAgICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcgYW5kICd0b3VjaGxlYXZlJ1xuICAgICAqIGV2ZW50LiBJdCB3aWxsIHVwZGF0ZSB0aGUgdG91Y2ggbW9kZSBpZiB0aGVyZSBhcmUgc3RpbGwgYXQgbGVhc3Qgb25lXG4gICAgICogZmluZ2VyLCBhbmQgc3RvcCBkcmFnZ2luZyBlbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9oYW5kbGVMZWF2ZShlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIHZhciBpbmVydGlhUmF0aW8gPSBfc2V0dGluZ3MoJ3RvdWNoSW5lcnRpYVJhdGlvJyk7XG5cbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpIHtcbiAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKF90b3VjaE1vZGUpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBfaGFuZGxlU3RhcnQoZSk7XG5cbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdzdG9wRHJhZycpO1xuXG4gICAgICAgICAgICBpZiAoX2lzTW92aW5nKSB7XG4gICAgICAgICAgICAgIF9kb3VibGVUYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24uY2FtZXJhKFxuICAgICAgICAgICAgICAgIF9jYW1lcmEsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgeDogX2NhbWVyYS54ICtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueCAtIF9sYXN0Q2FtZXJhWCksXG4gICAgICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xuICAgICAgICAgICAgICAgICAgICBpbmVydGlhUmF0aW8gKiAoX2NhbWVyYS55IC0gX2xhc3RDYW1lcmFZKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWFzaW5nOiAncXVhZHJhdGljT3V0JyxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ3RvdWNoSW5lcnRpYUR1cmF0aW9uJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNobW92ZScgZXZlbnQuIEl0IHdpbGwgZWZmZWN0aXZlbHkgZHJhZ1xuICAgICAqIHRoZSBncmFwaCwgYW5kIGV2ZW50dWFsbHkgem9vbXMgYW5kIHR1cm4gaXQgaWYgdGhlIHVzZXIgaXMgdXNpbmcgdHdvXG4gICAgICogZmluZ2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlTW92ZShlKSB7XG4gICAgICBpZiAoIV9kb3VibGVUYXAgJiYgX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xuICAgICAgICB2YXIgeDAsXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkwLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjb3MsXG4gICAgICAgICAgICBzaW4sXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBwb3MwLFxuICAgICAgICAgICAgcG9zMSxcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGRBbmdsZSxcbiAgICAgICAgICAgIGRSYXRpbyxcbiAgICAgICAgICAgIG5ld1N0YWdlWCxcbiAgICAgICAgICAgIG5ld1N0YWdlWSxcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8sXG4gICAgICAgICAgICBuZXdTdGFnZUFuZ2xlO1xuXG4gICAgICAgIF9kb3duVG91Y2hlcyA9IGUudG91Y2hlcztcbiAgICAgICAgX2lzTW92aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZClcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG5cbiAgICAgICAgX21vdmluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgIH0sIF9zZXR0aW5ncygnZHJhZ1RpbWVvdXQnKSk7XG5cbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICB4MCA9IHBvczAueDtcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xuXG4gICAgICAgICAgICBkaWZmID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgeDAgLSBfc3RhcnRUb3VjaFgwLFxuICAgICAgICAgICAgICB5MCAtIF9zdGFydFRvdWNoWTAsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG5ld1N0YWdlWCA9IF9zdGFydENhbWVyYVggLSBkaWZmLng7XG4gICAgICAgICAgICBuZXdTdGFnZVkgPSBfc3RhcnRDYW1lcmFZIC0gZGlmZi55O1xuXG4gICAgICAgICAgICBpZiAobmV3U3RhZ2VYICE9PSBfY2FtZXJhLnggfHwgbmV3U3RhZ2VZICE9PSBfY2FtZXJhLnkpIHtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgICB4OiBuZXdTdGFnZVgsXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgcG9zMC54LCBwb3MwLnkpKTtcblxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwb3MwID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzBdKTtcbiAgICAgICAgICAgIHBvczEgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMV0pO1xuICAgICAgICAgICAgeDAgPSBwb3MwLng7XG4gICAgICAgICAgICB5MCA9IHBvczAueTtcbiAgICAgICAgICAgIHgxID0gcG9zMS54O1xuICAgICAgICAgICAgeTEgPSBwb3MxLnk7XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDAgKyBfc3RhcnRUb3VjaFgxKSAvIDIgLVxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMCArIF9zdGFydFRvdWNoWTEpIC8gMiAtXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbmQgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgICAoeDAgKyB4MSkgLyAyIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgICAgICh5MCArIHkxKSAvIDIgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZEFuZ2xlID0gTWF0aC5hdGFuMih5MSAtIHkwLCB4MSAtIHgwKSAtIF9zdGFydFRvdWNoQW5nbGU7XG4gICAgICAgICAgICBkUmF0aW8gPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICh5MSAtIHkwKSAqICh5MSAtIHkwKSArICh4MSAtIHgwKSAqICh4MSAtIHgwKVxuICAgICAgICAgICAgKSAvIF9zdGFydFRvdWNoRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zbGF0aW9uOlxuICAgICAgICAgICAgeDAgPSBzdGFydC54O1xuICAgICAgICAgICAgeTAgPSBzdGFydC55O1xuXG4gICAgICAgICAgICAvLyBIb21vdGhldGljIHRyYW5zZm9ybWF0aW9uOlxuICAgICAgICAgICAgbmV3U3RhZ2VSYXRpbyA9IF9zdGFydENhbWVyYVJhdGlvIC8gZFJhdGlvO1xuICAgICAgICAgICAgeDAgPSB4MCAqIGRSYXRpbztcbiAgICAgICAgICAgIHkwID0geTAgKiBkUmF0aW87XG5cbiAgICAgICAgICAgIC8vIFJvdGF0aW9uOlxuICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSA9IF9zdGFydENhbWVyYUFuZ2xlIC0gZEFuZ2xlO1xuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoLWRBbmdsZSk7XG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbigtZEFuZ2xlKTtcbiAgICAgICAgICAgIHgxID0geDAgKiBjb3MgKyB5MCAqIHNpbjtcbiAgICAgICAgICAgIHkxID0geTAgKiBjb3MgLSB4MCAqIHNpbjtcbiAgICAgICAgICAgIHgwID0geDE7XG4gICAgICAgICAgICB5MCA9IHkxO1xuXG4gICAgICAgICAgICAvLyBGaW5hbGl6ZTpcbiAgICAgICAgICAgIG5ld1N0YWdlWCA9IHgwIC0gZW5kLnggKyBfc3RhcnRDYW1lcmFYO1xuICAgICAgICAgICAgbmV3U3RhZ2VZID0geTAgLSBlbmQueSArIF9zdGFydENhbWVyYVk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbmV3U3RhZ2VSYXRpbyAhPT0gX2NhbWVyYS5yYXRpbyB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZUFuZ2xlICE9PSBfY2FtZXJhLmFuZ2xlIHx8XG4gICAgICAgICAgICAgIG5ld1N0YWdlWCAhPT0gX2NhbWVyYS54IHx8XG4gICAgICAgICAgICAgIG5ld1N0YWdlWSAhPT0gX2NhbWVyYS55XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUgPSBfY2FtZXJhLmFuZ2xlO1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVJhdGlvID0gX2NhbWVyYS5yYXRpbztcblxuICAgICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xuICAgICAgICAgICAgICAgIHg6IG5ld1N0YWdlWCxcbiAgICAgICAgICAgICAgICB5OiBuZXdTdGFnZVksXG4gICAgICAgICAgICAgICAgYW5nbGU6IG5ld1N0YWdlQW5nbGUsXG4gICAgICAgICAgICAgICAgcmF0aW86IG5ld1N0YWdlUmF0aW9cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgZG91YmxlIHRhcCBjdXN0b20gZXZlbnQuIEl0IHdpbGxcbiAgICAgKiBiYXNpY2FsbHkgem9vbSBpbnRvIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG91YmxlVGFwSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbjtcblxuICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxICYmIF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgX2RvdWJsZVRhcCA9IHRydWU7XG5cbiAgICAgICAgcmF0aW8gPSAxIC8gX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIHBvcyA9IHBvc2l0aW9uKGUudG91Y2hlc1swXSk7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZWNsaWNrJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBwb3MueCwgcG9zLnkpKTtcblxuICAgICAgICBpZiAoX3NldHRpbmdzKCdkb3VibGVDbGlja0VuYWJsZWQnKSkge1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBwb3MueCAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgcG9zLnkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29tRHVyYXRpb24nKSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBfZG91YmxlVGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgaWYgKHR5cGVvZiBjb25yYWQgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdjb25yYWQgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnJlbmRlcmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY2FudmFzIHNpZ21hJ3MgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgICAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhLlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIG9iamVjdCAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcyA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMuY2FudmFzOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICghKG9wdGlvbnMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgICAgdGhyb3cgJ0NvbnRhaW5lciBub3QgZm91bmQuJztcblxuICAgIHZhciBrLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBmbixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWluIGF0dHJpYnV0ZXM6XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25yYWRJZCcsIHtcbiAgICAgIHZhbHVlOiBzaWdtYS51dGlscy5pZCgpXG4gICAgfSk7XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICAgICkgP1xuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxuICAgICAgICBzZXR0aW5ncztcblxuICAgIC8vIE5vZGUgaW5kZXhlczpcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcblxuICAgIC8vIENvbnJhZCByZWxhdGVkIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5qb2JzID0ge307XG5cbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9ICdyZW5kZXJlcicgKyB0aGlzLmNvbnJhZElkICsgJzonO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzOlxuICAgIGlmIChcbiAgICAgICF0aGlzLnNldHRpbmdzKCdiYXRjaEVkZ2VzRHJhd2luZycpXG4gICAgKSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLm5vZGVzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnZWRnZXMnKTtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ3NjZW5lJyk7XG4gICAgICB0aGlzLmNvbnRleHRzLm5vZGVzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdtb3VzZScpO1xuICAgIHRoaXMuY29udGV4dHMuaG92ZXIgPSB0aGlzLmNvbnRleHRzLm1vdXNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcbiAgICAgICAgbmV3IGZuKFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubW91c2UsXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XG4gICAgc2lnbWEubWlzYy5iaW5kRXZlbnRzLmNhbGwodGhpcywgdGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5vcHRpb25zLnByZWZpeCk7XG5cbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBjYW52YXNlcy5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBrLFxuICAgICAgICBsLFxuICAgICAgICBvLFxuICAgICAgICBpZCxcbiAgICAgICAgZW5kLFxuICAgICAgICBqb2IsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgcmVuZGVyZXJzLFxuICAgICAgICByZW5kZXJlclR5cGUsXG4gICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgdGVtcEdDTyxcbiAgICAgICAgaW5kZXggPSB7fSxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxuICAgICAgICBub2RlcyA9IHRoaXMuZ3JhcGgubm9kZXMsXG4gICAgICAgIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXggfHwgJycsXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKSxcbiAgICAgICAgZHJhd0xhYmVscyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdMYWJlbHMnKSxcbiAgICAgICAgZHJhd0VkZ2VMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZUxhYmVscycpLFxuICAgICAgICBlbWJlZFNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucywge1xuICAgICAgICAgIHByZWZpeDogdGhpcy5vcHRpb25zLnByZWZpeFxuICAgICAgICB9KTtcblxuICAgIC8vIENhbGwgdGhlIHJlc2l6ZSBmdW5jdGlvbjpcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBBcHBseSB0aGUgY2FtZXJhJ3MgdmlldzpcbiAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBDbGVhciBjYW52YXNlczpcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAvLyBLaWxsIHJ1bm5pbmcgam9iczpcbiAgICBmb3IgKGsgaW4gdGhpcy5qb2JzKVxuICAgICAgaWYgKGNvbnJhZC5oYXNKb2IoaykpXG4gICAgICAgIGNvbnJhZC5raWxsSm9iKGspO1xuXG4gICAgLy8gRmluZCB3aGljaCBub2RlcyBhcmUgb24gc2NyZWVuOlxuICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IFtdO1xuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IHRoaXMuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXG4gICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgKTtcblxuICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGluZGV4W2FbaV0uaWRdID0gYVtpXTtcblxuICAgIC8vIERyYXcgZWRnZXM6XG4gICAgLy8gLSBJZiBzZXR0aW5ncygnYmF0Y2hFZGdlc0RyYXdpbmcnKSBpcyB0cnVlLCB0aGUgZWRnZXMgYXJlIGRpc3BsYXllZCBwZXJcbiAgICAvLyAgIGJhdGNoZXMuIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lLlxuICAgIGlmIChkcmF3RWRnZXMpIHtcbiAgICAgIC8vIEZpcnN0LCBsZXQncyBpZGVudGlmeSB3aGljaCBlZGdlcyB0byBkcmF3LiBUbyBkbyB0aGlzLCB3ZSBqdXN0IGtlZXBcbiAgICAgIC8vIGV2ZXJ5IGVkZ2VzIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmUgZXh0cmVtaXR5IGRpc3BsYXllZCBhY2NvcmRpbmcgdG9cbiAgICAgIC8vIHRoZSBxdWFkdHJlZSBhbmQgdGhlIFwiaGlkZGVuXCIgYXR0cmlidXRlLiBXZSBhbHNvIGRvIG5vdCBrZWVwIGhpZGRlblxuICAgICAgLy8gZWRnZXMuXG4gICAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG8gPSBhW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGluZGV4W28uc291cmNlXSB8fCBpbmRleFtvLnRhcmdldF0pICYmXG4gICAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcbiAgICAgICAgKVxuICAgICAgICAgIHRoaXMuZWRnZXNPblNjcmVlbi5wdXNoKG8pO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgXCJiYXRjaEVkZ2VzRHJhd2luZ1wiIHNldHRpbmdzIGlzIHRydWUsIGVkZ2VzIGFyZSBiYXRjaGVkOlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpIHtcbiAgICAgICAgaWQgPSAnZWRnZXNfJyArIHRoaXMuY29ucmFkSWQ7XG4gICAgICAgIGJhdGNoU2l6ZSA9IGVtYmVkU2V0dGluZ3MoJ2NhbnZhc0VkZ2VzQmF0Y2hTaXplJyk7XG5cbiAgICAgICAgZWRnZXMgPSB0aGlzLmVkZ2VzT25TY3JlZW47XG4gICAgICAgIGwgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGgsIHN0YXJ0ICsgYmF0Y2hTaXplKTtcblxuICAgICAgICBqb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ZW1wR0NPID0gdGhpcy5jb250ZXh0cy5lZGdlcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG5cbiAgICAgICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZXM7XG4gICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgbyA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8udGFyZ2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyxcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEcmF3IGVkZ2UgbGFiZWxzOlxuICAgICAgICAgIGlmIChkcmF3RWRnZUxhYmVscykge1xuICAgICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzLmxhYmVscztcbiAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgbyA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgICBpZiAoIW8uaGlkZGVuKVxuICAgICAgICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICAgICAgICBvLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8uc291cmNlKSxcbiAgICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8udGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzLFxuICAgICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246XG4gICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0ZW1wR0NPO1xuXG4gICAgICAgICAgLy8gQ2F0Y2ggam9iJ3MgZW5kOlxuICAgICAgICAgIGlmIChlbmQgPT09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuam9ic1tpZF07XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnQgPSBlbmQgKyAxO1xuICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVkZ2VzLmxlbmd0aCwgc3RhcnQgKyBiYXRjaFNpemUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuam9ic1tpZF0gPSBqb2I7XG4gICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gSWYgbm90LCB0aGV5IGFyZSBkcmF3biBpbiBvbmUgZnJhbWU6XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZXM7XG4gICAgICAgIGZvciAoYSA9IHRoaXMuZWRnZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG8gPSBhW2ldO1xuICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICBvLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgbyxcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8uc291cmNlKSxcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8udGFyZ2V0KSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgZWRnZSBsYWJlbHM6XG4gICAgICAgIC8vIC0gTm8gYmF0Y2hpbmdcbiAgICAgICAgaWYgKGRyYXdFZGdlTGFiZWxzKSB7XG4gICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzLmxhYmVscztcbiAgICAgICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3IG5vZGVzOlxuICAgIC8vIC0gTm8gYmF0Y2hpbmdcbiAgICBpZiAoZHJhd05vZGVzKSB7XG4gICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMubm9kZXM7XG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIERyYXcgbGFiZWxzOlxuICAgIC8vIC0gTm8gYmF0Y2hpbmdcbiAgICBpZiAoZHJhd0xhYmVscykge1xuICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmxhYmVscztcbiAgICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgYVtpXS50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHROb2RlVHlwZScpXG4gICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnIFRoZSBsYWJlbCB0YWcuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgIFRoZSBpZCBvZiB0aGUgZWxlbWVudCAodG8gc3RvcmUgaXQgaW4gXCJkb21FbGVtZW50c1wiKS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmluaXRET00gPSBmdW5jdGlvbih0YWcsIGlkKSB7XG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2lnbWEtJyArIGlkKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudHNbaWRdID0gZG9tO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICBpZiAodGFnLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKVxuICAgICAgdGhpcy5jb250ZXh0c1tpZF0gPSBkb20uZ2V0Q29udGV4dCgnMmQnKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xuICAgKiBkaW1lbnNpb25zLiBUaGVuLCBpdCByZW5kZXJzIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW8gPSBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XG5cbiAgICBpZiAodyAhPT0gdW5kZWZpbmVkICYmIGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB3ID0gdGhpcy53aWR0aDtcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzW2tdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIChoICogcGl4ZWxSYXRpbykgKyAncHgnKTtcblxuICAgICAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1trXS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjbGVhcnMgZWFjaCBjYW52YXMuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICB0aGlzLmNvbnRleHRzW2tdLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGNvbnRleHRzIGFuZCBvdGhlciBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLFxuICAgICAgICBjYXB0b3I7XG5cbiAgICAvLyBLaWxsIGNhcHRvcnM6XG4gICAgd2hpbGUgKChjYXB0b3IgPSB0aGlzLmNhcHRvcnMucG9wKCkpKVxuICAgICAgY2FwdG9yLmtpbGwoKTtcbiAgICBkZWxldGUgdGhpcy5jYXB0b3JzO1xuXG4gICAgLy8gS2lsbCBjb250ZXh0czpcbiAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xuICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNba10pO1xuICAgICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHNba107XG4gICAgICBkZWxldGUgdGhpcy5jb250ZXh0c1trXTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuY29udGV4dHM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbHMsIG5vZGVzIGFuZCBlZGdlcyByZW5kZXJlcnMgYXJlIHN0b3JlZCBpbiB0aGUgdGhyZWUgZm9sbG93aW5nXG4gICAqIG9iamVjdHMuIFdoZW4gYW4gZWxlbWVudCBpcyBkcmF3biwgaXRzIHR5cGUgd2lsbCBiZSBjaGVja2VkIGFuZCBpZiBhXG4gICAqIHJlbmRlcmVyIHdpdGggdGhlIHNhbWUgbmFtZSBleGlzdHMsIGl0IHdpbGwgYmUgdXNlZC4gSWYgbm90IGZvdW5kLCB0aGVcbiAgICogZGVmYXVsdCByZW5kZXJlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICpcbiAgICogVGhleSBhcmUgc3RvcmVkIGluIGRpZmZlcmVudCBmaWxlcywgaW4gdGhlIFwiLi9jYW52YXNcIiBmb2xkZXIuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ub2RlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnJlbmRlcmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY2FudmFzIHNpZ21hJ3MgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgICAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhLlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIG9iamVjdCAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy53ZWJnbDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIF9zZWxmID0gdGhpcztcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuam9icyA9IHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25yYWRJZCcsIHtcbiAgICAgIHZhbHVlOiBzaWdtYS51dGlscy5pZCgpXG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnNldHRpbmdzID0gKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICAgKSA/XG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XG4gICAgICAgIHNldHRpbmdzO1xuXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSB0aGlzLmNhbWVyYS5yZWFkUHJlZml4O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBwcm9ncmFtcyBoYXNoXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub2RlUHJvZ3JhbXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VQcm9ncmFtcycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZUZsb2F0QXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlRmxvYXRBcnJheXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VJbmRpY2VzQXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBET00gZWxlbWVudHM6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJywgdHJ1ZSk7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdub2RlcycsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScsIHRydWUpO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdsYWJlbHMnKTtcbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdtb3VzZScpO1xuICAgIHRoaXMuY29udGV4dHMuaG92ZXIgPSB0aGlzLmNvbnRleHRzLm1vdXNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcbiAgICAgICAgbmV3IGZuKFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubW91c2UsXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XG4gICAgc2lnbWEubWlzYy5iaW5kRXZlbnRzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcbiAgICBzaWdtYS5taXNjLmRyYXdIb3ZlcnMuY2FsbCh0aGlzLCB0aGlzLmNhbWVyYS5wcmVmaXgpO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBnZW5lcmF0ZSB0aGUgbm9kZXMgYW5kIGVkZ2VzIGZsb2F0IGFycmF5cy4gVGhpcyBzdGVwIGlzXG4gICAqIHNlcGFyYXRlZCBmcm9tIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYmVjYXVzZSB0byBrZWVwIFdlYkdMIGVmZmljaWVudCwgc2luY2VcbiAgICogYWxsIHRoZSBjYW1lcmEgYW5kIG1pZGRsZXdhcmVzIGFyZSBtb2RlbGlzZWQgYXMgbWF0cmljZXMgYW5kIHRoZXkgZG8gbm90XG4gICAqIHJlcXVpcmUgdGhlIGZsb2F0IGFycmF5cyB0byBiZSByZWdlbmVyYXRlZC5cbiAgICpcbiAgICogQmFzaWNhbGx5LCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBjYW1lcmEgb3IgYXBwbGllcyBzb21lIHNwZWNpZmljIGxpbmVhclxuICAgKiB0cmFuc2Zvcm1hdGlvbnMsIHRoaXMgcHJvY2VzcyBzdGVwIHdpbGwgYmUgc2tpcHBlZCwgYW5kIHRoZSBcInJlbmRlclwiXG4gICAqIG1ldGhvZCB3aWxsIGVmZmljaWVudGx5IHJlZnJlc2ggdGhlIHJlbmRlcmluZy5cbiAgICpcbiAgICogQW5kIHdoZW4gdGhlIHVzZXIgbW9kaWZpZXMgdGhlIGdyYXBoIGNvbG9ycyBvciBwb3NpdGlvbnMgKGFwcGx5aW5nIGEgbmV3XG4gICAqIGxheW91dCBvciBmaWx0ZXJpbmcgdGhlIGNvbG9ycywgZm9yIGluc3RhbmNlKSwgdGhpcyBcInByb2Nlc3NcIiBzdGVwIHdpbGwgYmVcbiAgICogcmVxdWlyZWQgdG8gcmVnZW5lcmF0ZSB0aGUgZmxvYXQgYXJyYXlzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxuICAgICAgICBvcHRpb25zID0gc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMsIHRoaXMub3B0aW9ucyksXG4gICAgICAgIGRlZmF1bHRFZGdlVHlwZSA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpLFxuICAgICAgICBkZWZhdWx0Tm9kZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKTtcblxuICAgIC8vIEVtcHR5IGZsb2F0IGFycmF5czpcbiAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5ub2RlRmxvYXRBcnJheXNba107XG5cbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5lZGdlRmxvYXRBcnJheXNba107XG5cbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlSW5kaWNlc0FycmF5cylcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2tdO1xuXG4gICAgLy8gU29ydCBlZGdlcyBhbmQgbm9kZXMgcGVyIHR5cGVzOlxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHR5cGUgPSBhW2ldLnR5cGUgfHwgZGVmYXVsdEVkZ2VUeXBlO1xuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLmVkZ2VzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcblxuICAgICAgaWYgKCF0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSlcbiAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10gPSB7XG4gICAgICAgICAgZWRnZXM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmVkZ2VzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgZm9yIChhID0gZ3JhcGgubm9kZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdHlwZSA9IGFbaV0udHlwZSB8fCBkZWZhdWx0Tm9kZVR5cGU7XG4gICAgICBrID0gKHR5cGUgJiYgc2lnbWEud2ViZ2wubm9kZXNbdHlwZV0pID8gdHlwZSA6ICdkZWYnO1xuXG4gICAgICBpZiAoIXRoaXMubm9kZUZsb2F0QXJyYXlzW2tdKVxuICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXSA9IHtcbiAgICAgICAgICBub2RlczogW11cbiAgICAgICAgfTtcblxuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10ubm9kZXMucHVzaChhW2ldKTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIGVkZ2VzOlxuICAgIGZvciAoayBpbiB0aGlzLmVkZ2VGbG9hdEFycmF5cykge1xuICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1trXTtcbiAgICAgIGEgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5lZGdlcztcblxuICAgICAgLy8gQ3JlYXRpbmcgdGhlIG5lY2Vzc2FyeSBhcnJheXNcbiAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgYS5sZW5ndGggKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICApO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBKdXN0IGNoZWNrIHRoYXQgdGhlIGVkZ2UgYW5kIGJvdGggaXRzIGV4dHJlbWl0aWVzIGFyZSB2aXNpYmxlOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWFbaV0uaGlkZGVuICYmXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0uc291cmNlKS5oaWRkZW4gJiZcbiAgICAgICAgICAhZ3JhcGgubm9kZXMoYVtpXS50YXJnZXQpLmhpZGRlblxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyZXIuYWRkRWRnZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSksXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnRhcmdldCksXG4gICAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlci5jb21wdXRlSW5kaWNlcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXSA9IHJlbmRlcmVyLmNvbXB1dGVJbmRpY2VzKFxuICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBub2RlczpcbiAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpIHtcbiAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wubm9kZXNba107XG4gICAgICBhID0gdGhpcy5ub2RlRmxvYXRBcnJheXNba10ubm9kZXM7XG5cbiAgICAgIC8vIENyZWF0aW5nIHRoZSBuZWNlc3NhcnkgYXJyYXlzXG4gICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkpXG4gICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICAgICAgYS5sZW5ndGggKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgKTtcblxuICAgICAgICAvLyBKdXN0IGNoZWNrIHRoYXQgdGhlIGVkZ2UgYW5kIGJvdGggaXRzIGV4dHJlbWl0aWVzIGFyZSB2aXNpYmxlOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWFbaV0uaGlkZGVuXG4gICAgICAgIClcbiAgICAgICAgICByZW5kZXJlci5hZGROb2RlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAgaSAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVMsXG4gICAgICAgICAgICBvcHRpb25zLnByZWZpeCxcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaC4gSXQgYmFzaWNhbGx5IGNhbGxzIGVhY2ggcHJvZ3JhbSAoYW5kXG4gICAqIGdlbmVyYXRlIHRoZW0gaWYgdGhleSBkbyBub3QgZXhpc3QgeWV0KSB0byByZW5kZXIgbm9kZXMgYW5kIGVkZ2VzLCBiYXRjaGVkXG4gICAqIHBlciByZW5kZXJlci5cbiAgICpcbiAgICogQXMgaW4gdGhlIGNhbnZhcyByZW5kZXJlciwgaXQgaXMgcG9zc2libGUgdG8gZGlzcGxheSBlZGdlcywgbm9kZXMgYW5kIC8gb3JcbiAgICogbGFiZWxzIGluIGJhdGNoZXMsIHRvIG1ha2UgdGhlIHdob2xlIHRoaW5nIHdheSBtb3JlIHNjYWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICAgICAgICAgICAgIHBhcmFtcyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBvLFxuICAgICAgICBwcm9ncmFtLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXNHbCA9IHRoaXMuY29udGV4dHMubm9kZXMsXG4gICAgICAgIGVkZ2VzR2wgPSB0aGlzLmNvbnRleHRzLmVkZ2VzLFxuICAgICAgICBtYXRyaXggPSB0aGlzLmNhbWVyYS5nZXRNYXRyaXgoKSxcbiAgICAgICAgb3B0aW9ucyA9IHNpZ21hLnV0aWxzLmV4dGVuZChwYXJhbXMsIHRoaXMub3B0aW9ucyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKTtcblxuICAgIC8vIENhbGwgdGhlIHJlc2l6ZSBmdW5jdGlvbjpcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBDbGVhciBjYW52YXNlczpcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAvLyBUcmFuc2xhdGUgbWF0cml4IHRvIFt3aWR0aC8yLCBoZWlnaHQvMl06XG4gICAgbWF0cml4ID0gc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICBtYXRyaXgsXG4gICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbih0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKVxuICAgICk7XG5cbiAgICAvLyBLaWxsIHJ1bm5pbmcgam9iczpcbiAgICBmb3IgKGsgaW4gdGhpcy5qb2JzKVxuICAgICAgaWYgKGNvbnJhZC5oYXNKb2IoaykpXG4gICAgICAgIGNvbnJhZC5raWxsSm9iKGspO1xuXG4gICAgaWYgKGRyYXdFZGdlcykge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYSxcbiAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIGpvYixcbiAgICAgICAgICAgICAgYXJyLFxuICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICBpbmRpY2VzLFxuICAgICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgICAgYmF0Y2hTaXplLFxuICAgICAgICAgICAgICBjdXJyZW50UHJvZ3JhbTtcblxuICAgICAgICAgIGlkID0gJ2VkZ2VzXycgKyB0aGlzLmNvbnJhZElkO1xuICAgICAgICAgIGJhdGNoU2l6ZSA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ3dlYmdsRWRnZXNCYXRjaFNpemUnKTtcbiAgICAgICAgICBhID0gT2JqZWN0LmtleXModGhpcy5lZGdlRmxvYXRBcnJheXMpO1xuXG4gICAgICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2FbaV1dO1xuICAgICAgICAgIGFyciA9IHRoaXMuZWRnZUZsb2F0QXJyYXlzW2FbaV1dLmFycmF5O1xuICAgICAgICAgIGluZGljZXMgPSB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2FbaV1dO1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgam9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSlcbiAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0gPSByZW5kZXJlci5pbml0UHJvZ3JhbShlZGdlc0dsKTtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICAgIGVkZ2VzR2wudXNlUHJvZ3JhbSh0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSk7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgICBlZGdlc0dsLFxuICAgICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dLFxuICAgICAgICAgICAgICAgIGFycixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbydcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICBjb3VudDogZW5kIC0gc3RhcnQsXG4gICAgICAgICAgICAgICAgICBpbmRpY2VzRGF0YTogaW5kaWNlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2F0Y2ggam9iJ3MgZW5kOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlbmQgPj0gYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVMgJiZcbiAgICAgICAgICAgICAgaSA9PT0gYS5sZW5ndGggLSAxXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuam9ic1tpZF07XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuZCA+PSBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFUykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGFyciA9IHRoaXMuZWRnZUZsb2F0QXJyYXlzW2FbaV1dLmFycmF5O1xuICAgICAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2FbaV1dO1xuICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgc3RhcnQgKyBiYXRjaFNpemUgKiByZW5kZXJlci5QT0lOVFMsXG4gICAgICAgICAgICAgICAgYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuam9ic1tpZF0gPSBqb2I7XG4gICAgICAgICAgY29ucmFkLmFkZEpvYihpZCwgam9iLmJpbmQodGhpcykpO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoayBpbiB0aGlzLmVkZ2VGbG9hdEFycmF5cykge1xuICAgICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XG5cbiAgICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICAgIGlmICghdGhpcy5lZGdlUHJvZ3JhbXNba10pXG4gICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1trXSA9IHJlbmRlcmVyLmluaXRQcm9ncmFtKGVkZ2VzR2wpO1xuXG4gICAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgICAgaWYgKHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdKSB7XG4gICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNba10pO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgICBlZGdlc0dsLFxuICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1trXSxcbiAgICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKSxcbiAgICAgICAgICAgICAgICBpbmRpY2VzRGF0YTogdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkcmF3Tm9kZXMpIHtcbiAgICAgIC8vIEVuYWJsZSBibGVuZGluZzpcbiAgICAgIG5vZGVzR2wuYmxlbmRGdW5jKG5vZGVzR2wuU1JDX0FMUEhBLCBub2Rlc0dsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgbm9kZXNHbC5lbmFibGUobm9kZXNHbC5CTEVORCk7XG5cbiAgICAgIGZvciAoayBpbiB0aGlzLm5vZGVGbG9hdEFycmF5cykge1xuICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLm5vZGVzW2tdO1xuXG4gICAgICAgIC8vIENoZWNrIHByb2dyYW06XG4gICAgICAgIGlmICghdGhpcy5ub2RlUHJvZ3JhbXNba10pXG4gICAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShub2Rlc0dsKTtcblxuICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgaWYgKHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdKSB7XG4gICAgICAgICAgbm9kZXNHbC51c2VQcm9ncmFtKHRoaXMubm9kZVByb2dyYW1zW2tdKTtcbiAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICBub2Rlc0dsLFxuICAgICAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNba10sXG4gICAgICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHJhd0xhYmVscykge1xuICAgICAgYSA9IHRoaXMuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXG4gICAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICAgICk7XG5cbiAgICAgIC8vIEFwcGx5IGNhbWVyYSB2aWV3IHRvIHRoZXNlIG5vZGVzOlxuICAgICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAge1xuICAgICAgICAgIG5vZGVzOiBhLFxuICAgICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIG8gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2V0dGluZ3Moe1xuICAgICAgICAgIHByZWZpeDogc2VsZi5jYW1lcmEucHJlZml4XG4gICAgICAgIH0sIGtleSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKFxuICAgICAgICAgICAgc2lnbWEuY2FudmFzLmxhYmVsc1tcbiAgICAgICAgICAgICAgYVtpXS50eXBlIHx8XG4gICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHROb2RlVHlwZScpXG4gICAgICAgICAgICBdIHx8IHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmXG4gICAgICAgICAgKShhW2ldLCB0aGlzLmNvbnRleHRzLmxhYmVscywgbyk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIHRhZyAgIFRoZSBsYWJlbCB0YWcuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBpZCAgICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBcImRvbUVsZW1lbnRzXCIpLlxuICAgKiBAcGFyYW0gIHs/Ym9vbGVhbn0gd2ViZ2wgV2lsbCBpbml0IHRoZSBXZWJHTCBjb250ZXh0IGlmIHRydWUuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmluaXRET00gPSBmdW5jdGlvbih0YWcsIGlkLCB3ZWJnbCkge1xuICAgIHZhciBnbCxcbiAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2lnbWEtJyArIGlkKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudHNbaWRdID0gZG9tO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICBpZiAodGFnLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICB0aGlzLmNvbnRleHRzW2lkXSA9IGRvbS5nZXRDb250ZXh0KHdlYmdsID8gJ2V4cGVyaW1lbnRhbC13ZWJnbCcgOiAnMmQnLCB7XG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZGluZyB3ZWJnbCBjb250ZXh0IGxvc3MgbGlzdGVuZXJzXG4gICAgICBpZiAod2ViZ2wpIHtcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW8gPSBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XG5cbiAgICBpZiAodyAhPT0gdW5kZWZpbmVkICYmIGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB3ID0gdGhpcy53aWR0aDtcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzW2tdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICAvLyBJZiBzaW1wbGUgMkQgY2FudmFzOlxuICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRzW2tdICYmIHRoaXMuY29udGV4dHNba10uc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykgKyAncHgnKTtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKVxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgKHcgKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJykpICsgJ3B4J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgKGggKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJykpICsgJ3B4J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTY2FsZTpcbiAgICBmb3IgKGsgaW4gdGhpcy5jb250ZXh0cylcbiAgICAgIGlmICh0aGlzLmNvbnRleHRzW2tdICYmIHRoaXMuY29udGV4dHNba10udmlld3BvcnQpXG4gICAgICAgIHRoaXMuY29udGV4dHNba10udmlld3BvcnQoXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMud2lkdGggKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXG4gICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJylcbiAgICAgICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjbGVhcnMgZWFjaCBjYW52YXMuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dHMubGFiZWxzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgdGhpcy5jb250ZXh0cy5ub2Rlcy5jbGVhcih0aGlzLmNvbnRleHRzLm5vZGVzLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIHRoaXMuY29udGV4dHMuZWRnZXMuY2xlYXIodGhpcy5jb250ZXh0cy5lZGdlcy5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLFxuICAgICAgICBjYXB0b3I7XG5cbiAgICAvLyBLaWxsIGNhcHRvcnM6XG4gICAgd2hpbGUgKChjYXB0b3IgPSB0aGlzLmNhcHRvcnMucG9wKCkpKVxuICAgICAgY2FwdG9yLmtpbGwoKTtcbiAgICBkZWxldGUgdGhpcy5jYXB0b3JzO1xuXG4gICAgLy8gS2lsbCBjb250ZXh0czpcbiAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xuICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNba10pO1xuICAgICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHNba107XG4gICAgICBkZWxldGUgdGhpcy5jb250ZXh0c1trXTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuY29udGV4dHM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgXCJzaWdtYS53ZWJnbC5ub2Rlc1wiIGNvbnRhaW5zIHRoZSBkaWZmZXJlbnQgV2ViR0wgbm9kZVxuICAgKiByZW5kZXJlcnMuIFRoZSBkZWZhdWx0IG9uZSBkcmF3IG5vZGVzIGFzIGRpc2NzLiBIZXJlIGFyZSB0aGUgYXR0cmlidXRlc1xuICAgKiBhbnkgbm9kZSByZW5kZXJlciBtdXN0IGhhdmU6XG4gICAqXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhIG5vZGUuXG4gICAqIHtudW1iZXJ9ICAgQVRUUklCVVRFUyAgVGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIG5lZWRlZCB0byBkcmF3IG9uZSBwb2ludC5cbiAgICoge2Z1bmN0aW9ufSBhZGROb2RlICAgICBBIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIG5vZGUgdG8gdGhlIGRhdGEgc3RhY2sgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGJ1ZmZlci4gSGVyZSBpcyB0aGUgYXJndW1lbnRzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgbm9kZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge251bWJlcn0gICAgICAgaW5kZXggICBUaGUgbm9kZSBpbmRleCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjay5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG9wdGlvbnMgU29tZSBvcHRpb25zLlxuICAgKiB7ZnVuY3Rpb259IHJlbmRlciAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZWZmZWN0aXZlbHkgcmVuZGVyIHRoZSBub2Rlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGludG8gdGhlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICBwcm9ncmFtXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjayB0byBnaXZlIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBwYXJhbXMgIEFuIG9iamVjdCBjb250YWluaW5nIHNvbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgbGlrZSB3aWR0aCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LCB0aGUgY2FtZXJhIHJhdGlvLlxuICAgKiB7ZnVuY3Rpb259IGluaXRQcm9ncmFtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgaW5pdGlhdGUgdGhlIHByb2dyYW0sIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVsZXZhbnQgc2hhZGVycyBhbmQgcGFyYW1ldGVycy4gSXQgbXVzdCByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3bHkgY3JlYXRlZCBwcm9ncmFtLlxuICAgKlxuICAgKiBDaGVjayBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgb3Igc2lnbWEud2ViZ2wubm9kZXMuZmFzdCB0byBzZWUgaG93IGl0XG4gICAqIHdvcmtzIG1vcmUgcHJlY2lzZWx5LlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5ub2RlcycpO1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wuZWRnZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIGVkZ2VcbiAgICogcmVuZGVyZXJzLiBUaGUgZGVmYXVsdCBvbmUgZHJhdyBlZGdlcyBhcyBkaXJlY3QgbGluZXMuIEhlcmUgYXJlIHRoZVxuICAgKiBhdHRyaWJ1dGVzIGFueSBlZGdlIHJlbmRlcmVyIG11c3QgaGF2ZTpcbiAgICpcbiAgICoge251bWJlcn0gICBQT0lOVFMgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyByZXF1aXJlZCB0byBkcmF3IGFuIGVkZ2UuXG4gICAqIHtudW1iZXJ9ICAgQVRUUklCVVRFUyAgVGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIG5lZWRlZCB0byBkcmF3IG9uZSBwb2ludC5cbiAgICoge2Z1bmN0aW9ufSBhZGRFZGdlICAgICBBIGZ1bmN0aW9uIHRoYXQgYWRkcyBhbiBlZGdlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIHRvIHRoZSBidWZmZXIuIEhlcmUgaXMgdGhlIGFyZ3VtZW50czpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIGVkZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHNvdXJjZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgdGFyZ2V0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjay5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG9wdGlvbnMgU29tZSBvcHRpb25zLlxuICAgKiB7ZnVuY3Rpb259IHJlbmRlciAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZWZmZWN0aXZlbHkgcmVuZGVyIHRoZSBlZGdlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGludG8gdGhlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICBwcm9ncmFtXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjayB0byBnaXZlIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBwYXJhbXMgIEFuIG9iamVjdCBjb250YWluaW5nIHNvbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgbGlrZSB3aWR0aCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LCB0aGUgY2FtZXJhIHJhdGlvLlxuICAgKiB7ZnVuY3Rpb259IGluaXRQcm9ncmFtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgaW5pdGlhdGUgdGhlIHByb2dyYW0sIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVsZXZhbnQgc2hhZGVycyBhbmQgcGFyYW1ldGVycy4gSXQgbXVzdCByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3bHkgY3JlYXRlZCBwcm9ncmFtLlxuICAgKlxuICAgKiBDaGVjayBzaWdtYS53ZWJnbC5lZGdlcy5kZWYgb3Igc2lnbWEud2ViZ2wuZWRnZXMuZmFzdCB0byBzZWUgaG93IGl0XG4gICAqIHdvcmtzIG1vcmUgcHJlY2lzZWx5LlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEuY2FudmFzLmxhYmVsc1wiIGNvbnRhaW5zIHRoZSBkaWZmZXJlbnRcbiAgICogbGFiZWwgcmVuZGVyZXJzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXIuIFNpbmNlIGRpc3BsYXlpbmcgdGV4dHMgaW4gV2ViR0wgaXNcbiAgICogZGVmaW5pdGVseSBwYWluZnVsIGFuZCBzaW5jZSB0aGVyZSBhIHdheSBsZXNzIGxhYmVscyB0byBkaXNwbGF5IHRoYW4gbm9kZXNcbiAgICogb3IgZWRnZXMsIHRoZSBkZWZhdWx0IHJlbmRlcmVyIHNpbXBseSByZW5kZXJzIHRoZW0gaW4gYSBjYW52YXMuXG4gICAqXG4gICAqIEEgbGFiZWxzIHJlbmRlcmVyIGlzIGEgc2ltcGxlIGZ1bmN0aW9uLCB0YWtpbmcgYXMgYXJndW1lbnRzIHRoZSByZWxhdGVkXG4gICAqIG5vZGUsIHRoZSByZW5kZXJlciBhbmQgYSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmxhYmVscycpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIGlmICh0eXBlb2YgY29ucmFkID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIHN2ZyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLnN2ZzogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge1xuICAgICAgZ3JhcGg6IG51bGwsXG4gICAgICBncm91cHM6IHt9LFxuICAgICAgbm9kZXM6IHt9LFxuICAgICAgZWRnZXM6IHt9LFxuICAgICAgbGFiZWxzOiB7fSxcbiAgICAgIGhvdmVyczoge31cbiAgICB9O1xuICAgIHRoaXMubWVhc3VyZW1lbnRDYW52YXMgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXG4gICAgICApID9cbiAgICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMuc2V0dGluZ3MpIDpcbiAgICAgICAgc2V0dGluZ3M7XG5cbiAgICAvLyBJcyB0aGUgcmVuZGVyZXIgbWVhbnQgdG8gYmUgZnJlZXN0eWxlP1xuICAgIHRoaXMuc2V0dGluZ3MoJ2ZyZWVTdHlsZScsICEhdGhpcy5vcHRpb25zLmZyZWVTdHlsZSk7XG5cbiAgICAvLyBTVkcgeG1sbnNcbiAgICB0aGlzLnNldHRpbmdzKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuXG4gICAgLy8gSW5kZXhlczpcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcblxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gJ3JlbmRlcmVyJyArIHNpZ21hLnV0aWxzLmlkKCkgKyAnOic7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBET00gZWxlbWVudHNcbiAgICB0aGlzLmluaXRET00oJ3N2ZycpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcbiAgICAgICAgbmV3IGZuKFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGgsXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJpbmQgcmVzaXplOlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVzaXplKCk7XG4gICAgfSk7XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIC8vIFRPRE86IGtlZXAgYW4gb3B0aW9uIHRvIG92ZXJyaWRlIHRoZSBET00gZXZlbnRzP1xuICAgIHNpZ21hLm1pc2MuYmluZERPTUV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGgpO1xuICAgIHRoaXMuYmluZEhvdmVycyh0aGlzLm9wdGlvbnMucHJlZml4KTtcblxuICAgIC8vIFJlc2l6ZVxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGggb24gdGhlIHN2ZyBzY2VuZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBrLFxuICAgICAgICBlLFxuICAgICAgICBsLFxuICAgICAgICBvLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVkZ2VzLFxuICAgICAgICByZW5kZXJlcnMsXG4gICAgICAgIHN1YnJlbmRlcmVycyxcbiAgICAgICAgaW5kZXggPSB7fSxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxuICAgICAgICBub2RlcyA9IHRoaXMuZ3JhcGgubm9kZXMsXG4gICAgICAgIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXggfHwgJycsXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKSxcbiAgICAgICAgZHJhd0xhYmVscyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdMYWJlbHMnKSxcbiAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMsIHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgZm9yY2VMYWJlbHM6IHRoaXMub3B0aW9ucy5mb3JjZUxhYmVsc1xuICAgICAgICB9KTtcblxuICAgIC8vIENoZWNrIHRoZSAnaGlkZUVkZ2VzT25Nb3ZlJyBzZXR0aW5nOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdoaWRlRWRnZXNPbk1vdmUnKSlcbiAgICAgIGlmICh0aGlzLmNhbWVyYS5pc0FuaW1hdGVkIHx8IHRoaXMuY2FtZXJhLmlzTW92aW5nKVxuICAgICAgICBkcmF3RWRnZXMgPSBmYWxzZTtcblxuICAgIC8vIEFwcGx5IHRoZSBjYW1lcmEncyB2aWV3OlxuICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMub3B0aW9ucy5wcmVmaXgsXG4gICAgICB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIEhpZGluZyBldmVyeXRoaW5nXG4gICAgLy8gVE9ETzogZmluZCBhIG1vcmUgc2Vuc2libGUgd2F5IHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb25cbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLm5vZGVzKTtcbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzKTtcbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLmxhYmVscyk7XG5cbiAgICAvLyBGaW5kIHdoaWNoIG5vZGVzIGFyZSBvbiBzY3JlZW5cbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICk7XG5cbiAgICAvLyBOb2RlIGluZGV4XG4gICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaW5kZXhbYVtpXS5pZF0gPSBhW2ldO1xuXG4gICAgLy8gRmluZCB3aGljaCBlZGdlcyBhcmUgb24gc2NyZWVuXG4gICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbyA9IGFbaV07XG4gICAgICBpZiAoXG4gICAgICAgIChpbmRleFtvLnNvdXJjZV0gfHwgaW5kZXhbby50YXJnZXRdKSAmJlxuICAgICAgICAoIW8uaGlkZGVuICYmICFub2RlcyhvLnNvdXJjZSkuaGlkZGVuICYmICFub2RlcyhvLnRhcmdldCkuaGlkZGVuKVxuICAgICAgKVxuICAgICAgICB0aGlzLmVkZ2VzT25TY3JlZW4ucHVzaChvKTtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IG5vZGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcubm9kZXM7XG4gICAgc3VicmVuZGVyZXJzID0gc2lnbWEuc3ZnLmxhYmVscztcblxuICAgIC8vLS0gRmlyc3Qgd2UgY3JlYXRlIHRoZSBub2RlcyB3aGljaCBhcmUgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgIGlmIChkcmF3Tm9kZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbiAmJiAhdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSkge1xuXG4gICAgICAgICAgLy8gTm9kZVxuICAgICAgICAgIGUgPSAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSA9IGU7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHMubm9kZXMuYXBwZW5kQ2hpbGQoZSk7XG5cbiAgICAgICAgICAvLyBMYWJlbFxuICAgICAgICAgIGUgPSAoc3VicmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgc3VicmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5sYWJlbHNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmxhYmVscy5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBub2Rlc1xuICAgIGlmIChkcmF3Tm9kZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICBpZiAoYVtpXS5oaWRkZW4pXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgLy8gTm9kZVxuICAgICAgICAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikudXBkYXRlKFxuICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gTGFiZWxcbiAgICAgICAgKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHN1YnJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubGFiZWxzW2FbaV0uaWRdLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgIC8vIERpc3BsYXkgZWRnZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5lZGdlcztcblxuICAgIC8vLS0gRmlyc3Qgd2UgY3JlYXRlIHRoZSBlZGdlcyB3aGljaCBhcmUgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgIGlmIChkcmF3RWRnZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzW2FbaV0uaWRdKSB7XG4gICAgICAgICAgc291cmNlID0gbm9kZXMoYVtpXS5zb3VyY2UpO1xuICAgICAgICAgIHRhcmdldCA9IG5vZGVzKGFbaV0udGFyZ2V0KTtcblxuICAgICAgICAgIGUgPSAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSA9IGU7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHMuZWRnZXMuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAvLy0tIFNlY29uZCB3ZSB1cGRhdGUgdGhlIGVkZ2VzXG4gICAgaWYgKGRyYXdFZGdlcylcbiAgICAgIGZvciAoYSA9IHRoaXMuZWRnZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzb3VyY2UgPSBub2RlcyhhW2ldLnNvdXJjZSk7XG4gICAgICAgIHRhcmdldCA9IG5vZGVzKGFbaV0udGFyZ2V0KTtcblxuICAgICAgICAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikudXBkYXRlKFxuICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluIFwiZG9tRWxlbWVudHNcIikuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnKSB7XG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLnNldHRpbmdzKCd4bWxucycpLCB0YWcpLFxuICAgICAgICBjID0gdGhpcy5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSxcbiAgICAgICAgZyxcbiAgICAgICAgbCxcbiAgICAgICAgaTtcblxuICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjICsgJy1zdmcnKTtcblxuICAgIC8vIFNldHRpbmcgU1ZHIG5hbWVzcGFjZVxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgdGhpcy5zZXR0aW5ncygneG1sbnMnKSk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCAnMS4xJyk7XG5cbiAgICAvLyBDcmVhdGluZyB0aGUgbWVhc3VyZW1lbnQgY2FudmFzXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctbWVhc3VyZW1lbnQtY2FudmFzJyk7XG5cbiAgICAvLyBBcHBlbmRpbmcgZWxlbWVudHNcbiAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoID0gdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tKTtcblxuICAgIC8vIENyZWF0aW5nIGdyb3Vwc1xuICAgIHZhciBncm91cHMgPSBbJ2VkZ2VzJywgJ25vZGVzJywgJ2xhYmVscycsICdob3ZlcnMnXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLnNldHRpbmdzKCd4bWxucycpLCAnZycpO1xuXG4gICAgICBnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdpZCcsIGMgKyAnLWdyb3VwLScgKyBncm91cHNbaV0pO1xuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBjICsgJy1ncm91cCcpO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwc1tncm91cHNbaV1dID1cbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5hcHBlbmRDaGlsZChnKTtcbiAgICB9XG5cbiAgICAvLyBBcHBlbmRpbmcgbWVhc3VyZW1lbnQgY2FudmFzXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICB0aGlzLm1lYXN1cmVtZW50Q2FudmFzID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGhpZGVzIGEgYmF0Y2ggb2YgU1ZHIERPTSBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICAgICAgICAgICAgICAgICAgZWxlbWVudHMgIEFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIGhpZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIHJlbmRlcmVyICBUaGUgcmVuZGVyZXIgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuaGlkZURPTUVsZW1lbnRzID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgbyxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSBpbiBlbGVtZW50cykge1xuICAgICAgbyA9IGVsZW1lbnRzW2ldO1xuICAgICAgc2lnbWEuc3ZnLnV0aWxzLmhpZGUobyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGJpbmRzIHRoZSBob3ZlciBldmVudHMgdG8gdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHByZWZpeCBUaGUgcmVuZGVyZXIgcHJlZml4LlxuICAgKi9cbiAgLy8gVE9ETzogYWRkIG9wdGlvbiBhYm91dCB3aGV0aGVyIHRvIGRpc3BsYXkgaG92ZXJzIG9yIG5vdFxuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5iaW5kSG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5ob3ZlcnMsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBob3ZlcmVkTm9kZTtcblxuICAgIGZ1bmN0aW9uIG92ZXJOb2RlKGUpIHtcbiAgICAgIHZhciBub2RlID0gZS5kYXRhLm5vZGUsXG4gICAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIGlmICghZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgaG92ZXIgPSAocmVuZGVyZXJzW25vZGUudHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICBub2RlLFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLm5vZGVzW25vZGUuaWRdLFxuICAgICAgICBzZWxmLm1lYXN1cmVtZW50Q2FudmFzLFxuICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICApO1xuXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tub2RlLmlkXSA9IGhvdmVyO1xuXG4gICAgICAvLyBJbnNlcnRpbmcgdGhlIGhvdmVyIGluIHRoZSBkb21cbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5hcHBlbmRDaGlsZChob3Zlcik7XG4gICAgICBob3ZlcmVkTm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0Tm9kZShlKSB7XG4gICAgICB2YXIgbm9kZSA9IGUuZGF0YS5ub2RlLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgLy8gRGVsZXRpbmcgZWxlbWVudFxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLnJlbW92ZUNoaWxkKFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tub2RlLmlkXVxuICAgICAgKTtcbiAgICAgIGhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tub2RlLmlkXTtcblxuICAgICAgLy8gUmVpbnN0YXRlXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ub2Rlcy5hcHBlbmRDaGlsZChcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBPUFRJTUlaRTogcGVyZm9ybSBhIHJlYWwgdXBkYXRlIHJhdGhlciB0aGFuIGEgZGVsZXRpb25cbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBpZiAoIWhvdmVyZWROb2RlKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gRGVsZXRpbmcgZWxlbWVudCBiZWZvcmUgdXBkYXRlXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMucmVtb3ZlQ2hpbGQoXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW2hvdmVyZWROb2RlLmlkXVxuICAgICAgKTtcbiAgICAgIGRlbGV0ZSBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF07XG5cbiAgICAgIHZhciBob3ZlciA9IChyZW5kZXJlcnNbaG92ZXJlZE5vZGUudHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICBob3ZlcmVkTm9kZSxcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tob3ZlcmVkTm9kZS5pZF0sXG4gICAgICAgIHNlbGYubWVhc3VyZW1lbnRDYW52YXMsXG4gICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICk7XG5cbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW2hvdmVyZWROb2RlLmlkXSA9IGhvdmVyO1xuXG4gICAgICAvLyBJbnNlcnRpbmcgdGhlIGhvdmVyIGluIHRoZSBkb21cbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5hcHBlbmRDaGlsZChob3Zlcik7XG4gICAgfVxuXG4gICAgLy8gQmluZGluZyBldmVudHNcbiAgICB0aGlzLmJpbmQoJ292ZXJOb2RlJywgb3Zlck5vZGUpO1xuICAgIHRoaXMuYmluZCgnb3V0Tm9kZScsIG91dE5vZGUpO1xuXG4gICAgLy8gVXBkYXRlIG9uIHJlbmRlclxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgdXBkYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xuICAgKiBkaW1lbnNpb25zLiBUaGVuLCBpdCByZW5kZXJzIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW8gPSAxO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG5cbiAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHcgKiBwaXhlbFJhdGlvKSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWxzLCBub2RlcyBhbmQgZWRnZXMgcmVuZGVyZXJzIGFyZSBzdG9yZWQgaW4gdGhlIHRocmVlIGZvbGxvd2luZ1xuICAgKiBvYmplY3RzLiBXaGVuIGFuIGVsZW1lbnQgaXMgZHJhd24sIGl0cyB0eXBlIHdpbGwgYmUgY2hlY2tlZCBhbmQgaWYgYVxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXG4gICAqIGRlZmF1bHQgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vc3ZnXCIgZm9sZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubm9kZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubGFiZWxzJyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvLyBDaGVjayBpZiBXZWJHTCBpcyBlbmFibGVkOlxuICB2YXIgY2FudmFzLFxuICAgICAgd2ViZ2wgPSAhIWdsb2JhbC5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gIGlmICh3ZWJnbCkge1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRyeSB7XG4gICAgICB3ZWJnbCA9ICEhKFxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fFxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2ViZ2wgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBDb3B5IHRoZSBnb29kIHJlbmRlcmVyOlxuICBzaWdtYS5yZW5kZXJlcnMuZGVmID0gd2ViZ2wgP1xuICAgIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA6XG4gICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcztcbn0pKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG5vZGUgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IG5vZGVzIGFzIGRpc2NzLCBzaGFwZWQgaW4gdHJpYW5nbGVzIHdpdGhcbiAgICogdGhlIGdsLlRSSUFOR0xFUyBkaXNwbGF5IG1vZGUuIFNvLCB0byBiZSBtb3JlIHByZWNpc2UsIHRvIGRyYXcgb25lIG5vZGUsXG4gICAqIGl0IHdpbGwgc3RvcmUgdGhyZWUgdGltZXMgdGhlIGNlbnRlciBvZiBub2RlLCB3aXRoIHRoZSBjb2xvciBhbmQgdGhlIHNpemUsXG4gICAqIGFuZCBhbiBhbmdsZSBpbmRpY2F0aW5nIHdoaWNoIFwiY29ybmVyXCIgb2YgdGhlIHRyaWFuZ2xlIHRvIGRyYXcuXG4gICAqXG4gICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZG9lcyBub3QgZGVhbCB3aXRoIGFudGktYWxpYXNpbmcsIHNvIG1ha2Ugc3VyZSB0aGF0XG4gICAqIHlvdSBkZWFsIHdpdGggaXQgc29tZXdoZXJlIGVsc2UgaW4gdGhlIGNvZGUgKGJ5IGRlZmF1bHQsIHRoZSBXZWJHTFxuICAgKiByZW5kZXJlciB3aWxsIG92ZXJzYW1wbGUgdGhlIHJlbmRlcmluZyB0aHJvdWdoIHRoZSB3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvXG4gICAqIHZhbHVlKS5cbiAgICovXG4gIHNpZ21hLndlYmdsLm5vZGVzLmRlZiA9IHtcbiAgICBQT0lOVFM6IDMsXG4gICAgQVRUUklCVVRFUzogNSxcbiAgICBhZGROb2RlOiBmdW5jdGlvbihub2RlLCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKFxuICAgICAgICBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJylcbiAgICAgICk7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gMDtcblxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgICBkYXRhW2krK10gPSAyICogTWF0aC5QSSAvIDM7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gNCAqIE1hdGguUEkgLyAzO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyksXG4gICAgICAgICAgc2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3NpemUnKSxcbiAgICAgICAgICBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgYW5nbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9hbmdsZScpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFuZ2xlTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIHNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTJcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBhbmdsZUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTZcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcbiAgICAgICAgICAndmFyeWluZyB2ZWMyIGNlbnRlcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHJhZGl1czsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XG4gICAgICAgICAgICAncmFkaXVzID0gYV9zaXplICogdV9yYXRpbzsnLFxuXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ3ZlYzIgcG9zaXRpb24gPSAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eTsnLFxuICAgICAgICAgICAgLy8gJ2NlbnRlciA9IChwb3NpdGlvbiAvIHVfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKTsnLFxuICAgICAgICAgICAgJ2NlbnRlciA9IHBvc2l0aW9uICogdV9zY2FsZTsnLFxuICAgICAgICAgICAgJ2NlbnRlciA9IHZlYzIoY2VudGVyLngsIHVfc2NhbGUgKiB1X3Jlc29sdXRpb24ueSAtIGNlbnRlci55KTsnLFxuXG4gICAgICAgICAgICAncG9zaXRpb24gPSBwb3NpdGlvbiArJyxcbiAgICAgICAgICAgICAgJzIuMCAqIHJhZGl1cyAqIHZlYzIoY29zKGFfYW5nbGUpLCBzaW4oYV9hbmdsZSkpOycsXG4gICAgICAgICAgICAncG9zaXRpb24gPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSk7JyxcblxuICAgICAgICAgICAgJ3JhZGl1cyA9IHJhZGl1cyAqIHVfc2NhbGU7JyxcblxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMCwgMSk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcbiAgICAgICAgICAndmFyeWluZyBmbG9hdCByYWRpdXM7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAndmVjNCBjb2xvcjAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7JyxcblxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX0ZyYWdDb29yZC54eSAtIGNlbnRlcjsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGRpZmYgPSByYWRpdXMgLSBzcXJ0KG0ueCAqIG0ueCArIG0ueSAqIG0ueSk7JyxcblxuICAgICAgICAgICAgLy8gSGVyZSBpcyBob3cgd2UgZHJhdyBhIGRpc2MgaW5zdGVhZCBvZiBhIHNxdWFyZTpcbiAgICAgICAgICAgICdpZiAoZGlmZiA+IDAuMCknLFxuICAgICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAgICdlbHNlJyxcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBpbiB0aGUgZmFzdGVzdCB3YXk6IE5vZGVzIGFyZSBiYXNpY1xuICAgKiBzcXVhcmVzLCBkcmF3biB0aHJvdWdoIHRoZSBnbC5QT0lOVFMgZHJhd2luZyBtZXRob2QuIFRoZSBzaXplIG9mIHRoZSBub2Rlc1xuICAgKiBhcmUgcmVwcmVzZW50ZWQgd2l0aCB0aGUgXCJnbF9Qb2ludFNpemVcIiB2YWx1ZSBpbiB0aGUgdmVydGV4IHNoYWRlci5cbiAgICpcbiAgICogSXQgaXMgdGhlIGZhc3Rlc3Qgbm9kZSByZW5kZXJlciBoZXJlIHNpbmNlIHRoZSBidWZmZXIganVzdCB0YWtlcyBvbmUgbGluZVxuICAgKiB0byBkcmF3IGVhY2ggbm9kZSAod2l0aCBhdHRyaWJ1dGVzIFwieFwiLCBcInlcIiwgXCJzaXplXCIgYW5kIFwiY29sb3JcIikuXG4gICAqXG4gICAqIE5ldmVydGhlbGVzcywgdGhpcyBtZXRob2QgaGFzIHNvbWUgcHJvYmxlbXMsIGVzcGVjaWFsbHkgZHVlIHRvIHNvbWUgaXNzdWVzXG4gICAqIHdpdGggdGhlIGdsLlBPSU5UUzpcbiAgICogIC0gRmlyc3QsIGlmIHRoZSBjZW50ZXIgb2YgYSBub2RlIGlzIG91dHNpZGUgdGhlIHNjZW5lLCB0aGUgcG9pbnQgd2lsbCBub3RcbiAgICogICAgYmUgZHJhd24sIGV2ZW4gaWYgaXQgc2hvdWxkIGJlIHBhcnRseSBvbiBzY3JlZW4uXG4gICAqICAtIEkgdHJpZWQgYXBwbHlpbmcgYSBmcmFnbWVudCBzaGFkZXIgc2ltaWxhciB0byB0aGUgb25lIGluIHRoZSBkZWZhdWx0XG4gICAqICAgIG5vZGUgcmVuZGVyZXIgdG8gZGlzcGxheSB0aGVtIGFzIGRpc2NzLCBidXQgaXQgZGlkIG5vdCB3b3JrIGZpbmUgb25cbiAgICogICAgc29tZSBjb21wdXRlcnMgc2V0dGluZ3MsIGZpbGxpbmcgdGhlIGRpc2NzIHdpdGggd2VpcmQgZ3JhZGllbnRzIG5vdFxuICAgKiAgICBkZXBlbmRpbmcgb24gdGhlIGFjdHVhbCBjb2xvci5cbiAgICovXG4gIHNpZ21hLndlYmdsLm5vZGVzLmZhc3QgPSB7XG4gICAgUE9JTlRTOiAxLFxuICAgIEFUVFJJQlVURVM6IDQsXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuICAgICAgZGF0YVtpKytdID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyksXG4gICAgICAgICAgc2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3NpemUnKSxcbiAgICAgICAgICBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICAxIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG5cbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2l6ZUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIHNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTJcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlBPSU5UUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBNdWx0aXBseSB0aGUgcG9pbnQgc2l6ZSB0d2ljZTpcbiAgICAgICAgICAgIC8vICAtIHggU0NBTElOR19SQVRJTyB0byBjb3JyZWN0IHRoZSBjYW52YXMgc2NhbGluZ1xuICAgICAgICAgICAgLy8gIC0geCAyIHRvIGNvcnJlY3QgdGhlIGZvcm11bGFlXG4gICAgICAgICAgICAnZ2xfUG9pbnRTaXplID0gYV9zaXplICogdV9yYXRpbyAqIHVfc2NhbGUgKiAyLjA7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGJvcmRlciA9IDAuMDE7JyxcbiAgICAgICAgICAgICdmbG9hdCByYWRpdXMgPSAwLjU7JyxcblxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXG4gICAgICAgICAgICAndmVjMiBtID0gZ2xfUG9pbnRDb29yZCAtIHZlYzIoMC41LCAwLjUpOycsXG4gICAgICAgICAgICAnZmxvYXQgZGlzdCA9IHJhZGl1cyAtIHNxcnQobS54ICogbS54ICsgbS55ICogbS55KTsnLFxuXG4gICAgICAgICAgICAnZmxvYXQgdCA9IDAuMDsnLFxuICAgICAgICAgICAgJ2lmIChkaXN0ID4gYm9yZGVyKScsXG4gICAgICAgICAgICAgICd0ID0gMS4wOycsXG4gICAgICAgICAgICAnZWxzZSBpZiAoZGlzdCA+IDAuMCknLFxuICAgICAgICAgICAgICAndCA9IGRpc3QgLyBib3JkZXI7JyxcblxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IG1peChjb2xvcjAsIGNvbG9yLCB0KTsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBsaW5lcyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcbiAgICogdHdvIHRyaWFuZ2xlcyBmb3JtaW5nIHJlY3RhbmdsZXMsIHdpdGggdGhlIGdsLlRSSUFOR0xFUyBkcmF3aW5nIG1vZGUuXG4gICAqXG4gICAqIEl0IGlzIGV4cGVuc2l2ZSwgc2luY2UgZHJhd2luZyBhIHNpbmdsZSBlZGdlIHJlcXVpcmVzIDYgcG9pbnRzLCBlYWNoXG4gICAqIGhhdmluZyA3IGF0dHJpYnV0ZXMgKHNvdXJjZSBwb3NpdGlvbiwgdGFyZ2V0IHBvc2l0aW9uLCB0aGlja25lc3MsIGNvbG9yXG4gICAqIGFuZCBhIGZsYWcgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlIG9mIHRoZSByZWN0YW5nbGUgaXQgaXMpLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wuZWRnZXMuZGVmID0ge1xuICAgIFBPSU5UUzogNixcbiAgICBBVFRSSUJVVEVTOiA3LFxuICAgIGFkZEVkZ2U6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgdyA9IChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSkgLyAyLFxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTEgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB4MiA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgY29sb3IgPSBlZGdlLmNvbG9yO1xuXG4gICAgICBpZiAoIWNvbG9yKVxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzKCdlZGdlQ29sb3InKSkge1xuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGNvbG9yOlxuICAgICAgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKGNvbG9yKTtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24xID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uMScpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24yID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uMicpLFxuICAgICAgICAgIHRoaWNrbmVzc0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RoaWNrbmVzcycpLFxuICAgICAgICAgIG1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaU1pbnVzJyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgcGFyYW1zLnJhdGlvIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKE1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXG4gICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbigtTWF0aC5QSSAvIDIsIHRydWUpXG4gICAgICApO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24xKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24yKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaWNrbmVzc0xvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG1pbnVzTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24xLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjIsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlja25lc3NMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDE2XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihtaW51c0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyNFxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjE7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjI7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdGhpY2tuZXNzOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX21pbnVzOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXG5cbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpTWludXM7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XG4gICAgICAgICAgICAndmVjMiBwb3NpdGlvbiA9IGFfdGhpY2tuZXNzICogdV9yYXRpbyAqJyxcbiAgICAgICAgICAgICAgJ25vcm1hbGl6ZShhX3Bvc2l0aW9uMiAtIGFfcG9zaXRpb24xKTsnLFxuXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSBhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcbiAgICAgICAgICAgICAgJygxLjAgLSBhX21pbnVzKSAqIHVfbWF0cml4SGFsZlBpOycsXG5cbiAgICAgICAgICAgICdwb3NpdGlvbiA9IG1hdHJpeCAqIHBvc2l0aW9uICsgYV9wb3NpdGlvbjE7JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgd2l0aCB0aGUgZ2wuTElORVMgZGlzcGxheVxuICAgKiBtb2RlLiBTaW5jZSB0aGlzIG1vZGUgZG9lcyBub3Qgc3VwcG9ydCB3ZWxsIHRoaWNrbmVzcywgZWRnZXMgYXJlIGFsbCBkcmF3blxuICAgKiB3aXRoIHRoZSBzYW1lIHRoaWNrbmVzcyAoM3B4KSwgaW5kZXBlbmRhbnRseSBvZiB0aGUgZWRnZSBhdHRyaWJ1dGVzIG9yIHRoZVxuICAgKiB6b29taW5nIHJhdGlvLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wuZWRnZXMuZmFzdCA9IHtcbiAgICBQT0lOVFM6IDIsXG4gICAgQVRUUklCVVRFUzogMyxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcblxuICAgICAgZ2wubGluZVdpZHRoKDMpO1xuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuTElORVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXG5cbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgYXJyb3dzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXG4gICAqIHRvIHRoZSB0YXJnZXQgbm9kZS4gVG8gZGVhbCB3aXRoIGVkZ2UgdGhpY2tuZXNzZXMsIHRoZSBsaW5lcyBhcmUgbWFkZSBvZlxuICAgKiB0aHJlZSB0cmlhbmdsZXM6IHR3byBmb3JtaW5nIHJlY3RhbmdsZXMsIHdpdGggdGhlIGdsLlRSSUFOR0xFUyBkcmF3aW5nXG4gICAqIG1vZGUuXG4gICAqXG4gICAqIEl0IGlzIGV4cGVuc2l2ZSwgc2luY2UgZHJhd2luZyBhIHNpbmdsZSBlZGdlIHJlcXVpcmVzIDkgcG9pbnRzLCBlYWNoXG4gICAqIGhhdmluZyBhIGxvdCBvZiBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wuZWRnZXMuYXJyb3cgPSB7XG4gICAgUE9JTlRTOiA5LFxuICAgIEFUVFJJQlVURVM6IDExLFxuICAgIGFkZEVkZ2U6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgdyA9IChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSkgLyAyLFxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTEgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB4MiA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgdGFyZ2V0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIC8vIEFycm93IGhlYWQ6XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gLTEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbjEgPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zMScpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24yID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczInKSxcbiAgICAgICAgICB0aGlja25lc3NMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90aGlja25lc3MnKSxcbiAgICAgICAgICB0YXJnZXRTaXplTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdFNpemUnKSxcbiAgICAgICAgICBkZWxheUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2RlbGF5JyksXG4gICAgICAgICAgbWludXNMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9taW51cycpLFxuICAgICAgICAgIGhlYWRMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9oZWFkJyksXG4gICAgICAgICAgaGVhZFBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZFBvc2l0aW9uJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpJyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpTWludXMnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIG5vZGVSYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9ub2RlUmF0aW8nKSxcbiAgICAgICAgICBhcnJvd0hlYWRMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfYXJyb3dIZWFkJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbixcbiAgICAgICAgTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSkgL1xuICAgICAgICBwYXJhbXMucmF0aW9cbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoYXJyb3dIZWFkTG9jYXRpb24sIDUuMCk7XG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKE1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXG4gICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbigtTWF0aC5QSSAvIDIsIHRydWUpXG4gICAgICApO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMSk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0YXJnZXRTaXplTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZGVsYXlMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShtaW51c0xvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGhlYWRMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShoZWFkUG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMSxcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24yLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGFyZ2V0U2l6ZUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGRlbGF5TG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyNFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDI4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihoZWFkTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAzMlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZFBvc2l0aW9uTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAzNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDQwXG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5UUklBTkdMRVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3BvczE7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MyOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RoaWNrbmVzczsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90U2l6ZTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9kZWxheTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9oZWFkOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2hlYWRQb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9ub2RlUmF0aW87JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X2Fycm93SGVhZDsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGlNaW51czsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZ29vZCBwb2ludDpcbiAgICAgICAgICAgICd2ZWMyIHBvcyA9IG5vcm1hbGl6ZShhX3BvczIgLSBhX3BvczEpOycsXG5cbiAgICAgICAgICAgICdtYXQyIG1hdHJpeCA9ICgxLjAgLSBhX2hlYWQpIConLFxuICAgICAgICAgICAgICAnKCcsXG4gICAgICAgICAgICAgICAgJ2FfbWludXMgKiB1X21hdHJpeEhhbGZQaU1pbnVzICsnLFxuICAgICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaScsXG4gICAgICAgICAgICAgICcpICsgYV9oZWFkICogKCcsXG4gICAgICAgICAgICAgICAgJ2FfaGVhZFBvc2l0aW9uICogdV9tYXRyaXhIYWxmUGlNaW51cyAqIDAuNiArJyxcbiAgICAgICAgICAgICAgICAnKGFfaGVhZFBvc2l0aW9uICogYV9oZWFkUG9zaXRpb24gLSAxLjApICogbWF0MigxLjApJyxcbiAgICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgJ3BvcyA9IGFfcG9zMSArICgnLFxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggYm9keTpcbiAgICAgICAgICAgICAgJygxLjAgLSBhX2hlYWQpICogYV90aGlja25lc3MgKiB1X3JhdGlvICogbWF0cml4ICogcG9zICsnLFxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggaGVhZDpcbiAgICAgICAgICAgICAgJ2FfaGVhZCAqIHVfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvICogbWF0cml4ICogcG9zICsnLFxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggZGVsYXk6XG4gICAgICAgICAgICAgICdhX2RlbGF5ICogcG9zICogKCcsXG4gICAgICAgICAgICAgICAgJ2FfdFNpemUgLyB1X25vZGVSYXRpbyArJyxcbiAgICAgICAgICAgICAgICAndV9hcnJvd0hlYWQgKiBhX3RoaWNrbmVzcyAqIHVfcmF0aW8nLFxuICAgICAgICAgICAgICAnKScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMocG9zLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcblxuICAvKipcbiAgICogVGhpcyBsYWJlbCByZW5kZXJlciB3aWxsIGp1c3QgZGlzcGxheSB0aGUgbGFiZWwgb24gdGhlIHJpZ2h0IG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmxhYmVscy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBmb250U2l6ZSxcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuXG4gICAgaWYgKHNpemUgPCBzZXR0aW5ncygnbGFiZWxUaHJlc2hvbGQnKSlcbiAgICAgIHJldHVybjtcblxuICAgIGlmICghbm9kZS5sYWJlbCB8fCB0eXBlb2Ygbm9kZS5sYWJlbCAhPT0gJ3N0cmluZycpXG4gICAgICByZXR1cm47XG5cbiAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgY29udGV4dC5mb250ID0gKHNldHRpbmdzKCdmb250U3R5bGUnKSA/IHNldHRpbmdzKCdmb250U3R5bGUnKSArICcgJyA6ICcnKSArXG4gICAgICBmb250U2l6ZSArICdweCAnICsgc2V0dGluZ3MoJ2ZvbnQnKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IChzZXR0aW5ncygnbGFiZWxDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxDb2xvcicpO1xuXG4gICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgIG5vZGUubGFiZWwsXG4gICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSxcbiAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKVxuICAgICk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBiYXNpY2FsbHkgZGlzcGxheSB0aGUgbGFiZWwgd2l0aCBhIGJhY2tncm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZiA9IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIHgsXG4gICAgICAgIHksXG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgIGUsXG4gICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAvLyBMYWJlbCBiYWNrZ3JvdW5kOlxuICAgIGNvbnRleHQuZm9udCA9IChmb250U3R5bGUgPyBmb250U3R5bGUgKyAnICcgOiAnJykgK1xuICAgICAgZm9udFNpemUgKyAncHggJyArIChzZXR0aW5ncygnaG92ZXJGb250JykgfHwgc2V0dGluZ3MoJ2ZvbnQnKSk7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MoJ2xhYmVsSG92ZXJCR0NvbG9yJykgPT09ICdub2RlJyA/XG4gICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdEhvdmVyTGFiZWxCR0NvbG9yJyk7XG5cbiAgICBpZiAobm9kZS5sYWJlbCAmJiBzZXR0aW5ncygnbGFiZWxIb3ZlclNoYWRvdycpKSB7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDg7XG4gICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gc2V0dGluZ3MoJ2xhYmVsSG92ZXJTaGFkb3dDb2xvcicpO1xuICAgIH1cblxuICAgIGlmIChub2RlLmxhYmVsICYmIHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICB5ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcbiAgICAgIHcgPSBNYXRoLnJvdW5kKFxuICAgICAgICBjb250ZXh0Lm1lYXN1cmVUZXh0KG5vZGUubGFiZWwpLndpZHRoICsgZm9udFNpemUgLyAyICsgc2l6ZSArIDdcbiAgICAgICk7XG4gICAgICBoID0gTWF0aC5yb3VuZChmb250U2l6ZSArIDQpO1xuICAgICAgZSA9IE1hdGgucm91bmQoZm9udFNpemUgLyAyICsgMik7XG5cbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkgKyBlKTtcbiAgICAgIGNvbnRleHQuYXJjVG8oeCwgeSwgeCArIGUsIHksIGUpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCArIHcsIHkpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCArIHcsIHkgKyBoKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyBlLCB5ICsgaCk7XG4gICAgICBjb250ZXh0LmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIGUsIGUpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCwgeSArIGUpO1xuXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG5cbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICB9XG5cbiAgICAvLyBOb2RlIGJvcmRlcjpcbiAgICBpZiAoc2V0dGluZ3MoJ2JvcmRlclNpemUnKSA+IDApIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdub2RlQm9yZGVyQ29sb3InKSA9PT0gJ25vZGUnID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdE5vZGVCb3JkZXJDb2xvcicpO1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgbm9kZVtwcmVmaXggKyAneSddLFxuICAgICAgICBzaXplICsgc2V0dGluZ3MoJ2JvcmRlclNpemUnKSxcbiAgICAgICAgMCxcbiAgICAgICAgTWF0aC5QSSAqIDIsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgLy8gTm9kZTpcbiAgICB2YXIgbm9kZVJlbmRlcmVyID0gc2lnbWEuY2FudmFzLm5vZGVzW25vZGUudHlwZV0gfHwgc2lnbWEuY2FudmFzLm5vZGVzLmRlZjtcbiAgICBub2RlUmVuZGVyZXIobm9kZSwgY29udGV4dCwgc2V0dGluZ3MpO1xuXG4gICAgLy8gRGlzcGxheSB0aGUgbGFiZWw6XG4gICAgaWYgKG5vZGUubGFiZWwgJiYgdHlwZW9mIG5vZGUubGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxIb3ZlckNvbG9yJyk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICAgIG5vZGUubGFiZWwsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IG5vZGUgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBzaW1wbGUgZGlzYy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuYXJjKFxuICAgICAgbm9kZVtwcmVmaXggKyAneCddLFxuICAgICAgbm9kZVtwcmVmaXggKyAneSddLFxuICAgICAgbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgMCxcbiAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGVkZ2UgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGVkZ2UgYXMgYSBzaW1wbGUgbGluZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2VzLmRlZiA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J11cbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBhcnJvd3MgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2VzLmFycm93ID0gZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxuICAgICAgICB0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBhU2l6ZSA9IE1hdGgubWF4KHNpemUgKiAyLjUsIHNldHRpbmdzKCdtaW5BcnJvd1NpemUnKSksXG4gICAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBzWCwgMikgKyBNYXRoLnBvdyh0WSAtIHNZLCAyKSksXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgYVkgPSBzWSArICh0WSAtIHNZKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICB2WCA9ICh0WCAtIHNYKSAqIGFTaXplIC8gZCxcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICBhWCxcbiAgICAgIGFZXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlkgKiAwLjYsIGFZIC0gdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYIC0gdlkgKiAwLjYsIGFZICsgdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmRlZiA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG4gICAgc2l6ZSAqPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJyk7XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J11cbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmN1cnZlID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcbiAgICAgICAgY3AgPSB7fSxcbiAgICAgICAgc1NpemUgPSBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXTtcblxuICAgIGNwID0gKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSA/XG4gICAgICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCBzU2l6ZSkgOlxuICAgICAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZKTtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNwLngxLCBjcC55MSwgY3AueDIsIGNwLnkyLCB0WCwgdFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AueCwgY3AueSwgdFgsIHRZKTtcbiAgICB9XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuYXJyb3cgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXTtcblxuICAgIHNpemUgPSAoZWRnZS5ob3ZlcikgP1xuICAgICAgc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogc2l6ZSA6IHNpemU7XG4gICAgdmFyIGFTaXplID0gc2l6ZSAqIDIuNSxcbiAgICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyh0WCAtIHNYLCAyKSArIE1hdGgucG93KHRZIC0gc1ksIDIpKSxcbiAgICAgICAgYVggPSBzWCArICh0WCAtIHNYKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICBhWSA9IHNZICsgKHRZIC0gc1kpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIHZYID0gKHRYIC0gc1gpICogYVNpemUgLyBkLFxuICAgICAgICB2WSA9ICh0WSAtIHNZKSAqIGFTaXplIC8gZDtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgYVgsXG4gICAgICBhWVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZWRBcnJvdyA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcbiAgICAgICAgY3AgPSB7fSxcbiAgICAgICAgc2l6ZSA9IHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSksXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgIGQsXG4gICAgICAgIGFTaXplLFxuICAgICAgICBhWCxcbiAgICAgICAgYVksXG4gICAgICAgIHZYLFxuICAgICAgICB2WTtcblxuICAgIGNwID0gKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSA/XG4gICAgICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCB0U2l6ZSkgOlxuICAgICAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZKTtcblxuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyh0WCAtIGNwLngxLCAyKSArIE1hdGgucG93KHRZIC0gY3AueTEsIDIpKTtcbiAgICAgIGFTaXplID0gc2l6ZSAqIDIuNTtcbiAgICAgIGFYID0gY3AueDEgKyAodFggLSBjcC54MSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIGFZID0gY3AueTEgKyAodFkgLSBjcC55MSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIHZYID0gKHRYIC0gY3AueDEpICogYVNpemUgLyBkO1xuICAgICAgdlkgPSAodFkgLSBjcC55MSkgKiBhU2l6ZSAvIGQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyh0WCAtIGNwLngsIDIpICsgTWF0aC5wb3codFkgLSBjcC55LCAyKSk7XG4gICAgICBhU2l6ZSA9IHNpemUgKiAyLjU7XG4gICAgICBhWCA9IGNwLnggKyAodFggLSBjcC54KSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xuICAgICAgYVkgPSBjcC55ICsgKHRZIC0gY3AueSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIHZYID0gKHRYIC0gY3AueCkgKiBhU2l6ZSAvIGQ7XG4gICAgICB2WSA9ICh0WSAtIGNwLnkpICogYVNpemUgLyBkO1xuICAgIH1cblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNwLngyLCBjcC55MiwgY3AueDEsIGNwLnkxLCBhWCwgYVkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AueCwgY3AueSwgYVgsIGFZKTtcbiAgICB9XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmV4dHJlbWl0aWVzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHJlbmRlcmVyIGZvciBob3ZlcmVkIGVkZ2UgZXh0cmVtaXRpZXMuIEl0IHJlbmRlcnMgdGhlIGVkZ2VcbiAgICogZXh0cmVtaXRpZXMgYXMgaG92ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmV4dHJlbWl0aWVzLmRlZiA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgLy8gU291cmNlIE5vZGU6XG4gICAgKFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVyc1tzb3VyY2UudHlwZV0gfHxcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnMuZGVmXG4gICAgKSAoXG4gICAgICBzb3VyY2UsIGNvbnRleHQsIHNldHRpbmdzXG4gICAgKTtcblxuICAgIC8vIFRhcmdldCBOb2RlOlxuICAgIChcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZlxuICAgICkgKFxuICAgICAgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5nc1xuICAgICk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcudXRpbHMnKTtcblxuICAvKipcbiAgICogU29tZSB1c2VmdWwgZnVuY3Rpb25zIHVzZWQgYnkgc2lnbWEncyBTVkcgcmVuZGVyZXIuXG4gICAqL1xuICBzaWdtYS5zdmcudXRpbHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBzaG93LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBlbGVtZW50ICAgVGhlIERPTSBlbGVtZW50IHRvIHNob3cuXG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgaGlkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBoaWRlLlxuICAgICAqL1xuICAgIGhpZGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBub2RlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGRpc2MuXG4gICAqL1xuICBzaWdtYS5zdmcubm9kZXMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2NpcmNsZScpO1xuXG4gICAgICAvLyBEZWZpbmluZyB0aGUgbm9kZSdzIGNpcmNsZVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLW5vZGUtaWQnLCBub2RlLmlkKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctbm9kZScpO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICBudWxsLCAnZmlsbCcsIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSk7XG5cbiAgICAgIC8vIFJldHVybmluZyB0aGUgRE9NIEVsZW1lbnRcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgY2lyY2xlICAgVGhlIG5vZGUgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihub2RlLCBjaXJjbGUsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICAvLyBBcHBseWluZyBjaGFuZ2VzXG4gICAgICAvLyBUT0RPOiBvcHRpbWl6ZSAtIGNoZWNrIGlmIG5lY2Vzc2FyeVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeCcsIG5vZGVbcHJlZml4ICsgJ3gnXSk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5Jywgbm9kZVtwcmVmaXggKyAneSddKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsIG5vZGVbcHJlZml4ICsgJ3NpemUnXSk7XG5cbiAgICAgIC8vIFVwZGF0aW5nIG9ubHkgaWYgbm90IGZyZWVzdHlsZVxuICAgICAgaWYgKCFzZXR0aW5ncygnZnJlZVN0eWxlJykpXG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgICBudWxsLCAnZmlsbCcsIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSk7XG5cbiAgICAgIC8vIFNob3dpbmdcbiAgICAgIGNpcmNsZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGxpbmUuXG4gICAqL1xuICBzaWdtYS5zdmcuZWRnZXMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIHZhciBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnbGluZScpO1xuXG4gICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWVkZ2UtaWQnLCBlZGdlLmlkKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWVkZ2UnKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIGNvbG9yKTtcblxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBsaW5lICAgICAgIFRoZSBsaW5lIERPTSBFbGVtZW50LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihlZGdlLCBsaW5lLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XG5cbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZS13aWR0aCcsIGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gxJywgc291cmNlW3ByZWZpeCArICd4J10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTEnLCBzb3VyY2VbcHJlZml4ICsgJ3knXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MicsIHRhcmdldFtwcmVmaXggKyAneCddKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kyJywgdGFyZ2V0W3ByZWZpeCArICd5J10pO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJ2ZSBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgYmV6aWVyIGN1cnZlLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmVkZ2VzLmN1cnZlID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIHZhciBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAncGF0aCcpO1xuXG4gICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWVkZ2UtaWQnLCBlZGdlLmlkKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWVkZ2UnKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIGNvbG9yKTtcblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBsaW5lICAgICAgIFRoZSBsaW5lIERPTSBFbGVtZW50LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihlZGdlLCBwYXRoLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XG5cbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZS13aWR0aCcsIGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKTtcblxuICAgICAgLy8gQ29udHJvbCBwb2ludFxuICAgICAgdmFyIGN4ID0gKHNvdXJjZVtwcmVmaXggKyAneCddICsgdGFyZ2V0W3ByZWZpeCArICd4J10pIC8gMiArXG4gICAgICAgICh0YXJnZXRbcHJlZml4ICsgJ3knXSAtIHNvdXJjZVtwcmVmaXggKyAneSddKSAvIDQsXG4gICAgICAgICAgY3kgPSAoc291cmNlW3ByZWZpeCArICd5J10gKyB0YXJnZXRbcHJlZml4ICsgJ3knXSkgLyAyICtcbiAgICAgICAgKHNvdXJjZVtwcmVmaXggKyAneCddIC0gdGFyZ2V0W3ByZWZpeCArICd4J10pIC8gNDtcblxuICAgICAgLy8gUGF0aFxuICAgICAgdmFyIHAgPSAnTScgKyBzb3VyY2VbcHJlZml4ICsgJ3gnXSArICcsJyArIHNvdXJjZVtwcmVmaXggKyAneSddICsgJyAnICtcbiAgICAgICAgICAgICAgJ1EnICsgY3ggKyAnLCcgKyBjeSArICcgJyArXG4gICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddICsgJywnICsgdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICAgIC8vIFVwZGF0aW5nIGF0dHJpYnV0ZXNcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBwYXRoLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmxhYmVscycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBsYWJlbCByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbGFiZWwgYXMgYSBzaW1wbGUgdGV4dC5cbiAgICovXG4gIHNpZ21hLnN2Zy5sYWJlbHMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICd0ZXh0Jyk7XG5cbiAgICAgIHZhciBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgICAgdmFyIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcblxuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1sYWJlbC10YXJnZXQnLCBub2RlLmlkKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWxhYmVsJyk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LWZhbWlseScsIHNldHRpbmdzKCdmb250JykpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIGZvbnRDb2xvcik7XG5cbiAgICAgIHRleHQuaW5uZXJIVE1MID0gbm9kZS5sYWJlbDtcbiAgICAgIHRleHQudGV4dENvbnRlbnQgPSBub2RlLmxhYmVsO1xuXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICB0ZXh0ICAgICBUaGUgbGFiZWwgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihub2RlLCB0ZXh0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAgIC8vIENhc2Ugd2hlbiB3ZSBkb24ndCB3YW50IHRvIGRpc3BsYXkgdGhlIGxhYmVsXG4gICAgICBpZiAoIXNldHRpbmdzKCdmb3JjZUxhYmVscycpICYmIHNpemUgPCBzZXR0aW5ncygnbGFiZWxUaHJlc2hvbGQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIFVwZGF0aW5nXG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JyxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMykpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKSk7XG5cbiAgICAgIC8vIFNob3dpbmdcbiAgICAgIHRleHQuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGhvdmVyIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmhvdmVycy5kZWYgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgIG5vZGUgICAgICAgICAgICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Q2FudmFzRWxlbWVudH0gICAgbWVhc3VyZW1lbnRDYW52YXMgIEEgZmFrZSBjYW52YXMgaGFuZGxlZCBieVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdmcgdG8gcGVyZm9ybSBzb21lIG1lYXN1cmVtZW50cyBhbmRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgIG5vZGVDaXJjbGUgICAgICAgICBUaGUgbm9kZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICBzZXR0aW5ncyAgICAgICAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgbm9kZUNpcmNsZSwgbWVhc3VyZW1lbnRDYW52YXMsIHNldHRpbmdzKSB7XG5cbiAgICAgIC8vIERlZmluaW5nIHZpc3VhbCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHcsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBlLFxuICAgICAgICAgIGQsXG4gICAgICAgICAgZm9udFN0eWxlID0gc2V0dGluZ3MoJ2hvdmVyRm9udFN0eWxlJykgfHwgc2V0dGluZ3MoJ2ZvbnRTdHlsZScpLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICAgIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemUsXG4gICAgICAgICAgZm9udENvbG9yID0gKHNldHRpbmdzKCdsYWJlbEhvdmVyQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xuXG4gICAgICAvLyBDcmVhdGluZyBlbGVtZW50c1xuICAgICAgdmFyIGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnZycpLFxuICAgICAgICAgIHJlY3RhbmdsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3JlY3QnKSxcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKSxcbiAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAndGV4dCcpO1xuXG4gICAgICAvLyBEZWZpbmluZyBwcm9wZXJ0aWVzXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXInKTtcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLW5vZGUtaWQnLCBub2RlLmlkKTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIC8vIFRleHRcbiAgICAgICAgdGV4dC5pbm5lckhUTUwgPSBub2RlLmxhYmVsO1xuICAgICAgICB0ZXh0LnRleHRDb250ZW50ID0gbm9kZS5sYWJlbDtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyLWxhYmVsJyk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1mYW1pbHknLCBzZXR0aW5ncygnZm9udCcpKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIGZvbnRDb2xvcik7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLFxuICAgICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsXG4gICAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpKTtcblxuICAgICAgICAvLyBNZWFzdXJlc1xuICAgICAgICAvLyBPUFRJTUlaRTogRmluZCBhIGJldHRlciB3YXkgdGhhbiBhIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgICAgICB4ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICAgIHcgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgIG1lYXN1cmVtZW50Q2FudmFzLm1lYXN1cmVUZXh0KG5vZGUubGFiZWwpLndpZHRoICtcbiAgICAgICAgICAgIGZvbnRTaXplIC8gMiArIHNpemUgKyA5XG4gICAgICAgICk7XG4gICAgICAgIGggPSBNYXRoLnJvdW5kKGZvbnRTaXplICsgNCk7XG4gICAgICAgIGUgPSBNYXRoLnJvdW5kKGZvbnRTaXplIC8gMiArIDIpO1xuXG4gICAgICAgIC8vIENpcmNsZVxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1hcmVhJyk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCBub2RlW3ByZWZpeCArICd4J10pO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5Jywgbm9kZVtwcmVmaXggKyAneSddKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgZSk7XG5cbiAgICAgICAgLy8gUmVjdGFuZ2xlXG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyLWFyZWEnKTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyNmZmYnKTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4Jywgbm9kZVtwcmVmaXggKyAneCddICsgZSAvIDQpO1xuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCBub2RlW3ByZWZpeCArICd5J10gLSBlKTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIHcpO1xuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBlbmRpbmcgY2hpbGRzXG4gICAgICBncm91cC5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQocmVjdGFuZ2xlKTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQobm9kZUNpcmNsZSk7XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taWRkbGV3YXJlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnV0aWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWlkZGxld2FyZSB3aWxsIHJlc2NhbGUgdGhlIGdyYXBoIHN1Y2ggdGhhdCBpdCB0YWtlcyBhbiBvcHRpbWFsIHNwYWNlXG4gICAqIG9uIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQXMgZWFjaCBtaWRkbGV3YXJlLCB0aGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBzY29wZSBvZiB0aGUgc2lnbWFcbiAgICogaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHdyaXRlUHJlZml4IFRoZSB3cml0ZSBwcmVmaXguXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgICAgVGhlIHBhcmFtZXRlcnMuXG4gICAqL1xuICBzaWdtYS5taWRkbGV3YXJlcy5yZXNjYWxlID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgsIG9wdGlvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZCxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIG1hcmdpbixcbiAgICAgICAgbiA9IHRoaXMuZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgZSA9IHRoaXMuZ3JhcGguZWRnZXMoKSxcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgYm91bmRzID0gc2V0dGluZ3MoJ2JvdW5kcycpIHx8IHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMoXG4gICAgICAgICAgdGhpcy5ncmFwaCxcbiAgICAgICAgICByZWFkUHJlZml4LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKSxcbiAgICAgICAgbWluWCA9IGJvdW5kcy5taW5YLFxuICAgICAgICBtaW5ZID0gYm91bmRzLm1pblksXG4gICAgICAgIG1heFggPSBib3VuZHMubWF4WCxcbiAgICAgICAgbWF4WSA9IGJvdW5kcy5tYXhZLFxuICAgICAgICBzaXplTWF4ID0gYm91bmRzLnNpemVNYXgsXG4gICAgICAgIHdlaWdodE1heCA9IGJvdW5kcy53ZWlnaHRNYXgsXG4gICAgICAgIHcgPSBzZXR0aW5ncygnd2lkdGgnKSB8fCAxLFxuICAgICAgICBoID0gc2V0dGluZ3MoJ2hlaWdodCcpIHx8IDEsXG4gICAgICAgIHJlc2NhbGVTZXR0aW5ncyA9IHNldHRpbmdzKCdhdXRvUmVzY2FsZScpLFxuICAgICAgICB2YWxpZFNldHRpbmdzID0ge1xuICAgICAgICAgIG5vZGVQb3NpdGlvbjogMSxcbiAgICAgICAgICBub2RlU2l6ZTogMSxcbiAgICAgICAgICBlZGdlU2l6ZTogMVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBlbGVtZW50cyBzaG91bGQgd2UgcmVzY2FsZT9cbiAgICAgKi9cbiAgICBpZiAoIShyZXNjYWxlU2V0dGluZ3MgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICByZXNjYWxlU2V0dGluZ3MgPSBbJ25vZGVQb3NpdGlvbicsICdub2RlU2l6ZScsICdlZGdlU2l6ZSddO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHJlc2NhbGVTZXR0aW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAoIXZhbGlkU2V0dGluZ3NbcmVzY2FsZVNldHRpbmdzW2ldXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgcmVzY2FsZSBzZXR0aW5nIFwiJyArIHJlc2NhbGVTZXR0aW5nc1tpXSArICdcIiBpcyBub3QgcmVjb2duaXplZC4nXG4gICAgICAgICk7XG5cbiAgICB2YXIgbnAgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVQb3NpdGlvbicpLFxuICAgICAgICBucyA9IH5yZXNjYWxlU2V0dGluZ3MuaW5kZXhPZignbm9kZVNpemUnKSxcbiAgICAgICAgZXMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ2VkZ2VTaXplJyk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCwgd2UgY29tcHV0ZSB0aGUgc2NhbGluZyByYXRpbywgd2l0aG91dCBjb25zaWRlcmluZyB0aGUgc2l6ZXNcbiAgICAgKiBvZiB0aGUgbm9kZXMgOiBFYWNoIG5vZGUgd2lsbCBoYXZlIGl0cyBjZW50ZXIgaW4gdGhlIGNhbnZhcywgYnV0IG1pZ2h0XG4gICAgICogYmUgcGFydGlhbGx5IG91dCBvZiBpdC5cbiAgICAgKi9cbiAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICkgOlxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGVuLCB3ZSBjb3JyZWN0IHRoYXQgc2NhbGluZyByYXRpbyBjb25zaWRlcmluZyBhIG1hcmdpbiwgd2hpY2ggaXNcbiAgICAgKiBiYXNpY2FsbHkgdGhlIHNpemUgb2YgdGhlIGJpZ2dlc3Qgbm9kZS5cbiAgICAgKiBUaGlzIGhhcyB0byBiZSBkb25lIGFzIGEgY29ycmVjdGlvbiBzaW5jZSB0byBjb21wYXJlIHRoZSBzaXplIG9mIHRoZVxuICAgICAqIGJpZ2dlc3Qgbm9kZSB0byB0aGUgWCBhbmQgWSB2YWx1ZXMsIHdlIGhhdmUgdG8gZmlyc3QgZ2V0IGFuXG4gICAgICogYXBwcm94aW1hdGlvbiBvZiB0aGUgc2NhbGluZyByYXRpby5cbiAgICAgKiovXG4gICAgbWFyZ2luID1cbiAgICAgIChcbiAgICAgICAgc2V0dGluZ3MoJ3Jlc2NhbGVJZ25vcmVTaXplJykgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSB8fCBzaXplTWF4KSAvIHNjYWxlXG4gICAgICApICtcbiAgICAgIChzZXR0aW5ncygnc2lkZU1hcmdpbicpIHx8IDApO1xuICAgIG1heFggKz0gbWFyZ2luO1xuICAgIG1pblggLT0gbWFyZ2luO1xuICAgIG1heFkgKz0gbWFyZ2luO1xuICAgIG1pblkgLT0gbWFyZ2luO1xuXG4gICAgLy8gRml4IHRoZSBzY2FsaW5nIHdpdGggdGhlIG5ldyBleHRyZW1hOlxuICAgIHNjYWxlID0gc2V0dGluZ3MoJ3NjYWxpbmdNb2RlJykgPT09ICdvdXRzaWRlJyA/XG4gICAgICBNYXRoLm1heChcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKSA6XG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKTtcblxuICAgIC8vIFNpemUgaG9tb3RoZXRpYyBwYXJhbWV0ZXJzOlxuICAgIGlmICghc2V0dGluZ3MoJ21heE5vZGVTaXplJykgJiYgIXNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XG4gICAgICBhID0gMTtcbiAgICAgIGIgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgPT09IHNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XG4gICAgICBhID0gMDtcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21heE5vZGVTaXplJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgLSBzZXR0aW5ncygnbWluTm9kZVNpemUnKSkgLyBzaXplTWF4O1xuICAgICAgYiA9ICtzZXR0aW5ncygnbWluTm9kZVNpemUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXNldHRpbmdzKCdtYXhFZGdlU2l6ZScpICYmICFzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xuICAgICAgYyA9IDE7XG4gICAgICBkID0gMDtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpID09PSBzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xuICAgICAgYyA9IDA7XG4gICAgICBkID0gK3NldHRpbmdzKCdtaW5FZGdlU2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjID0gKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIC8gd2VpZ2h0TWF4O1xuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcbiAgICB9XG5cbiAgICAvLyBSZXNjYWxlIHRoZSBub2RlcyBhbmQgZWRnZXM6XG4gICAgZm9yIChpID0gMCwgbCA9IGUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgZVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxuICAgICAgICBlW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKGVzID8gYyA6IDEpICsgKGVzID8gZCA6IDApO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9XG4gICAgICAgIG5baV1bcmVhZFByZWZpeCArICdzaXplJ10gKiAobnMgPyBhIDogMSkgKyAobnMgPyBiIDogMCk7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3gnXSA9XG4gICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneCddIC0gKG1heFggKyBtaW5YKSAvIDIpICogKG5wID8gc2NhbGUgOiAxKTtcbiAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAneSddID1cbiAgICAgICAgKG5baV1bcmVhZFByZWZpeCArICd5J10gLSAobWF4WSArIG1pblkpIC8gMikgKiAobnAgPyBzY2FsZSA6IDEpO1xuICAgIH1cbiAgfTtcblxuICBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24oZ3JhcGgsIHByZWZpeCwgZG9FZGdlcykge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBlID0gZ3JhcGguZWRnZXMoKSxcbiAgICAgICAgbiA9IGdyYXBoLm5vZGVzKCksXG4gICAgICAgIHdlaWdodE1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgc2l6ZU1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWluWCA9IEluZmluaXR5LFxuICAgICAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBpZiAoZG9FZGdlcylcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgd2VpZ2h0TWF4ID0gTWF0aC5tYXgoZVtpXVtwcmVmaXggKyAnc2l6ZSddLCB3ZWlnaHRNYXgpO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzaXplTWF4ID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAnc2l6ZSddLCBzaXplTWF4KTtcbiAgICAgIG1heFggPSBNYXRoLm1heChuW2ldW3ByZWZpeCArICd4J10sIG1heFgpO1xuICAgICAgbWluWCA9IE1hdGgubWluKG5baV1bcHJlZml4ICsgJ3gnXSwgbWluWCk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneSddLCBtYXhZKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd5J10sIG1pblkpO1xuICAgIH1cblxuICAgIHdlaWdodE1heCA9IHdlaWdodE1heCB8fCAxO1xuICAgIHNpemVNYXggPSBzaXplTWF4IHx8IDE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0TWF4OiB3ZWlnaHRNYXgsXG4gICAgICBzaXplTWF4OiBzaXplTWF4LFxuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WVxuICAgIH07XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taWRkbGV3YXJlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1pZGRsZXdhcmUgd2lsbCBqdXN0IGNvcHkgdGhlIGdyYXBoaWMgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHs/c3RyaW5nfSByZWFkUHJlZml4ICBUaGUgcmVhZCBwcmVmaXguXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gd3JpdGVQcmVmaXggVGhlIHdyaXRlIHByZWZpeC5cbiAgICovXG4gIHNpZ21hLm1pZGRsZXdhcmVzLmNvcHkgPSBmdW5jdGlvbihyZWFkUHJlZml4LCB3cml0ZVByZWZpeCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhO1xuXG4gICAgaWYgKHdyaXRlUHJlZml4ICsgJycgPT09IHJlYWRQcmVmaXggKyAnJylcbiAgICAgIHJldHVybjtcblxuICAgIGEgPSB0aGlzLmdyYXBoLm5vZGVzKCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3gnXSA9IGFbaV1bcmVhZFByZWZpeCArICd4J107XG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9IGFbaV1bcmVhZFByZWZpeCArICd5J107XG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9IGFbaV1bcmVhZFByZWZpeCArICdzaXplJ107XG4gICAgfVxuXG4gICAgYSA9IHRoaXMuZ3JhcGguZWRnZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9IGFbaV1bcmVhZFByZWZpeCArICdzaXplJ107XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nJyk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRCBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBuZXcgSUQuXG4gICAqL1xuICB2YXIgX2dldElEID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcnICsgKCsraWQpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYW5pbWF0ZXMgYSBjYW1lcmEuIEl0IGhhcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgY2FtZXJhIHRvXG4gICAqIGFuaW1hdGUsIHRoZSB2YWx1ZXMgb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHJlYWNoIGFuZCBldmVudHVhbGx5IHNvbWVcbiAgICogb3B0aW9ucy4gSXQgcmV0dXJucyBhIG51bWJlciBpZCwgdGhhdCB5b3UgY2FuIHVzZSB0byBraWxsIHRoZSBhbmltYXRpb24sXG4gICAqIHdpdGggdGhlIG1ldGhvZCBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsKGlkKS5cbiAgICpcbiAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBkdXJhdGlvbiAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uTmV3RnJhbWUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgYSBuZXcgZnJhbWUuXG4gICAqICAgez9mdW5jdGlvbn0gICAgICAgICAgb25Db21wbGV0ZSBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgYW5pbWF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBjb21wbGV0ZWQgb3Iga2lsbGVkLlxuICAgKiAgIHs/KHN0cmluZ3xmdW5jdGlvbil9IGVhc2luZyAgICAgVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBmcm9tIHRoZSBwYWNrYWdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzLCBvciBhIGN1c3RvbSBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtjYW1lcmF9ICBjYW1lcmEgIFRoZSBjYW1lcmEgdG8gYW5pbWF0ZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgdGFyZ2V0ICBUaGUgY29vcmRpbmF0ZXMgdG8gcmVhY2guXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3QgdG8gc3BlY2lmeSBzb21lIG9wdGlvbnMgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZnVuY3Rpb24uIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50ZWQgaW4gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICBUaGUgYW5pbWF0aW9uIGlkLCB0byBtYWtlIGl0IGVhc3kgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm91Z2ggdGhlIG1ldGhvZCBcInNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxcIi5cbiAgICovXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgdmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKFxuICAgICAgIShjYW1lcmEgaW5zdGFuY2VvZiBzaWdtYS5jbGFzc2VzLmNhbWVyYSkgfHxcbiAgICAgIHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8XG4gICAgICAhdmFsXG4gICAgKVxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5jYW1lcmE6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHZhbC54ICE9PSAnbnVtYmVyJyAmJlxuICAgICAgdHlwZW9mIHZhbC55ICE9PSAnbnVtYmVyJyAmJlxuICAgICAgdHlwZW9mIHZhbC5yYXRpbyAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwuYW5nbGUgIT09ICdudW1iZXInXG4gICAgKVxuICAgICAgdGhyb3cgJ1RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIHZhbGlkIGNvb3JkaW5hdGUgaW4gdGhlIGdpdmVuIHZhbC4nO1xuXG4gICAgdmFyIGZuLFxuICAgICAgICBpZCxcbiAgICAgICAgYW5pbSxcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgaW5pdGlhbFZhbCxcbiAgICAgICAgbyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgIHN0YXJ0ID0gc2lnbWEudXRpbHMuZGF0ZU5vdygpO1xuXG4gICAgLy8gU3RvcmUgaW5pdGlhbCB2YWx1ZXM6XG4gICAgaW5pdGlhbFZhbCA9IHtcbiAgICAgIHg6IGNhbWVyYS54LFxuICAgICAgeTogY2FtZXJhLnksXG4gICAgICByYXRpbzogY2FtZXJhLnJhdGlvLFxuICAgICAgYW5nbGU6IGNhbWVyYS5hbmdsZVxuICAgIH07XG5cbiAgICBkdXJhdGlvbiA9IG8uZHVyYXRpb247XG4gICAgZWFzaW5nID0gdHlwZW9mIG8uZWFzaW5nICE9PSAnZnVuY3Rpb24nID9cbiAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3Nbby5lYXNpbmcgfHwgJ3F1YWRyYXRpY0luT3V0J10gOlxuICAgICAgby5lYXNpbmc7XG5cbiAgICBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvZWYsXG4gICAgICAgICAgdCA9IG8uZHVyYXRpb24gPyAoc2lnbWEudXRpbHMuZGF0ZU5vdygpIC0gc3RhcnQpIC8gby5kdXJhdGlvbiA6IDE7XG5cbiAgICAgIC8vIElmIHRoZSBhbmltYXRpb24gaXMgb3ZlcjpcbiAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FtZXJhLmdvVG8oe1xuICAgICAgICAgIHg6IHZhbC54ICE9PSB1bmRlZmluZWQgPyB2YWwueCA6IGluaXRpYWxWYWwueCxcbiAgICAgICAgICB5OiB2YWwueSAhPT0gdW5kZWZpbmVkID8gdmFsLnkgOiBpbml0aWFsVmFsLnksXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID8gdmFsLnJhdGlvIDogaW5pdGlhbFZhbC5yYXRpbyxcbiAgICAgICAgICBhbmdsZTogdmFsLmFuZ2xlICE9PSB1bmRlZmluZWQgPyB2YWwuYW5nbGUgOiBpbml0aWFsVmFsLmFuZ2xlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgby5vbkNvbXBsZXRlKCk7XG5cbiAgICAgIC8vIEVsc2UsIGxldCdzIGtlZXAgZ29pbmc6XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2VmID0gZWFzaW5nKHQpO1xuICAgICAgICBjYW1lcmEuaXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgIGNhbWVyYS5nb1RvKHtcbiAgICAgICAgICB4OiB2YWwueCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwueCArICh2YWwueCAtIGluaXRpYWxWYWwueCkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwueCxcbiAgICAgICAgICB5OiB2YWwueSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwueSArICh2YWwueSAtIGluaXRpYWxWYWwueSkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwueSxcbiAgICAgICAgICByYXRpbzogdmFsLnJhdGlvICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgaW5pdGlhbFZhbC5yYXRpbyArICh2YWwucmF0aW8gLSBpbml0aWFsVmFsLnJhdGlvKSAqIGNvZWYgOlxuICAgICAgICAgICAgaW5pdGlhbFZhbC5yYXRpbyxcbiAgICAgICAgICBhbmdsZTogdmFsLmFuZ2xlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgaW5pdGlhbFZhbC5hbmdsZSArICh2YWwuYW5nbGUgLSBpbml0aWFsVmFsLmFuZ2xlKSAqIGNvZWYgOlxuICAgICAgICAgICAgaW5pdGlhbFZhbC5hbmdsZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbk5ld0ZyYW1lID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25OZXdGcmFtZSgpO1xuXG4gICAgICAgIGFuaW0uZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlkID0gX2dldElEKCk7XG4gICAgYW5pbSA9IHtcbiAgICAgIGZyYW1lSWQ6IHJlcXVlc3RBbmltYXRpb25GcmFtZShmbiksXG4gICAgICB0YXJnZXQ6IGNhbWVyYSxcbiAgICAgIHR5cGU6ICdjYW1lcmEnLFxuICAgICAgb3B0aW9uczogbyxcbiAgICAgIGZuOiBmblxuICAgIH07XG4gICAgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF0gPSBhbmltO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLaWxscyBhIHJ1bm5pbmcgYW5pbWF0aW9uLiBJdCB0cmlnZ2VycyB0aGUgZXZlbnR1YWwgb25Db21wbGV0ZSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpZCAgVGhlIGlkIG9mIHRoZSBhbmltYXRpb24gdG8ga2lsbC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgUmV0dXJucyB0aGUgc2lnbWEubWlzYy5hbmltYXRpb24gcGFja2FnZS5cbiAgICovXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGwgPSBmdW5jdGlvbihpZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxIHx8IHR5cGVvZiBpZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnYW5pbWF0aW9uLmtpbGw6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgdmFyIG8gPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgIGlmIChvKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tvLmZyYW1lSWRdO1xuXG4gICAgICBpZiAoby50eXBlID09PSAnY2FtZXJhJylcbiAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICBpZiAodHlwZW9mIChvLm9wdGlvbnMgfHwge30pLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEtpbGxzIGV2ZXJ5IHJ1bm5pbmcgYW5pbWF0aW9ucywgb3Igb25seSB0aGUgb25lIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLFxuICAgKiBpZiBhIHN0cmluZyBwYXJhbWV0ZXIgaXMgZ2l2ZW4uXG4gICAqXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfG9iamVjdCl9IGZpbHRlciBBIHN0cmluZyB0byBmaWx0ZXIgdGhlIGFuaW1hdGlvbnMgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIG51bWJlciBvZiBhbmltYXRpb25zIGtpbGxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB3YXkuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIG8sXG4gICAgICAgIGlkLFxuICAgICAgICBjb3VudCA9IDAsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHRhcmdldCA9IHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgcnVubmluZyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmc7XG5cbiAgICBmb3IgKGlkIGluIHJ1bm5pbmcpXG4gICAgICBpZiAoXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxuICAgICAgICAoIXRhcmdldCB8fCBydW5uaW5nW2lkXS50YXJnZXQgPT09IHRhcmdldClcbiAgICAgICkge1xuICAgICAgICBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKG8uZnJhbWVJZCk7XG4gICAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgICAgICBpZiAoby50eXBlID09PSAnY2FtZXJhJylcbiAgICAgICAgICBvLnRhcmdldC5pc0FuaW1hdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXI6XG4gICAgICAgIGNvdW50Kys7XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgICBpZiAodHlwZW9mIChvLm9wdGlvbnMgfHwge30pLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgby5vcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBcInRydWVcIiBpZiBhbnkgYW5pbWF0aW9uIHRoYXQgaXMgY3VycmVudGx5IHN0aWxsIHJ1bm5pbmcgbWF0Y2hlc1xuICAgKiB0aGUgZmlsdGVyIGdpdmVuIHRvIHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfG9iamVjdH0gZmlsdGVyIEEgc3RyaW5nIHRvIGZpbHRlciB0aGUgYW5pbWF0aW9ucyB0byBraWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiB0aGVpciB0eXBlIChleGFtcGxlOiBcImNhbWVyYVwiKSwgb3IgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB0byBmaWx0ZXIgb24gdGhlaXIgdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgICAgUmV0dXJucyB0cnVlIGlmIGFueSBydW5uaW5nIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5cbiAgICovXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmhhcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBpZCxcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgdGFyZ2V0ID0gdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICBydW5uaW5nID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZztcblxuICAgIGZvciAoaWQgaW4gcnVubmluZylcbiAgICAgIGlmIChcbiAgICAgICAgKCF0eXBlIHx8IHJ1bm5pbmdbaWRdLnR5cGUgPT09IHR5cGUpICYmXG4gICAgICAgICghdGFyZ2V0IHx8IHJ1bm5pbmdbaWRdLnRhcmdldCA9PT0gdGFyZ2V0KVxuICAgICAgKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBoZWxwZXIgd2lsbCBiaW5kIGFueSBuby1ET00gcmVuZGVyZXIgKGZvciBpbnN0YW5jZSBjYW52YXMgb3IgV2ViR0wpXG4gICAqIHRvIGl0cyBjYXB0b3JzLCB0byBwcm9wZXJseSBkaXNwYXRjaCB0aGUgZ29vZCBldmVudHMgdG8gdGhlIHNpZ21hIGluc3RhbmNlXG4gICAqIHRvIG1hbmFnZSBjbGlja2luZywgaG92ZXJpbmcgZXRjLi4uXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5iaW5kRXZlbnRzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIG1YLFxuICAgICAgICBtWSxcbiAgICAgICAgY2FwdG9yLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGdldE5vZGVzKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIG1YID0gJ3gnIGluIGUuZGF0YSA/IGUuZGF0YS54IDogbVg7XG4gICAgICAgIG1ZID0gJ3knIGluIGUuZGF0YSA/IGUuZGF0YS55IDogbVk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgbCxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIGluc2VydGVkLFxuICAgICAgICAgIHNlbGVjdGVkID0gW10sXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcbiAgICAgICAgICBtb2RpZmllZFkgPSBtWSArIHNlbGYuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludCA9IHNlbGYuY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgbVgsXG4gICAgICAgICAgICBtWVxuICAgICAgICAgICksXG4gICAgICAgICAgbm9kZXMgPSBzZWxmLmNhbWVyYS5xdWFkdHJlZS5wb2ludChcbiAgICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgICBwb2ludC55XG4gICAgICAgICAgKTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG4gPSBub2Rlc1tpXTtcbiAgICAgICAgICB4ID0gbltwcmVmaXggKyAneCddO1xuICAgICAgICAgIHkgPSBuW3ByZWZpeCArICd5J107XG4gICAgICAgICAgcyA9IG5bcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFuLmhpZGRlbiAmJlxuICAgICAgICAgICAgbW9kaWZpZWRYID4geCAtIHMgJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWCA8IHggKyBzICYmXG4gICAgICAgICAgICBtb2RpZmllZFkgPiB5IC0gcyAmJlxuICAgICAgICAgICAgbW9kaWZpZWRZIDwgeSArIHMgJiZcbiAgICAgICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgICAgTWF0aC5wb3cobW9kaWZpZWRYIC0geCwgMikgK1xuICAgICAgICAgICAgICBNYXRoLnBvdyhtb2RpZmllZFkgLSB5LCAyKVxuICAgICAgICAgICAgKSA8IHNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZTpcbiAgICAgICAgICAgIGluc2VydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzZWxlY3RlZC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgaWYgKG4uc2l6ZSA+IHNlbGVjdGVkW2pdLnNpemUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2UoaiwgMCwgbik7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2gobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEVkZ2VzKGUpIHtcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZW5hYmxlRWRnZUhvdmVyaW5nJykpIHtcbiAgICAgICAgLy8gTm8gZXZlbnQgaWYgdGhlIHNldHRpbmcgaXMgb2ZmOlxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NhbnZhcyA9IChcbiAgICAgICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcyAmJiBzZWxmIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLmNhbnZhcyk7XG5cbiAgICAgIGlmICghaXNDYW52YXMpIHtcbiAgICAgICAgLy8gQSBxdWljayBoYXJkY29kZWQgcnVsZSB0byBwcmV2ZW50IHBlb3BsZSBmcm9tIHVzaW5nIHRoaXMgZmVhdHVyZVxuICAgICAgICAvLyB3aXRoIHRoZSBXZWJHTCByZW5kZXJlciAod2hpY2ggaXMgbm90IGdvb2QgZW5vdWdoIGF0IHRoZSBtb21lbnQpOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBlZGdlIGV2ZW50cyBmZWF0dXJlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFdlYkdMIHJlbmRlcmVyJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xuICAgICAgICBtWSA9ICd5JyBpbiBlLmRhdGEgPyBlLmRhdGEueSA6IG1ZO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBlZGdlLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgbWF4RXBzaWxvbiA9IHNlbGYuc2V0dGluZ3MoJ2VkZ2VIb3ZlclByZWNpc2lvbicpLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgY3AsXG4gICAgICAgICAgbm9kZUluZGV4ID0ge30sXG4gICAgICAgICAgaW5zZXJ0ZWQsXG4gICAgICAgICAgc2VsZWN0ZWQgPSBbXSxcbiAgICAgICAgICBtb2RpZmllZFggPSBtWCArIHNlbGYud2lkdGggLyAyLFxuICAgICAgICAgIG1vZGlmaWVkWSA9IG1ZICsgc2VsZi5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50ID0gc2VsZi5jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBtWCxcbiAgICAgICAgICAgIG1ZXG4gICAgICAgICAgKSxcbiAgICAgICAgICBlZGdlcyA9IFtdO1xuXG4gICAgICBpZiAoaXNDYW52YXMpIHtcbiAgICAgICAgdmFyIG5vZGVzT25TY3JlZW4gPSBzZWxmLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgICAgIHNlbGYuY2FtZXJhLmdldFJlY3RhbmdsZShzZWxmLndpZHRoLCBzZWxmLmhlaWdodClcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChhID0gbm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBub2RlSW5kZXhbYVtpXS5pZF0gPSBhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWRnZXMgPSBzZWxmLmNhbWVyYS5lZGdlcXVhZHRyZWUucG9pbnQoXG4gICAgICAgICAgcG9pbnQueCxcbiAgICAgICAgICBwb2ludC55XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpIHtcbiAgICAgICAgaW5zZXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VsZWN0ZWQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgaWYgKGVkZ2Uuc2l6ZSA+IHNlbGVjdGVkW2pdLnNpemUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnNwbGljZShqLCAwLCBlZGdlKTtcbiAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgIHNlbGVjdGVkLnB1c2goZWRnZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlcy5sZW5ndGgpXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgc291cmNlID0gc2VsZi5ncmFwaC5ub2RlcyhlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2RlcyhlZGdlLnRhcmdldCk7XG4gICAgICAgICAgLy8gKEhBQ0spIHdlIGNhbid0IGdldCBlZGdlW3ByZWZpeCArICdzaXplJ10gb24gV2ViR0wgcmVuZGVyZXI6XG4gICAgICAgICAgcyA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fFxuICAgICAgICAgICAgICBlZGdlWydyZWFkXycgKyBwcmVmaXggKyAnc2l6ZSddO1xuXG4gICAgICAgICAgLy8gRmlyc3QsIGxldCdzIGlkZW50aWZ5IHdoaWNoIGVkZ2VzIGFyZSBkcmF3bi4gVG8gZG8gdGhpcywgd2Uga2VlcFxuICAgICAgICAgIC8vIGV2ZXJ5IGVkZ2VzIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmUgZXh0cmVtaXR5IGRpc3BsYXllZCBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAvLyB0aGUgcXVhZHRyZWUgYW5kIHRoZSBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW5cbiAgICAgICAgICAvLyBlZGdlcy5cbiAgICAgICAgICAvLyBUaGVuLCBsZXQncyBjaGVjayBpZiB0aGUgbW91c2UgaXMgb24gdGhlIGVkZ2UgKHdlIHN1cHBvc2UgdGhhdCBpdFxuICAgICAgICAgIC8vIGlzIGEgbGluZSBzZWdtZW50KS5cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFlZGdlLmhpZGRlbiAmJlxuICAgICAgICAgICAgIXNvdXJjZS5oaWRkZW4gJiYgIXRhcmdldC5oaWRkZW4gJiZcbiAgICAgICAgICAgICghaXNDYW52YXMgfHxcbiAgICAgICAgICAgICAgKG5vZGVJbmRleFtlZGdlLnNvdXJjZV0gfHwgbm9kZUluZGV4W2VkZ2UudGFyZ2V0XSkpICYmXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXREaXN0YW5jZShcbiAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgIG1vZGlmaWVkWSkgPiBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSAmJlxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoXG4gICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gdGFyZ2V0W3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChlZGdlLnR5cGUgPT0gJ2N1cnZlJyB8fCBlZGdlLnR5cGUgPT0gJ2N1cnZlZEFycm93Jykge1xuICAgICAgICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFksXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIGNwLngxLFxuICAgICAgICAgICAgICAgICAgY3AueTEsXG4gICAgICAgICAgICAgICAgICBjcC54MixcbiAgICAgICAgICAgICAgICAgIGNwLnkyLFxuICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uUXVhZHJhdGljQ3VydmUoXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFksXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIGNwLngsXG4gICAgICAgICAgICAgICAgICBjcC55LFxuICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudChcbiAgICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJpbmRDYXB0b3IoY2FwdG9yKSB7XG4gICAgICB2YXIgbm9kZXMsXG4gICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgb3Zlck5vZGVzID0ge30sXG4gICAgICAgICAgb3ZlckVkZ2VzID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGljaycsIGUuZGF0YSk7XG5cbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGljaycsIGUuZGF0YSk7XG5cbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmlnaHRDbGljayhlKSB7XG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlOiBub2RlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrU3RhZ2UnLCB7Y2FwdG9yOiBlLmRhdGF9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25PdXQoZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGssXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGxlLFxuICAgICAgICAgICAgb3V0Tm9kZXMgPSBbXSxcbiAgICAgICAgICAgIG91dEVkZ2VzID0gW107XG5cbiAgICAgICAgZm9yIChrIGluIG92ZXJOb2RlcylcbiAgICAgICAgICBvdXROb2Rlcy5wdXNoKG92ZXJOb2Rlc1trXSk7XG5cbiAgICAgICAgb3Zlck5vZGVzID0ge307XG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBvdXROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXROb2RlJywge1xuICAgICAgICAgICAgbm9kZTogb3V0Tm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0Tm9kZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZXMnLCB7XG4gICAgICAgICAgICBub2Rlczogb3V0Tm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIG92ZXJFZGdlcyA9IHt9O1xuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsZSA9IG91dEVkZ2VzLmxlbmd0aDsgaSA8IGxlOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogb3V0RWRnZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0RWRnZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlczogb3V0RWRnZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk1vdmUoZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgZWRnZSxcbiAgICAgICAgICAgIG5ld091dE5vZGVzID0gW10sXG4gICAgICAgICAgICBuZXdPdmVyTm9kZXMgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnRPdmVyTm9kZXMgPSB7fSxcbiAgICAgICAgICAgIGwgPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICBuZXdPdXRFZGdlcyA9IFtdLFxuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzID0gW10sXG4gICAgICAgICAgICBjdXJyZW50T3ZlckVkZ2VzID0ge30sXG4gICAgICAgICAgICBsZSA9IGVkZ2VzLmxlbmd0aDtcblxuICAgICAgICAvLyBDaGVjayBuZXdseSBvdmVycmVkIG5vZGVzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGN1cnJlbnRPdmVyTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAgIGlmICghb3Zlck5vZGVzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICBuZXdPdmVyTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIG92ZXJOb2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgbm8gbW9yZSBvdmVycmVkIG5vZGVzOlxuICAgICAgICBmb3IgKGsgaW4gb3Zlck5vZGVzKVxuICAgICAgICAgIGlmICghY3VycmVudE92ZXJOb2Rlc1trXSkge1xuICAgICAgICAgICAgbmV3T3V0Tm9kZXMucHVzaChvdmVyTm9kZXNba10pO1xuICAgICAgICAgICAgZGVsZXRlIG92ZXJOb2Rlc1trXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5ld092ZXJOb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5ld092ZXJOb2Rlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZXdPdXROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXROb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbmV3T3V0Tm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3T3Zlck5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGVzOiBuZXdPdmVyTm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3T3V0Tm9kZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlczogbmV3T3V0Tm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrIG5ld2x5IG92ZXJyZWQgZWRnZXM6XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZTsgaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIGN1cnJlbnRPdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgIGlmICghb3ZlckVkZ2VzW2VkZ2UuaWRdKSB7XG4gICAgICAgICAgICBuZXdPdmVyRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIG92ZXJFZGdlc1tlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgbm8gbW9yZSBvdmVycmVkIGVkZ2VzOlxuICAgICAgICBmb3IgKGsgaW4gb3ZlckVkZ2VzKVxuICAgICAgICAgIGlmICghY3VycmVudE92ZXJFZGdlc1trXSkge1xuICAgICAgICAgICAgbmV3T3V0RWRnZXMucHVzaChvdmVyRWRnZXNba10pO1xuICAgICAgICAgICAgZGVsZXRlIG92ZXJFZGdlc1trXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBuZXdPdmVyRWRnZXMubGVuZ3RoOyBpIDwgbGU7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogbmV3T3ZlckVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBuZXdPdXRFZGdlcy5sZW5ndGg7IGkgPCBsZTsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG5ld091dEVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld092ZXJFZGdlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlczogbmV3T3ZlckVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld091dEVkZ2VzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG5ld091dEVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQmluZCBldmVudHM6XG4gICAgICBjYXB0b3IuYmluZCgnY2xpY2snLCBvbkNsaWNrKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZWRvd24nLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNldXAnLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlbW92ZScsIG9uTW92ZSk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2VvdXQnLCBvbk91dCk7XG4gICAgICBjYXB0b3IuYmluZCgnZG91YmxlY2xpY2snLCBvbkRvdWJsZUNsaWNrKTtcbiAgICAgIGNhcHRvci5iaW5kKCdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKTtcbiAgICAgIHNlbGYuYmluZCgncmVuZGVyJywgb25Nb3ZlKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jYXB0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGJpbmRDYXB0b3IodGhpcy5jYXB0b3JzW2ldKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBoZWxwZXIgd2lsbCBiaW5kIGFueSBET00gcmVuZGVyZXIgKGZvciBpbnN0YW5jZSBzdmcpXG4gICAqIHRvIGl0cyBjYXB0b3JzLCB0byBwcm9wZXJseSBkaXNwYXRjaCB0aGUgZ29vZCBldmVudHMgdG8gdGhlIHNpZ21hIGluc3RhbmNlXG4gICAqIHRvIG1hbmFnZSBjbGlja2luZywgaG92ZXJpbmcgZXRjLi4uXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5iaW5kRE9NRXZlbnRzID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGg7XG5cbiAgICAvLyBET01FbGVtZW50IGFic3RyYWN0aW9uXG4gICAgZnVuY3Rpb24gRWxlbWVudChkb21FbGVtZW50KSB7XG5cbiAgICAgIC8vIEhlbHBlcnNcbiAgICAgIHRoaXMuYXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG4gICAgICAgIHJldHVybiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZU5TKG51bGwsIGF0dHJOYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgIHRoaXMudGFnID0gZG9tRWxlbWVudC50YWdOYW1lO1xuICAgICAgdGhpcy5jbGFzcyA9IHRoaXMuYXR0cignY2xhc3MnKTtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmF0dHIoJ2lkJyk7XG5cbiAgICAgIC8vIE1ldGhvZHNcbiAgICAgIHRoaXMuaXNOb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctbm9kZScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5pc0VkZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmlzSG92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3ZlcicpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDbGlja1xuICAgIGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIEdlbmVyaWMgZXZlbnRcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBlKTtcblxuICAgICAgLy8gQXJlIHdlIG9uIGEgbm9kZT9cbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnQoZS50YXJnZXQpO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSlcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWxlbWVudC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tTdGFnZScpO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIERvdWJsZSBjbGlja1xuICAgIGZ1bmN0aW9uIGRvdWJsZUNsaWNrKGUpIHtcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIEdlbmVyaWMgZXZlbnRcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2snLCBlKTtcblxuICAgICAgLy8gQXJlIHdlIG9uIGEgbm9kZT9cbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnQoZS50YXJnZXQpO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSlcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWxlbWVudC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tTdGFnZScpO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIE9uIG92ZXJcbiAgICBmdW5jdGlvbiBvbk92ZXIoZSkge1xuICAgICAgdmFyIHRhcmdldCA9IGUudG9FbGVtZW50IHx8IGUudGFyZ2V0O1xuXG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSB8fCAhdGFyZ2V0KVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KHRhcmdldCk7XG5cbiAgICAgIGlmIChlbC5pc05vZGUoKSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsLmF0dHIoJ2RhdGEtbm9kZS1pZCcpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmlzRWRnZSgpKSB7XG4gICAgICAgIHZhciBlZGdlID0gZ3JhcGguZWRnZXMoZWwuYXR0cignZGF0YS1lZGdlLWlkJykpO1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJFZGdlJywge1xuICAgICAgICAgIGVkZ2U6IGVkZ2UsXG4gICAgICAgICAgc291cmNlOiBncmFwaC5ub2RlcyhlZGdlLnNvdXJjZSksXG4gICAgICAgICAgdGFyZ2V0OiBncmFwaC5ub2RlcyhlZGdlLnRhcmdldClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT24gb3V0XG4gICAgZnVuY3Rpb24gb25PdXQoZSkge1xuICAgICAgdmFyIHRhcmdldCA9IGUuZnJvbUVsZW1lbnQgfHwgZS5vcmlnaW5hbFRhcmdldDtcblxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGVsID0gbmV3IEVsZW1lbnQodGFyZ2V0KTtcblxuICAgICAgaWYgKGVsLmlzTm9kZSgpKSB7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgZWRnZSA9IGdyYXBoLmVkZ2VzKGVsLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlJywge1xuICAgICAgICAgIGVkZ2U6IGVkZ2UsXG4gICAgICAgICAgc291cmNlOiBncmFwaC5ub2RlcyhlZGdlLnNvdXJjZSksXG4gICAgICAgICAgdGFyZ2V0OiBncmFwaC5ub2RlcyhlZGdlLnRhcmdldClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXJpbmcgRXZlbnRzOlxuXG4gICAgLy8gQ2xpY2tcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGljaywgZmFsc2UpO1xuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKGNvbnRhaW5lciwgJ2NsaWNrJywgZG91YmxlQ2xpY2spO1xuXG4gICAgLy8gVG91Y2ggY291bnRlcnBhcnRzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjbGljaywgZmFsc2UpO1xuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKGNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCBkb3VibGVDbGljayk7XG5cbiAgICAvLyBNb3VzZW92ZXJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25PdmVyLCB0cnVlKTtcblxuICAgIC8vIE1vdXNlb3V0XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgb25PdXQsIHRydWUpO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBsaXN0ZW5zIHRvIFwib3Zlck5vZGVcIiwgXCJvdXROb2RlXCIsIFwib3ZlckVkZ2VcIiBhbmQgXCJvdXRFZGdlXCJcbiAgICogZXZlbnRzIGZyb20gYSByZW5kZXJlciBhbmQgcmVuZGVycyB0aGUgbm9kZXMgZGlmZmVyZW50bHkgb24gdGhlIHRvcCBsYXllci5cbiAgICogVGhlIGdvYWwgaXMgdG8gbWFrZSBhbnkgbm9kZSBsYWJlbCByZWFkYWJsZSB3aXRoIHRoZSBtb3VzZSwgYW5kIHRvXG4gICAqIGhpZ2hsaWdodCBob3ZlcmVkIG5vZGVzIGFuZCBlZGdlcy5cbiAgICpcbiAgICogSXQgaGFzIHRvIGJlIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJlbGF0ZWQgcmVuZGVyZXIuXG4gICAqL1xuICBzaWdtYS5taXNjLmRyYXdIb3ZlcnMgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGhvdmVyZWROb2RlcyA9IHt9LFxuICAgICAgICBob3ZlcmVkRWRnZXMgPSB7fTtcblxuICAgIHRoaXMuYmluZCgnb3Zlck5vZGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIG5vZGUgPSBldmVudC5kYXRhLm5vZGU7XG4gICAgICBpZiAoIW5vZGUuaGlkZGVuKSB7XG4gICAgICAgIGhvdmVyZWROb2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIGRyYXcoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgnb3V0Tm9kZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkZWxldGUgaG92ZXJlZE5vZGVzW2V2ZW50LmRhdGEubm9kZS5pZF07XG4gICAgICBkcmF3KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ292ZXJFZGdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBlZGdlID0gZXZlbnQuZGF0YS5lZGdlO1xuICAgICAgaWYgKCFlZGdlLmhpZGRlbikge1xuICAgICAgICBob3ZlcmVkRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICBkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ291dEVkZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZXRlIGhvdmVyZWRFZGdlc1tldmVudC5kYXRhLmVkZ2UuaWRdO1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdyZW5kZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZHJhdygpIHtcblxuICAgICAgdmFyIGssXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBob3ZlcmVkTm9kZSxcbiAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICBjID0gc2VsZi5jb250ZXh0cy5ob3Zlci5jYW52YXMsXG4gICAgICAgICAgZGVmYXVsdE5vZGVUeXBlID0gc2VsZi5zZXR0aW5ncygnZGVmYXVsdE5vZGVUeXBlJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VUeXBlID0gc2VsZi5zZXR0aW5ncygnZGVmYXVsdEVkZ2VUeXBlJyksXG4gICAgICAgICAgbm9kZVJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5ob3ZlcnMsXG4gICAgICAgICAgZWRnZVJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLFxuICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmV4dHJlbWl0aWVzLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICAvLyBDbGVhciBzZWxmLmNvbnRleHRzLmhvdmVyOlxuICAgICAgc2VsZi5jb250ZXh0cy5ob3Zlci5jbGVhclJlY3QoMCwgMCwgYy53aWR0aCwgYy5oZWlnaHQpO1xuXG4gICAgICAvLyBOb2RlIHJlbmRlcjogc2luZ2xlIGhvdmVyXG4gICAgICBpZiAoXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykgJiZcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKSAmJlxuICAgICAgICBPYmplY3Qua2V5cyhob3ZlcmVkTm9kZXMpLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGhvdmVyZWROb2RlID0gaG92ZXJlZE5vZGVzW09iamVjdC5rZXlzKGhvdmVyZWROb2RlcylbMF1dO1xuICAgICAgICAoXG4gICAgICAgICAgbm9kZVJlbmRlcmVyc1tob3ZlcmVkTm9kZS50eXBlXSB8fFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnNbZGVmYXVsdE5vZGVUeXBlXSB8fFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnMuZGVmXG4gICAgICAgICkoXG4gICAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vZGUgcmVuZGVyOiBtdWx0aXBsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpICYmXG4gICAgICAgICFlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpXG4gICAgICApXG4gICAgICAgIGZvciAoayBpbiBob3ZlcmVkTm9kZXMpXG4gICAgICAgICAgKFxuICAgICAgICAgICAgbm9kZVJlbmRlcmVyc1tob3ZlcmVkTm9kZXNba10udHlwZV0gfHxcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnNbZGVmYXVsdE5vZGVUeXBlXSB8fFxuICAgICAgICAgICAgbm9kZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICApKFxuICAgICAgICAgICAgaG92ZXJlZE5vZGVzW2tdLFxuICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAvLyBFZGdlIHJlbmRlcjogc2luZ2xlIGhvdmVyXG4gICAgICBpZiAoXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpICYmXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJykgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoaG92ZXJlZEVkZ2VzKS5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICBob3ZlcmVkRWRnZSA9IGhvdmVyZWRFZGdlc1tPYmplY3Qua2V5cyhob3ZlcmVkRWRnZXMpWzBdXTtcbiAgICAgICAgc291cmNlID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS5zb3VyY2UpO1xuICAgICAgICB0YXJnZXQgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnRhcmdldCk7XG5cbiAgICAgICAgaWYgKCEgaG92ZXJlZEVkZ2UuaGlkZGVuKSB7XG4gICAgICAgICAgKFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tkZWZhdWx0RWRnZVR5cGVdIHx8XG4gICAgICAgICAgICBlZGdlUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICkgKFxuICAgICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoZW1iZWRTZXR0aW5ncygnZWRnZUhvdmVyRXh0cmVtaXRpZXMnKSkge1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVycy5kZWZcbiAgICAgICAgICAgICkoXG4gICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBlZGdlcyByZW5kZXJlZCBvdmVyIG5vZGVzOlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbc291cmNlLnR5cGVdIHx8XG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlc1t0YXJnZXQudHlwZV0gfHxcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZlxuICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRWRnZSByZW5kZXI6IG11bHRpcGxlIGhvdmVyXG4gICAgICBpZiAoXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpICYmXG4gICAgICAgICFlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpXG4gICAgICApIHtcbiAgICAgICAgZm9yIChrIGluIGhvdmVyZWRFZGdlcykge1xuICAgICAgICAgIGhvdmVyZWRFZGdlID0gaG92ZXJlZEVkZ2VzW2tdO1xuICAgICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2Uuc291cmNlKTtcbiAgICAgICAgICB0YXJnZXQgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnRhcmdldCk7XG5cbiAgICAgICAgICBpZiAoIWhvdmVyZWRFZGdlLmhpZGRlbikge1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2hvdmVyZWRFZGdlLnR5cGVdIHx8XG4gICAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VIb3ZlckV4dHJlbWl0aWVzJykpIHtcbiAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzW2hvdmVyZWRFZGdlLnR5cGVdIHx8XG4gICAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgICAgICkoXG4gICAgICAgICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGVkZ2VzIHJlbmRlcmVkIG92ZXIgbm9kZXM6XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbc291cmNlLnR5cGVdIHx8XG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZlxuICAgICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZlxuICAgICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcbiIsIjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCcpO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZTpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5sYXlvdXQubm92ZXJsYXAnKTtcblxuICAvKipcbiAgICogTm92ZXJsYXAgTGF5b3V0XG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICpcbiAgICogQXV0aG9yOiBAYXBpdHRzIC8gQW5kcmV3IFBpdHRzXG4gICAqIEFsZ29yaXRobTogQGphY29teW1hIC8gTWF0aGlldSBKYWNvbXkgKG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgdG8gR2VwaGkgYW5kIHBvcnRlZCB0byBzaWdtYS5qcyB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgYnkgQGFuZHBpdHRzIHdpdGggcGVybWlzc2lvbilcbiAgICogQWNrbm93bGVkZ2VtZW50OiBAc2hleW1hbiAvIFPDqWJhc3RpZW4gSGV5bWFubiAoc29tZSBpbnNwaXJhdGlvbiBoYXMgYmVlbiB0YWtlbiBmcm9tIG90aGVyIE1JVCBsaWNlbnNlZCBsYXlvdXQgYWxnb3JpdGhtcyBhdXRob3JlZCBieSBAc2hleW1hbilcbiAgICogVmVyc2lvbjogMC4xXG4gICAqL1xuXG4gIHZhciBzZXR0aW5ncyA9IHtcbiAgICBzcGVlZDogMyxcbiAgICBzY2FsZU5vZGVzOiAxLjIsXG4gICAgbm9kZU1hcmdpbjogNS4wLFxuICAgIGdyaWRTaXplOiAyMCxcbiAgICBwZXJtaXR0ZWRFeHBhbnNpb246IDEuMSxcbiAgICByZW5kZXJlckluZGV4OiAwLFxuICAgIG1heEl0ZXJhdGlvbnM6IDUwMFxuICB9O1xuXG4gIHZhciBfaW5zdGFuY2UgPSB7fTtcblxuICAvKipcbiAgICogRXZlbnQgZW1pdHRlciBPYmplY3RcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICB2YXIgX2V2ZW50RW1pdHRlciA9IHt9O1xuXG4gICAvKipcbiAgICogTm92ZXJsYXAgT2JqZWN0XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgZnVuY3Rpb24gTm92ZXJsYXAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKHNpZ0luc3QsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICB0aGlzLnNpZ0luc3QgPSBzaWdJbnN0O1xuICAgICAgdGhpcy5jb25maWcgPSBzaWdtYS51dGlscy5leHRlbmQob3B0aW9ucywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXG4gICAgICBpZiAob3B0aW9ucy5ub2Rlcykge1xuICAgICAgICB0aGlzLm5vZGVzID0gb3B0aW9ucy5ub2RlcztcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMubm9kZXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2lnbWEucGx1Z2lucyB8fCB0eXBlb2Ygc2lnbWEucGx1Z2lucy5hbmltYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hLnBsdWdpbnMuYW5pbWF0ZSBpcyBub3QgZGVjbGFyZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhdGVcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaW5nbGUgbGF5b3V0IGl0ZXJhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmF0b21pY0dvID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcgfHwgdGhpcy5pdGVyQ291bnQgPCAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMgfHwgdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCksXG4gICAgICAgICAgbm9kZXNDb3VudCA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgeG1pbiA9IEluZmluaXR5LFxuICAgICAgICAgIHhtYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgeW1pbiA9IEluZmluaXR5LFxuICAgICAgICAgIHltYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgeHdpZHRoLFxuICAgICAgICAgIHloZWlnaHQsXG4gICAgICAgICAgeGNlbnRlcixcbiAgICAgICAgICB5Y2VudGVyLFxuICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGNvbCxcbiAgICAgICAgICBtaW5YQm94LFxuICAgICAgICAgIG1heFhCb3gsXG4gICAgICAgICAgbWluWUJveCxcbiAgICAgICAgICBtYXhZQm94LFxuICAgICAgICAgIGFkamFjZW50Tm9kZXMsXG4gICAgICAgICAgc3ViUm93LFxuICAgICAgICAgIHN1YkNvbCxcbiAgICAgICAgICBueG1pbixcbiAgICAgICAgICBueG1heCxcbiAgICAgICAgICBueW1pbixcbiAgICAgICAgICBueW1heDtcblxuICAgICAgdGhpcy5pdGVyQ291bnQtLTtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xuICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgIG4uZG4uZHggPSAwO1xuICAgICAgICBuLmRuLmR5ID0gMDtcblxuICAgICAgICAvL0ZpbmQgdGhlIG1pbiBhbmQgbWF4IGZvciBib3RoIHggYW5kIHkgYWNyb3NzIGFsbCBub2Rlc1xuICAgICAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgbi5kbl94IC0gKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKTtcbiAgICAgICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIG4uZG5feCArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XG4gICAgICAgIHltaW4gPSBNYXRoLm1pbih5bWluLCBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xuICAgICAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgbi5kbl95ICsgKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKTtcblxuICAgICAgfVxuXG4gICAgICB4d2lkdGggPSB4bWF4IC0geG1pbjtcbiAgICAgIHloZWlnaHQgPSB5bWF4IC0geW1pbjtcbiAgICAgIHhjZW50ZXIgPSAoeG1pbiArIHhtYXgpIC8gMjtcbiAgICAgIHljZW50ZXIgPSAoeW1pbiArIHltYXgpIC8gMjtcbiAgICAgIHhtaW4gPSB4Y2VudGVyIC0gc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnh3aWR0aCAvIDI7XG4gICAgICB4bWF4ID0geGNlbnRlciArIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip4d2lkdGggLyAyO1xuICAgICAgeW1pbiA9IHljZW50ZXIgLSBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeWhlaWdodCAvIDI7XG4gICAgICB5bWF4ID0geWNlbnRlciArIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip5aGVpZ2h0IC8gMjtcblxuICAgICAgZ3JpZCA9IHt9OyAvL0FuIG9iamVjdCBvZiBvYmplY3RzIHdoZXJlIGdyaWRbcm93XVtjb2xdIGlzIGFuIGFycmF5IG9mIG5vZGUgaWRzIHJlcHJlc2VudGluZyBub2RlcyB0aGF0IGZhbGwgaW4gdGhhdCBncmlkLiBOb2RlcyBjYW4gZmFsbCBpbiBtb3JlIHRoYW4gb25lIGdyaWRcblxuICAgICAgZm9yKHJvdyA9IDA7IHJvdyA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyByb3crKykge1xuICAgICAgICBncmlkW3Jvd10gPSB7fTtcbiAgICAgICAgZm9yKGNvbCA9IDA7IGNvbCA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyBjb2wrKykge1xuICAgICAgICAgIGdyaWRbcm93XVtjb2xdID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9QbGFjZSBub2RlcyBpbiBncmlkXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xuICAgICAgICBuID0gbm9kZXNbaV07XG5cbiAgICAgICAgbnhtaW4gPSBuLmRuX3ggLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnhtYXggPSBuLmRuX3ggKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnltaW4gPSBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnltYXggPSBuLmRuX3kgKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcblxuICAgICAgICBtaW5YQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG54bWluIC0geG1pbikgLyAoeG1heCAtIHhtaW4pICk7XG4gICAgICAgIG1heFhCb3ggPSBNYXRoLmZsb29yKHNlbGYuY29uZmlnLmdyaWRTaXplKiAobnhtYXggLSB4bWluKSAvICh4bWF4IC0geG1pbikgKTtcbiAgICAgICAgbWluWUJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueW1pbiAtIHltaW4pIC8gKHltYXggLSB5bWluKSApO1xuICAgICAgICBtYXhZQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG55bWF4IC0geW1pbikgLyAoeW1heCAtIHltaW4pICk7XG4gICAgICAgIGZvcihjb2wgPSBtaW5YQm94OyBjb2wgPD0gbWF4WEJveDsgY29sKyspIHtcbiAgICAgICAgICBmb3Iocm93ID0gbWluWUJveDsgcm93IDw9IG1heFlCb3g7IHJvdysrKSB7XG4gICAgICAgICAgICBncmlkW3Jvd11bY29sXS5wdXNoKG4uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIGFkamFjZW50Tm9kZXMgPSB7fTsgLy9BbiBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIG5vZGUgaWRzIG9mIGFkamFjZW50IG5vZGVzIChlaXRoZXIgaW4gc2FtZSBncmlkIGJveCBvciBhZGphY2VudCBncmlkIGJveCkgZm9yIGFsbCBub2Rlc1xuXG4gICAgICBmb3Iocm93ID0gMDsgcm93IDwgc2VsZi5jb25maWcuZ3JpZFNpemU7IHJvdysrKSB7XG4gICAgICAgIGZvcihjb2wgPSAwOyBjb2wgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgY29sKyspIHtcbiAgICAgICAgICBncmlkW3Jvd11bY29sXS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYoIWFkamFjZW50Tm9kZXNbbm9kZUlkXSkge1xuICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihzdWJSb3cgPSBNYXRoLm1heCgwLCByb3cgLSAxKTsgc3ViUm93IDw9IE1hdGgubWluKHJvdyArIDEsIHNlbGYuY29uZmlnLmdyaWRTaXplIC0gMSk7IHN1YlJvdysrKSB7XG4gICAgICAgICAgICAgIGZvcihzdWJDb2wgPSBNYXRoLm1heCgwLCBjb2wgLSAxKTsgc3ViQ29sIDw9IE1hdGgubWluKGNvbCArIDEsICBzZWxmLmNvbmZpZy5ncmlkU2l6ZSAtIDEpOyBzdWJDb2wrKykge1xuICAgICAgICAgICAgICAgIGdyaWRbc3ViUm93XVtzdWJDb2xdLmZvckVhY2goZnVuY3Rpb24oc3ViTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICBpZihzdWJOb2RlSWQgIT09IG5vZGVJZCAmJiBhZGphY2VudE5vZGVzW25vZGVJZF0uaW5kZXhPZihzdWJOb2RlSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0ucHVzaChzdWJOb2RlSWQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9JZiB0d28gbm9kZXMgb3ZlcmxhcCB0aGVuIHJlcHVsc2UgdGhlbVxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcbiAgICAgICAgbjEgPSBub2Rlc1tpXTtcbiAgICAgICAgYWRqYWNlbnROb2Rlc1tuMS5pZF0uZm9yRWFjaChmdW5jdGlvbihub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbjIgPSBzZWxmLnNpZ0luc3QuZ3JhcGgubm9kZXMobm9kZUlkKTtcbiAgICAgICAgICB2YXIgeERpc3QgPSBuMi5kbl94IC0gbjEuZG5feDtcbiAgICAgICAgICB2YXIgeURpc3QgPSBuMi5kbl95IC0gbjEuZG5feTtcbiAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCh4RGlzdCp4RGlzdCArIHlEaXN0KnlEaXN0KTtcbiAgICAgICAgICB2YXIgY29sbGlzaW9uID0gKGRpc3QgPCAoKG4xLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICsgKG4yLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pKSk7XG4gICAgICAgICAgaWYoY29sbGlzaW9uKSB7XG4gICAgICAgICAgICBzZWxmLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgbjIuZG4uZHggKz0geERpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcbiAgICAgICAgICAgICAgbjIuZG4uZHkgKz0geURpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG4yLmRuLmR4ICs9IHh3aWR0aCAqIDAuMDEgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICAgIG4yLmRuLmR5ICs9IHloZWlnaHQgKiAwLjAxICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaT0wOyBpIDwgbm9kZXNDb3VudDsgaSsrKSB7XG4gICAgICAgIG4gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYoIW4uZml4ZWQpIHtcbiAgICAgICAgICBuLmRuX3ggPSBuLmRuX3ggKyBuLmRuLmR4ICogMC4xICogc2VsZi5jb25maWcuc3BlZWQ7XG4gICAgICAgICAgbi5kbl95ID0gbi5kbl95ICsgbi5kbi5keSAqIDAuMSAqIHNlbGYuY29uZmlnLnNwZWVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMucnVubmluZyAmJiB0aGlzLml0ZXJDb3VudCA8IDEpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfTtcblxuICAgIHRoaXMuZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLml0ZXJDb3VudCA9IHRoaXMuY29uZmlnLm1heEl0ZXJhdGlvbnM7XG5cbiAgICAgIHdoaWxlICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5hdG9taWNHbygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHJldHVybjtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCk7XG5cbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLnNpZ0luc3QucmVuZGVyZXJzW3NlbGYuY29uZmlnLnJlbmRlcmVySW5kZXhdLm9wdGlvbnMucHJlZml4O1xuXG4gICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAvLyBJbml0IG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGVzW2ldLmRuX3ggPSBub2Rlc1tpXVtwcmVmaXggKyAneCddO1xuICAgICAgICBub2Rlc1tpXS5kbl95ID0gbm9kZXNbaV1bcHJlZml4ICsgJ3knXTtcbiAgICAgICAgbm9kZXNbaV0uZG5fc2l6ZSA9IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ107XG4gICAgICAgIG5vZGVzW2ldLmRuID0ge1xuICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgIGR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RhcnQnKTtcbiAgICAgIHRoaXMuZ28oKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLnNpZ0luc3QuZ3JhcGgubm9kZXMoKTtcblxuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmVhc2luZykge1xuICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnaW50ZXJwb2xhdGUnKTtcbiAgICAgICAgc2lnbWEucGx1Z2lucy5hbmltYXRlKFxuICAgICAgICAgIHNlbGYuc2lnSW5zdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB4OiAnZG5feCcsXG4gICAgICAgICAgICB5OiAnZG5feSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZzogc2VsZi5lYXNpbmcsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5zaWdJbnN0LnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGVzW2ldLmRuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbl94ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbl95ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RvcCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzZWxmLmR1cmF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEFwcGx5IGNoYW5nZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzW2ldLnggPSBub2Rlc1tpXS5kbl94O1xuICAgICAgICAgIG5vZGVzW2ldLnkgPSBub2Rlc1tpXS5kbl95O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaWdJbnN0LnJlZnJlc2goKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXNbaV0uZG4gPSBudWxsO1xuICAgICAgICAgIG5vZGVzW2ldLmRuX3ggPSBudWxsO1xuICAgICAgICAgIG5vZGVzW2ldLmRuX3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF9ldmVudEVtaXR0ZXJbc2VsZi5zaWdJbnN0LmlkXS5kaXNwYXRjaEV2ZW50KCdzdG9wJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zaWdJbnN0ID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuZWFzaW5nID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2VcbiAgICogLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBsYXlvdXQgYWxnb3JpdGhtLlxuXG4gICAqIFJlY29nbml6ZWQgb3B0aW9uczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVyIGluIHRoZSBzZXR0aW5nc1xuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNjYWxlTm9kZXMgICAgICAgICAgVGhlIHJhdGlvIHRvIHNjYWxlIG5vZGVzIGJ5IC0gYSBsYXJnZXIgcmF0aW8gd2lsbCBsZWFkIHRvIG1vcmUgc3BhY2UgYXJvdW5kIGxhcmdlciBub2Rlc1xuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgZ3JpZFNpemUgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgdG8gdXNlIHdoZW4gcGFydGlvbmluZyBub2RlcyBpbnRvIGEgZ3JpZCBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgICAgICAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGUgc2lnbWEudXRpbHMuZWFzaW5ncyBwYWNrYWdlIG9yIGEgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnICBUaGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmNvbmZpZ05vdmVybGFwID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGFyZ3VtZW50OiBcImNvbmZpZ1wiJyk7XG5cbiAgICAvLyBDcmVhdGUgaW5zdGFuY2UgaWYgdW5kZWZpbmVkXG4gICAgaWYgKCFfaW5zdGFuY2Vbc2lnSW5zdC5pZF0pIHtcbiAgICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXSA9IG5ldyBOb3ZlcmxhcCgpO1xuXG4gICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0ge307XG4gICAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF0pO1xuXG4gICAgICAvLyBCaW5kaW5nIG9uIGtpbGwgdG8gY2xlYXIgdGhlIHJlZmVyZW5jZXNcbiAgICAgIHNpZ0luc3QuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0ua2lsbCgpO1xuICAgICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gPSBudWxsO1xuICAgICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5pbml0KHNpZ0luc3QsIGNvbmZpZyk7XG5cbiAgICByZXR1cm4gX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgdGhlIGxheW91dCBhbGdvcml0aG0uIEl0IHdpbGwgdXNlIHRoZSBleGlzdGluZyBjb25maWd1cmF0aW9uIGlmIG5vXG4gICAqIG5ldyBjb25maWd1cmF0aW9uIGlzIHBhc3NlZC5cblxuICAgKiBSZWNvZ25pemVkIG9wdGlvbnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlciBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNjYWxlTm9kZXMgICAgICAgICAgVGhlIHJhdGlvIHRvIHNjYWxlIG5vZGVzIGJ5IC0gYSBsYXJnZXIgcmF0aW8gd2lsbCBsZWFkIHRvIG1vcmUgc3BhY2UgYXJvdW5kIGxhcmdlciBub2Rlc1xuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgZ3JpZFNpemUgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgdG8gdXNlIHdoZW4gcGFydGlvbmluZyBub2RlcyBpbnRvIGEgZ3JpZCBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgICAgICAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGUgc2lnbWEudXRpbHMuZWFzaW5ncyBwYWNrYWdlIG9yIGEgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnICBUaGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxuICAgKi9cblxuICBzaWdtYS5wcm90b3R5cGUuc3RhcnROb3ZlcmxhcCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgdmFyIHNpZ0luc3QgPSB0aGlzO1xuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWdOb3ZlcmxhcChzaWdJbnN0LCBjb25maWcpO1xuICAgIH1cblxuICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5zdGFydCgpO1xuXG4gICAgcmV0dXJuIF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGhhcyBzdGFydGVkIGFuZCBpcyBub3QgY29tcGxldGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmlzTm92ZXJsYXBSdW5uaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XG5cbiAgICByZXR1cm4gISFfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gJiYgX2luc3RhbmNlW3NpZ0luc3QuaWRdLnJ1bm5pbmc7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7IiwiLyoqXG4gKiBUaGlzIHBsdWdpbiBwcm92aWRlcyBhIG1ldGhvZCB0byBhbmltYXRlIGEgc2lnbWEgaW5zdGFuY2UgYnkgaW50ZXJwb2xhdGluZ1xuICogc29tZSBub2RlIHByb3BlcnRpZXMuIENoZWNrIHRoZSBzaWdtYS5wbHVnaW5zLmFuaW1hdGUgZnVuY3Rpb24gZG9jIG9yIHRoZVxuICogZXhhbXBsZXMvYW5pbWF0ZS5odG1sIGNvZGUgc2FtcGxlIHRvIGtub3cgbW9yZS5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5wbHVnaW5zJyk7XG5cbiAgdmFyIF9pZCA9IDAsXG4gICAgICBfY2FjaGUgPSB7fTtcblxuICAvLyBUT09MSU5HIEZVTkNUSU9OUzpcbiAgLy8gKioqKioqKioqKioqKioqKioqXG4gIGZ1bmN0aW9uIHBhcnNlQ29sb3IodmFsKSB7XG4gICAgaWYgKF9jYWNoZVt2YWxdKVxuICAgICAgcmV0dXJuIF9jYWNoZVt2YWxdO1xuXG4gICAgdmFyIHJlc3VsdCA9IFswLCAwLCAwXTtcblxuICAgIGlmICh2YWwubWF0Y2goL14jLykpIHtcbiAgICAgIHZhbCA9ICh2YWwgfHwgJycpLnJlcGxhY2UoL14jLywgJycpO1xuICAgICAgcmVzdWx0ID0gKHZhbC5sZW5ndGggPT09IDMpID9cbiAgICAgICAgW1xuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDApLCAxNiksXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KSxcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgyKSwgMTYpXG4gICAgICAgIF0gOlxuICAgICAgICBbXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgwKSArIHZhbC5jaGFyQXQoMSksIDE2KSxcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpLFxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoNCkgKyB2YWwuY2hhckF0KDUpLCAxNilcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XG4gICAgICB2YWwgPSB2YWwubWF0Y2goXG4gICAgICAgIC9eICpyZ2JhPyAqXFwoICooWzAtOV0qKSAqLCAqKFswLTldKikgKiwgKihbMC05XSopICooLC4qKT9cXCkgKiQvXG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gW1xuICAgICAgICArdmFsWzFdLFxuICAgICAgICArdmFsWzJdLFxuICAgICAgICArdmFsWzNdXG4gICAgICBdO1xuICAgIH1cblxuICAgIF9jYWNoZVt2YWxdID0ge1xuICAgICAgcjogcmVzdWx0WzBdLFxuICAgICAgZzogcmVzdWx0WzFdLFxuICAgICAgYjogcmVzdWx0WzJdXG4gICAgfTtcblxuICAgIHJldHVybiBfY2FjaGVbdmFsXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3JzKGMxLCBjMiwgcCkge1xuICAgIGMxID0gcGFyc2VDb2xvcihjMSk7XG4gICAgYzIgPSBwYXJzZUNvbG9yKGMyKTtcblxuICAgIHZhciBjID0ge1xuICAgICAgcjogYzEuciAqICgxIC0gcCkgKyBjMi5yICogcCxcbiAgICAgIGc6IGMxLmcgKiAoMSAtIHApICsgYzIuZyAqIHAsXG4gICAgICBiOiBjMS5iICogKDEgLSBwKSArIGMyLmIgKiBwXG4gICAgfTtcblxuICAgIHJldHVybiAncmdiKCcgKyBbYy5yIHwgMCwgYy5nIHwgMCwgYy5iIHwgMF0uam9pbignLCcpICsgJyknO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbmltYXRlIHNvbWUgc3BlY2lmaWVkIG5vZGUgcHJvcGVydGllcy4gSXQgd2lsbFxuICAgKiBiYXNpY2FsbHkgY2FsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGludGVycG9sYXRlIHRoZSB2YWx1ZXMgYW5kIGNhbGwgdGhlXG4gICAqIHJlZnJlc2ggbWV0aG9kIGR1cmluZyBhIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBzZXR0aW5nc1xuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9hcnJheX0gICAgICAgICAgICAgbm9kZXMgICAgICBBbiBhcnJheSBvZiBub2RlIG9iamVjdHMgb3Igbm9kZSBpZHMuIElmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3Qgc3BlY2lmaWVkLCBhbGwgbm9kZXMgb2YgdGhlIGdyYXBoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGFuaW1hdGVkLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3MgcGFja2FnZSBvciBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNJbk91dCBlYXNpbmcgZnJvbSB0aGlzIHBhY2thZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCB0aGUgXCJhbmltYXRpb25zVGltZVwiIHNldHRpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIG9mIHRoZSBzaWdtYSBpbnN0YW5jZSB3aWxsIGJlIHVzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RlYWQuXG4gICAqICAgez9mdW5jdGlvbn0gICAgICAgICAgb25Db21wbGV0ZSBFdmVudHVhbGx5IGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uIGlzIGVuZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gICBzICAgICAgIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBhbmltYXRlIEFuIGhhc2ggd2l0aCB0aGUga2V5cyBiZWluZyB0aGUgbm9kZSBwcm9wZXJ0aWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gaW50ZXJwb2xhdGUsIGFuZCB0aGUgdmFsdWVzIGJlaW5nIHRoZSByZWxhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0IHZhbHVlcy5cbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gICAqL1xuICBzaWdtYS5wbHVnaW5zLmFuaW1hdGUgPSBmdW5jdGlvbihzLCBhbmltYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBpZCA9ICsrX2lkLFxuICAgICAgICBkdXJhdGlvbiA9IG8uZHVyYXRpb24gfHwgcy5zZXR0aW5ncygnYW5pbWF0aW9uc1RpbWUnKSxcbiAgICAgICAgZWFzaW5nID0gdHlwZW9mIG8uZWFzaW5nID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5nc1tvLmVhc2luZ10gOlxuICAgICAgICAgIHR5cGVvZiBvLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgby5lYXNpbmcgOlxuICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljSW5PdXQsXG4gICAgICAgIHN0YXJ0ID0gc2lnbWEudXRpbHMuZGF0ZU5vdygpLFxuICAgICAgICBub2RlcyxcbiAgICAgICAgc3RhcnRQb3NpdGlvbnM7XG5cbiAgICBpZiAoby5ub2RlcyAmJiBvLm5vZGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBvLm5vZGVzWzBdID09PSAnb2JqZWN0JylcbiAgICAgICAgbm9kZXMgPSBvLm5vZGVzO1xuICAgICAgZWxzZVxuICAgICAgICBub2RlcyA9IHMuZ3JhcGgubm9kZXMoby5ub2Rlcyk7IC8vIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIElEc1xuICAgIH1cbiAgICBlbHNlXG4gICAgICBub2RlcyA9IHMuZ3JhcGgubm9kZXMoKTtcblxuICAgIC8vIFN0b3JlIGluaXRpYWwgcG9zaXRpb25zOlxuICAgIHN0YXJ0UG9zaXRpb25zID0gbm9kZXMucmVkdWNlKGZ1bmN0aW9uKHJlcywgbm9kZSkge1xuICAgICAgdmFyIGs7XG4gICAgICByZXNbbm9kZS5pZF0gPSB7fTtcbiAgICAgIGZvciAoayBpbiBhbmltYXRlKVxuICAgICAgICBpZiAoayBpbiBub2RlKVxuICAgICAgICAgIHJlc1tub2RlLmlkXVtrXSA9IG5vZGVba107XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHt9KTtcblxuICAgIHMuYW5pbWF0aW9ucyA9IHMuYW5pbWF0aW9ucyB8fCBPYmplY3QuY3JlYXRlKHt9KTtcbiAgICBzaWdtYS5wbHVnaW5zLmtpbGwocyk7XG5cbiAgICAvLyBEbyBub3QgcmVmcmVzaCBlZGdlcXVhZHRyZWUgZHVyaW5nIGRyYWc6XG4gICAgdmFyIGssXG4gICAgICAgIGM7XG4gICAgZm9yIChrIGluIHMuY2FtZXJhcykge1xuICAgICAgYyA9IHMuY2FtZXJhc1trXTtcbiAgICAgIGMuZWRnZXF1YWR0cmVlLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIHZhciBwID0gKHNpZ21hLnV0aWxzLmRhdGVOb3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICBpZiAocCA+PSAxKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gYW5pbWF0ZSlcbiAgICAgICAgICAgIGlmIChrIGluIGFuaW1hdGUpXG4gICAgICAgICAgICAgIG5vZGVba10gPSBub2RlW2FuaW1hdGVba11dO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBbGxvdyB0byByZWZyZXNoIGVkZ2VxdWFkdHJlZTpcbiAgICAgICAgdmFyIGssXG4gICAgICAgICAgICBjO1xuICAgICAgICBmb3IgKGsgaW4gcy5jYW1lcmFzKSB7XG4gICAgICAgICAgYyA9IHMuY2FtZXJhc1trXTtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzLnJlZnJlc2goKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgby5vbkNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwID0gZWFzaW5nKHApO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGFuaW1hdGUpXG4gICAgICAgICAgICBpZiAoayBpbiBhbmltYXRlKSB7XG4gICAgICAgICAgICAgIGlmIChrLm1hdGNoKC9jb2xvciQvKSlcbiAgICAgICAgICAgICAgICBub2RlW2tdID0gaW50ZXJwb2xhdGVDb2xvcnMoXG4gICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uc1tub2RlLmlkXVtrXSxcbiAgICAgICAgICAgICAgICAgIG5vZGVbYW5pbWF0ZVtrXV0sXG4gICAgICAgICAgICAgICAgICBwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVba10gPVxuICAgICAgICAgICAgICAgICAgbm9kZVthbmltYXRlW2tdXSAqIHAgK1xuICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbnNbbm9kZS5pZF1ba10gKiAoMSAtIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzLnJlZnJlc2goKTtcbiAgICAgICAgcy5hbmltYXRpb25zW2lkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGVwKCk7XG4gIH07XG5cbiAgc2lnbWEucGx1Z2lucy5raWxsID0gZnVuY3Rpb24ocykge1xuICAgIGZvciAodmFyIGsgaW4gKHMuYW5pbWF0aW9ucyB8fCB7fSkpXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzLmFuaW1hdGlvbnNba10pO1xuXG4gICAgLy8gQWxsb3cgdG8gcmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgdmFyIGssXG4gICAgICAgIGM7XG4gICAgZm9yIChrIGluIHMuY2FtZXJhcykge1xuICAgICAgYyA9IHMuY2FtZXJhc1trXTtcbiAgICAgIGMuZWRnZXF1YWR0cmVlLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59KS5jYWxsKHdpbmRvdyk7XG4iLCIvKipcbiAqIFRoaXMgcGx1Z2luIHByb3ZpZGVzIGEgbWV0aG9kIHRvIGRyYWcgJiBkcm9wIG5vZGVzLiBDaGVjayB0aGVcbiAqIHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzIGZ1bmN0aW9uIGRvYyBvciB0aGUgZXhhbXBsZXMvYmFzaWMuaHRtbCAmXG4gKiBleGFtcGxlcy9hcGktY2FuZHkuaHRtbCBjb2RlIHNhbXBsZXMgdG8ga25vdyBtb3JlLlxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnBsdWdpbnMnKTtcblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGBtb3VzZWRvd25gLCBgbW91c2V1cGAgJiBgbW91c2Vtb3ZlYCBldmVudHMgdG8gdGhlXG4gICAqIG5vZGVzIGluIHRoZSBgb3Zlck5vZGVgZXZlbnQgdG8gcGVyZm9ybSBkcmFnICYgZHJvcCBvcGVyYXRpb25zLiBJdCB1c2VzXG4gICAqIGBsaW5lYXIgaW50ZXJwb2xhdGlvbmAgW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25dXG4gICAqIGFuZCBgcm90YXRpb24gbWF0cml4YCBbaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3RhdGlvbl9tYXRyaXhdIHRvXG4gICAqIGNhbGN1bGF0ZSB0aGUgWCBhbmQgWSBjb29yZGluYXRlcyBmcm9tIHRoZSBgY2FtYCBvciBgcmVuZGVyZXJgIG5vZGVcbiAgICogYXR0cmlidXRlcy4gVGhlc2UgYXR0cmlidXRlcyByZXByZXNlbnQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBub2RlcyBpblxuICAgKiB0aGUgcmVhbCBjb250YWluZXIsIG5vdCBpbiBjYW52YXMuXG4gICAqXG4gICAqIEZpcmVkIGV2ZW50czpcbiAgICogKioqKioqKioqKioqKlxuICAgKiBzdGFydGRyYWcgIEZpcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXG4gICAqIGRyYWcgICAgICAgRmlyZWQgd2hpbGUgdGhlIG5vZGUgaXMgZHJhZ2dlZC5cbiAgICogZHJvcCAgICAgICBGaXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBkcmFnIGlmIHRoZSBub2RlIGhhcyBiZWVuIGRyYWdnZWQuXG4gICAqIGRyYWdlbmQgICAgRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgZHJhZy5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEBwYXJhbSAge3NpZ21hfSAgICBzICAgICAgICBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7cmVuZGVyZXJ9IHJlbmRlcmVyIFRoZSByZWxhdGVkIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gRHJhZ05vZGVzKHMsIHJlbmRlcmVyKSB7XG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIHBsdWdpbiB3aXRoIHRoZVxuICAgIC8vIFdlYkdMIHJlbmRlcmVyICh3aGljaCBpcyBpbXBvc3NpYmxlIGF0IHRoZSBtb21lbnQpOlxuICAgIC8vIGlmIChcbiAgICAvLyAgIHNpZ21hLnJlbmRlcmVycy53ZWJnbCAmJlxuICAgIC8vICAgcmVuZGVyZXIgaW5zdGFuY2VvZiBzaWdtYS5yZW5kZXJlcnMud2ViZ2xcbiAgICAvLyApXG4gICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gICAgICdUaGUgc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXInXG4gICAgLy8gICApO1xuXG4gICAgLy8gSW5pdCB2YXJpYWJsZXM6XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgIF9zID0gcyxcbiAgICAgIF9ib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgIF9yZW5kZXJlciA9IHJlbmRlcmVyLFxuICAgICAgX21vdXNlID0gcmVuZGVyZXIuY29udGFpbmVyLmxhc3RDaGlsZCxcbiAgICAgIF9jYW1lcmEgPSByZW5kZXJlci5jYW1lcmEsXG4gICAgICBfbm9kZSA9IG51bGwsXG4gICAgICBfcHJlZml4ID0gJycsXG4gICAgICBfaG92ZXJTdGFjayA9IFtdLFxuICAgICAgX2hvdmVySW5kZXggPSB7fSxcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlLFxuICAgICAgX2lzTW91c2VPdmVyQ2FudmFzID0gZmFsc2UsXG4gICAgICBfZHJhZyA9IGZhbHNlO1xuXG4gICAgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLnN2Zykge1xuICAgICAgICBfbW91c2UgPSByZW5kZXJlci5jb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBJdCByZW1vdmVzIHRoZSBpbml0aWFsIHN1YnN0cmluZyAoJ3JlYWRfJykgaWYgaXQncyBhIFdlZ0dMIHJlbmRlcmVyLlxuICAgIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy53ZWJnbCkge1xuICAgICAgX3ByZWZpeCA9IHJlbmRlcmVyLm9wdGlvbnMucHJlZml4LnN1YnN0cig1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3ByZWZpeCA9IHJlbmRlcmVyLm9wdGlvbnMucHJlZml4O1xuICAgIH1cblxuICAgIHJlbmRlcmVyLmJpbmQoJ292ZXJOb2RlJywgbm9kZU1vdXNlT3Zlcik7XG4gICAgcmVuZGVyZXIuYmluZCgnb3V0Tm9kZScsIHRyZWF0T3V0Tm9kZSk7XG4gICAgcmVuZGVyZXIuYmluZCgnY2xpY2snLCBjbGljayk7XG5cbiAgICBfcy5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICBfc2VsZi51bmJpbmRBbGwoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFVuYmluZCBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIHRoaXMudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBub2RlTW91c2VNb3ZlKTtcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XG4gICAgICBfcmVuZGVyZXIudW5iaW5kKCdvdmVyTm9kZScsIG5vZGVNb3VzZU92ZXIpO1xuICAgICAgX3JlbmRlcmVyLnVuYmluZCgnb3V0Tm9kZScsIHRyZWF0T3V0Tm9kZSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBtb3JlIGFjY3VyYXRlbHkgdGhhblxuICAgIC8vIGVsZW1lbnQub2Zmc2V0VG9wIGFuZCBlbGVtZW50Lm9mZnNldExlZnQuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgdmFyIGdldENzc1Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKS5yZXBsYWNlKCdweCcsICcnKSkgfHwgMDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBnZXRDc3NQcm9wZXJ0eSgncGFkZGluZy1sZWZ0JyksXG4gICAgICAgIHRvcDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBnZXRDc3NQcm9wZXJ0eSgncGFkZGluZy10b3AnKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICAgIC8vIGV2ZW50IHRyaWdnZXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBjbGlja1xuICAgICAgX2lzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBub2RlTW91c2VNb3ZlKTtcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XG5cbiAgICAgIGlmICghX2hvdmVyU3RhY2subGVuZ3RoKSB7XG4gICAgICAgIF9ub2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlT3ZlcihldmVudCkge1xuICAgICAgLy8gRG9uJ3QgdHJlYXQgdGhlIG5vZGUgaWYgaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICBpZiAoX2hvdmVySW5kZXhbZXZlbnQuZGF0YS5ub2RlLmlkXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBub2RlIHRvIGFycmF5IG9mIGN1cnJlbnQgbm9kZXMgb3ZlclxuICAgICAgX2hvdmVyU3RhY2sucHVzaChldmVudC5kYXRhLm5vZGUpO1xuICAgICAgX2hvdmVySW5kZXhbZXZlbnQuZGF0YS5ub2RlLmlkXSA9IHRydWU7XG5cbiAgICAgIGlmKF9ob3ZlclN0YWNrLmxlbmd0aCAmJiAhIF9pc01vdXNlRG93bikge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgbm9kZSB0byBiZSB0aGUgbGFzdCBvbmUgaW4gdGhlIGFycmF5XG4gICAgICAgIF9ub2RlID0gX2hvdmVyU3RhY2tbX2hvdmVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIF9tb3VzZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJlYXRPdXROb2RlKGV2ZW50KSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgYXJyYXlcbiAgICAgIHZhciBpbmRleENoZWNrID0gX2hvdmVyU3RhY2subWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGU7IH0pLmluZGV4T2YoZXZlbnQuZGF0YS5ub2RlKTtcbiAgICAgIF9ob3ZlclN0YWNrLnNwbGljZShpbmRleENoZWNrLCAxKTtcbiAgICAgIGRlbGV0ZSBfaG92ZXJJbmRleFtldmVudC5kYXRhLm5vZGUuaWRdO1xuXG4gICAgICBpZihfaG92ZXJTdGFjay5sZW5ndGggJiYgISBfaXNNb3VzZURvd24pIHtcbiAgICAgICAgLy8gT24gb3V0LCBzZXQgdGhlIGN1cnJlbnQgbm9kZSB0byBiZSB0aGUgbmV4dCBzdGF0ZWQgaW4gYXJyYXlcbiAgICAgICAgX25vZGUgPSBfaG92ZXJTdGFja1tfaG92ZXJTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9tb3VzZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlRG93bihldmVudCkge1xuICAgICAgX2lzTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHZhciBzaXplID0gX3MuZ3JhcGgubm9kZXMoKS5sZW5ndGg7XG5cbiAgICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBub2RlIGluIHRoZSBncmFwaCwgdGhlIHBsdWdpbiBjYW5ub3QgYXBwbHlcbiAgICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uLiBTbyB0cmVhdCBpdCBhcyBpZiBhIHVzZXIgaXMgZHJhZ2dpbmdcbiAgICAgIC8vIHRoZSBncmFwaFxuICAgICAgaWYgKF9ub2RlICYmIHNpemUgPiAxKSB7XG4gICAgICAgIF9tb3VzZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgICAgX2JvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICAgIF9ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XG5cbiAgICAgICAgLy8gRG8gbm90IHJlZnJlc2ggZWRnZXF1YWR0cmVlIGR1cmluZyBkcmFnOlxuICAgICAgICB2YXIgayxcbiAgICAgICAgICAgIGM7XG4gICAgICAgIGZvciAoayBpbiBfcy5jYW1lcmFzKSB7XG4gICAgICAgICAgYyA9IF9zLmNhbWVyYXNba107XG4gICAgICAgICAgaWYgKGMuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGMuZWRnZXF1YWR0cmVlLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVhY3RpdmF0ZSBkcmFnIGdyYXBoLlxuICAgICAgICBfcmVuZGVyZXIuc2V0dGluZ3Moe21vdXNlRW5hYmxlZDogZmFsc2UsIGVuYWJsZUhvdmVyaW5nOiBmYWxzZX0pO1xuICAgICAgICBfcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnc3RhcnRkcmFnJywge1xuICAgICAgICAgIG5vZGU6IF9ub2RlLFxuICAgICAgICAgIGNhcHRvcjogZXZlbnQsXG4gICAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlVXAoZXZlbnQpIHtcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgX21vdXNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuXG4gICAgICAvLyBBbGxvdyB0byByZWZyZXNoIGVkZ2VxdWFkdHJlZTpcbiAgICAgIHZhciBrLFxuICAgICAgICAgIGM7XG4gICAgICBmb3IgKGsgaW4gX3MuY2FtZXJhcykge1xuICAgICAgICBjID0gX3MuY2FtZXJhc1trXTtcbiAgICAgICAgaWYgKGMuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWN0aXZhdGUgZHJhZyBncmFwaC5cbiAgICAgIF9yZW5kZXJlci5zZXR0aW5ncyh7bW91c2VFbmFibGVkOiB0cnVlLCBlbmFibGVIb3ZlcmluZzogdHJ1ZX0pO1xuICAgICAgX3MucmVmcmVzaCgpO1xuXG4gICAgICBpZiAoX2RyYWcpIHtcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJvcCcsIHtcbiAgICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgICBjYXB0b3I6IGV2ZW50LFxuICAgICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnZW5kJywge1xuICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgY2FwdG9yOiBldmVudCxcbiAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxuICAgICAgfSk7XG5cbiAgICAgIF9kcmFnID0gZmFsc2U7XG4gICAgICBfbm9kZSA9IG51bGw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGlmKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAtMSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZU91dCk7XG4gICAgICAgIHZhciB0aW1lT3V0ID0gc2V0VGltZW91dChleGVjdXRlTm9kZU1vdXNlTW92ZSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjdXRlTm9kZU1vdXNlTW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleGVjdXRlTm9kZU1vdXNlTW92ZSgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGNhbGN1bGF0ZU9mZnNldChfcmVuZGVyZXIuY29udGFpbmVyKSxcbiAgICAgICAgICAgIHggPSBldmVudC5jbGllbnRYIC0gb2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WSAtIG9mZnNldC50b3AsXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhfY2FtZXJhLmFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKF9jYW1lcmEuYW5nbGUpLFxuICAgICAgICAgICAgbm9kZXMgPSBfcy5ncmFwaC5ub2RlcygpLFxuICAgICAgICAgICAgcmVmID0gW107XG5cbiAgICAgICAgLy8gR2V0dGluZyBhbmQgZGVyb3RhdGluZyB0aGUgcmVmZXJlbmNlIGNvb3JkaW5hdGVzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIGF1eCA9IHtcbiAgICAgICAgICAgIHg6IG4ueCAqIGNvcyArIG4ueSAqIHNpbixcbiAgICAgICAgICAgIHk6IG4ueSAqIGNvcyAtIG4ueCAqIHNpbixcbiAgICAgICAgICAgIHJlblg6IG5bX3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICByZW5ZOiBuW19wcmVmaXggKyAneSddLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVmLnB1c2goYXV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5aW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAvLyBpZiB0aGUgbm9kZXMgYXJlIG9uIHRvcCBvZiBlYWNoIG90aGVyLCB3ZSB1c2UgdGhlIGNhbWVyYSByYXRpbyB0byBpbnRlcnBvbGF0ZVxuICAgICAgICBpZiAocmVmWzBdLnggPT09IHJlZlsxXS54ICYmIHJlZlswXS55ID09PSByZWZbMV0ueSkge1xuICAgICAgICAgIHZhciB4UmF0aW8gPSAocmVmWzBdLnJlblggPT09IDApID8gMSA6IHJlZlswXS5yZW5YO1xuICAgICAgICAgIHZhciB5UmF0aW8gPSAocmVmWzBdLnJlblkgPT09IDApID8gMSA6IHJlZlswXS5yZW5ZO1xuICAgICAgICAgIHggPSAocmVmWzBdLnggLyB4UmF0aW8pICogKHggLSByZWZbMF0ucmVuWCkgKyByZWZbMF0ueDtcbiAgICAgICAgICB5ID0gKHJlZlswXS55IC8geVJhdGlvKSAqICh5IC0gcmVmWzBdLnJlblkpICsgcmVmWzBdLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHhSYXRpbyA9IChyZWZbMV0ucmVuWCAtIHJlZlswXS5yZW5YKSAvIChyZWZbMV0ueCAtIHJlZlswXS54KTtcbiAgICAgICAgICB2YXIgeVJhdGlvID0gKHJlZlsxXS5yZW5ZIC0gcmVmWzBdLnJlblkpIC8gKHJlZlsxXS55IC0gcmVmWzBdLnkpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgc2FtZSwgd2UgdXNlIHRoZSBvdGhlciByYXRpbyB0byBpbnRlcnBvbGF0ZVxuICAgICAgICAgIGlmIChyZWZbMV0ueCA9PT0gcmVmWzBdLngpIHtcbiAgICAgICAgICAgIHhSYXRpbyA9IHlSYXRpbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVmWzFdLnkgPT09IHJlZlswXS55KSB7XG4gICAgICAgICAgICB5UmF0aW8gPSB4UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeCA9ICh4IC0gcmVmWzBdLnJlblgpIC8geFJhdGlvICsgcmVmWzBdLng7XG4gICAgICAgICAgeSA9ICh5IC0gcmVmWzBdLnJlblkpIC8geVJhdGlvICsgcmVmWzBdLnk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSb3RhdGluZyB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICAgIF9ub2RlLnggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICAgICAgX25vZGUueSA9IHkgKiBjb3MgKyB4ICogc2luO1xuXG4gICAgICAgIF9zLnJlZnJlc2goKTtcblxuICAgICAgICBfZHJhZyA9IHRydWU7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnLCB7XG4gICAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgICAgY2FwdG9yOiBldmVudCxcbiAgICAgICAgICByZW5kZXJlcjogX3JlbmRlcmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVyZmFjZVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogPiB2YXIgZHJhZ05vZGVzTGlzdGVuZXIgPSBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyhzLCBzLnJlbmRlcmVyc1swXSk7XG4gICAqL1xuICB2YXIgX2luc3RhbmNlID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge3NpZ21hfSBzIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtyZW5kZXJlcn0gcmVuZGVyZXIgVGhlIHJlbGF0ZWQgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyA9IGZ1bmN0aW9uKHMsIHJlbmRlcmVyKSB7XG4gICAgLy8gQ3JlYXRlIG9iamVjdCBpZiB1bmRlZmluZWRcbiAgICBpZiAoIV9pbnN0YW5jZVtzLmlkXSkge1xuICAgICAgX2luc3RhbmNlW3MuaWRdID0gbmV3IERyYWdOb2RlcyhzLCByZW5kZXJlcik7XG4gICAgfVxuXG4gICAgcy5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS5wbHVnaW5zLmtpbGxEcmFnTm9kZXMocyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX2luc3RhbmNlW3MuaWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgYW5kIGtpbGxzIHRoZSBkcmFnTm9kZXMgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hfSBzIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucGx1Z2lucy5raWxsRHJhZ05vZGVzID0gZnVuY3Rpb24ocykge1xuICAgIGlmIChfaW5zdGFuY2Vbcy5pZF0gaW5zdGFuY2VvZiBEcmFnTm9kZXMpIHtcbiAgICAgIF9pbnN0YW5jZVtzLmlkXS51bmJpbmRBbGwoKTtcbiAgICAgIGRlbGV0ZSBfaW5zdGFuY2Vbcy5pZF07XG4gICAgfVxuICB9O1xuXG59KS5jYWxsKHdpbmRvdyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBhcnJheXMgPSByZXF1aXJlKFwiLi9hcnJheXNcIik7XG52YXIgTGlua2VkTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYW4gZW1wdHkgTGlua2VkIExpc3QuXG4gICAgKiBAY2xhc3MgQSBsaW5rZWQgbGlzdCBpcyBhIGRhdGEgc3RydWN0dXJlIGNvbnNpc3Rpbmcgb2YgYSBncm91cCBvZiBub2Rlc1xuICAgICogd2hpY2ggdG9nZXRoZXIgcmVwcmVzZW50IGEgc2VxdWVuY2UuXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEZpcnN0IG5vZGUgaW4gdGhlIGxpc3RcbiAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyc3ROb2RlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICogTGFzdCBub2RlIGluIHRoZSBsaXN0XG4gICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICogTnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBsaXN0XG4gICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5FbGVtZW50cyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoaXMgbGlzdC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIGVsZW1lbnQgdG8gYmUgYWRkZWQuXG4gICAgKiBAcGFyYW0ge251bWJlcj19IGluZGV4IG9wdGlvbmFsIGluZGV4IHRvIGFkZCB0aGUgZWxlbWVudC4gSWYgbm8gaW5kZXggaXMgc3BlY2lmaWVkXG4gICAgKiB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgZW5kIG9mIHRoaXMgbGlzdC5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVsZW1lbnQgd2FzIGFkZGVkIG9yIGZhbHNlIGlmIHRoZSBpbmRleCBpcyBpbnZhbGlkXG4gICAgKiBvciBpZiB0aGUgZWxlbWVudCBpcyB1bmRlZmluZWQuXG4gICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubkVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLm5FbGVtZW50cyB8fCB1dGlsLmlzVW5kZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld05vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLm5FbGVtZW50cyA9PT0gMCB8fCB0aGlzLmxhc3ROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBub2RlIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdGhpcy5maXJzdE5vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IHRoaXMubkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgYXQgdGhlIGVuZC5cbiAgICAgICAgICAgIHRoaXMubGFzdE5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQ2hhbmdlIGZpcnN0IG5vZGUuXG4gICAgICAgICAgICBuZXdOb2RlLm5leHQgPSB0aGlzLmZpcnN0Tm9kZTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3ROb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5ub2RlQXRJbmRleChpbmRleCAtIDEpO1xuICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld05vZGUubmV4dCA9IHByZXYubmV4dDtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uRWxlbWVudHMrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhpcyBsaXN0LlxuICAgICogQHJldHVybiB7Kn0gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgb3IgdW5kZWZpbmVkIGlmIHRoZSBsaXN0IGlzXG4gICAgKiBlbXB0eS5cbiAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5maXJzdE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0Tm9kZS5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGlzIGxpc3QuXG4gICAgKiBAcmV0dXJuIHsqfSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBsaXN0IG9yIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBpc1xuICAgICogZW1wdHkuXG4gICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdE5vZGUuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoaXMgbGlzdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggZGVzaXJlZCBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggb3IgdW5kZWZpbmVkIGlmIHRoZSBpbmRleCBpc1xuICAgICAqIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZWxlbWVudEF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVBdEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IGluIHRoaXMgbGlzdCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGVcbiAgICAgKiBzcGVjaWZpZWQgZWxlbWVudCwgb3IgLTEgaWYgdGhlIExpc3QgZG9lcyBub3QgY29udGFpbiB0aGlzIGVsZW1lbnQuXG4gICAgICogPHA+SWYgdGhlIGVsZW1lbnRzIGluc2lkZSB0aGlzIGxpc3QgYXJlXG4gICAgICogbm90IGNvbXBhcmFibGUgd2l0aCB0aGUgPT09IG9wZXJhdG9yIGEgY3VzdG9tIGVxdWFscyBmdW5jdGlvbiBzaG91bGQgYmVcbiAgICAgKiBwcm92aWRlZCB0byBwZXJmb3JtIHNlYXJjaGVzLCB0aGUgZnVuY3Rpb24gbXVzdCByZWNlaXZlIHR3byBhcmd1bWVudHMgYW5kXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS4gRXhhbXBsZTo8L3A+XG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqIGNvbnN0IHBldHNBcmVFcXVhbEJ5TmFtZSA9IGZ1bmN0aW9uKHBldDEsIHBldDIpIHtcbiAgICAgKiAgcmV0dXJuIHBldDEubmFtZSA9PT0gcGV0Mi5uYW1lO1xuICAgICAqIH1cbiAgICAgKiA8L3ByZT5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gT3B0aW9uYWxcbiAgICAgKiBmdW5jdGlvbiB1c2VkIHRvIGNoZWNrIGlmIHR3byBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggaW4gdGhpcyBsaXN0IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlXG4gICAgICogb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50LCBvciAtMSBpZiB0aGlzIGxpc3QgZG9lcyBub3QgY29udGFpbiB0aGVcbiAgICAgKiBlbGVtZW50LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGVxdWFsc0YgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVxdWFsc0YoY3VycmVudE5vZGUuZWxlbWVudCwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlzdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gICAgICAgKiA8cD5JZiB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZSBsaXN0IGFyZVxuICAgICAgICogbm90IGNvbXBhcmFibGUgd2l0aCB0aGUgPT09IG9wZXJhdG9yIGEgY3VzdG9tIGVxdWFscyBmdW5jdGlvbiBzaG91bGQgYmVcbiAgICAgICAqIHByb3ZpZGVkIHRvIHBlcmZvcm0gc2VhcmNoZXMsIHRoZSBmdW5jdGlvbiBtdXN0IHJlY2VpdmUgdHdvIGFyZ3VtZW50cyBhbmRcbiAgICAgICAqIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuIEV4YW1wbGU6PC9wPlxuICAgICAgICpcbiAgICAgICAqIDxwcmU+XG4gICAgICAgKiBjb25zdCBwZXRzQXJlRXF1YWxCeU5hbWUgPSBmdW5jdGlvbihwZXQxLCBwZXQyKSB7XG4gICAgICAgKiAgcmV0dXJuIHBldDEubmFtZSA9PT0gcGV0Mi5uYW1lO1xuICAgICAgICogfVxuICAgICAgICogPC9wcmU+XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBPcHRpb25hbFxuICAgICAgICogZnVuY3Rpb24gdXNlZCB0byBjaGVjayBpZiB0d28gZWxlbWVudHMgYXJlIGVxdWFsLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGxpc3QgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LCBmYWxzZVxuICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4T2YoaXRlbSwgZXF1YWxzRnVuY3Rpb24pID49IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaW4gdGhpcyBsaXN0LlxuICAgICAqIDxwPklmIHRoZSBlbGVtZW50cyBpbnNpZGUgdGhlIGxpc3QgYXJlXG4gICAgICogbm90IGNvbXBhcmFibGUgd2l0aCB0aGUgPT09IG9wZXJhdG9yIGEgY3VzdG9tIGVxdWFscyBmdW5jdGlvbiBzaG91bGQgYmVcbiAgICAgKiBwcm92aWRlZCB0byBwZXJmb3JtIHNlYXJjaGVzLCB0aGUgZnVuY3Rpb24gbXVzdCByZWNlaXZlIHR3byBhcmd1bWVudHMgYW5kXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS4gRXhhbXBsZTo8L3A+XG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqIGNvbnN0IHBldHNBcmVFcXVhbEJ5TmFtZSA9IGZ1bmN0aW9uKHBldDEsIHBldDIpIHtcbiAgICAgKiAgcmV0dXJuIHBldDEubmFtZSA9PT0gcGV0Mi5uYW1lO1xuICAgICAqIH1cbiAgICAgKiA8L3ByZT5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBlbGVtZW50IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGlzIGxpc3QsIGlmIHByZXNlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbGlzdCBjb250YWluZWQgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgICAgICB2YXIgZXF1YWxzRiA9IGVxdWFsc0Z1bmN0aW9uIHx8IHV0aWwuZGVmYXVsdEVxdWFscztcbiAgICAgICAgaWYgKHRoaXMubkVsZW1lbnRzIDwgMSB8fCB1dGlsLmlzVW5kZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVxdWFsc0YoY3VycmVudE5vZGUuZWxlbWVudCwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGhpcy5sYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMubGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubkVsZW1lbnRzLS07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIG9mIHRoZSBlbGVtZW50cyBmcm9tIHRoaXMgbGlzdC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maXJzdE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5uRWxlbWVudHMgPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlzdCBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gbGlzdC5cbiAgICAgKiBUd28gbGlzdHMgYXJlIGVxdWFsIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgKiBAcGFyYW0ge0xpbmtlZExpc3R9IG90aGVyIHRoZSBvdGhlciBsaXN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsXG4gICAgICogZnVuY3Rpb24gdXNlZCB0byBjaGVjayBpZiB0d28gZWxlbWVudHMgYXJlIGVxdWFsLiBJZiB0aGUgZWxlbWVudHMgaW4gdGhlIGxpc3RzXG4gICAgICogYXJlIGN1c3RvbSBvYmplY3RzIHlvdSBzaG91bGQgcHJvdmlkZSBhIGZ1bmN0aW9uLCBvdGhlcndpc2VcbiAgICAgKiB0aGUgPT09IG9wZXJhdG9yIGlzIHVzZWQgdG8gY2hlY2sgZXF1YWxpdHkgYmV0d2VlbiBlbGVtZW50cy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoaXMgbGlzdCBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gbGlzdC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIsIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBlcUYgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgTGlua2VkTGlzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplKCkgIT09IG90aGVyLnNpemUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFsc0F1eCh0aGlzLmZpcnN0Tm9kZSwgb3RoZXIuZmlyc3ROb2RlLCBlcUYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZXF1YWxzQXV4ID0gZnVuY3Rpb24gKG4xLCBuMiwgZXFGKSB7XG4gICAgICAgIHdoaWxlIChuMSAhPT0gbnVsbCAmJiBuMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFlcUYobjEuZWxlbWVudCwgbjIuZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuMSA9IG4xLm5leHQ7XG4gICAgICAgICAgICBuMiA9IG4yLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gdGhpcyBsaXN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBnaXZlbiBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHsqfSByZW1vdmVkIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZUVsZW1lbnRBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5uRWxlbWVudHMgfHwgdGhpcy5maXJzdE5vZGUgPT09IG51bGwgfHwgdGhpcy5sYXN0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMubkVsZW1lbnRzID09PSAxKSB7XG4gICAgICAgICAgICAvL0ZpcnN0IG5vZGUgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5maXJzdE5vZGUuZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmlyc3ROb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5ub2RlQXRJbmRleChpbmRleCAtIDEpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZmlyc3ROb2RlLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJldmlvdXMubmV4dCA9PT0gdGhpcy5sYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmxhc3ROb2RlLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzICE9PSBudWxsICYmIHByZXZpb3VzLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gcHJldmlvdXMubmV4dC5lbGVtZW50O1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBwcmV2aW91cy5uZXh0Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uRWxlbWVudHMtLTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnQgaW4gdGhpcyBsaXN0IGluIG9yZGVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KToqfSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLCBpdCBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6IHRoZSBlbGVtZW50IHZhbHVlLCB0byBicmVhayB0aGUgaXRlcmF0aW9uIHlvdSBjYW5cbiAgICAgKiBvcHRpb25hbGx5IHJldHVybiBmYWxzZS5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjdXJyZW50Tm9kZS5lbGVtZW50KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIG9yZGVyIG9mIHRoZSBlbGVtZW50cyBpbiB0aGlzIGxpbmtlZCBsaXN0IChtYWtlcyB0aGUgbGFzdFxuICAgICAqIGVsZW1lbnQgZmlyc3QsIGFuZCB0aGUgZmlyc3QgZWxlbWVudCBsYXN0KS5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB2YXIgdGVtcCA9IG51bGw7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0ZW1wID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gcHJldmlvdXM7XG4gICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgIHRoaXMuZmlyc3ROb2RlID0gdGhpcy5sYXN0Tm9kZTtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IHRlbXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiB0aGlzIGxpc3QgaW4gcHJvcGVyXG4gICAgICogc2VxdWVuY2UuXG4gICAgICogQHJldHVybiB7QXJyYXkuPCo+fSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhpcyBsaXN0LFxuICAgICAqIGluIHByb3BlciBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXkucHVzaChjdXJyZW50Tm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhpcyBsaXN0LlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGlzIGxpc3QuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubkVsZW1lbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlzdCBjb250YWlucyBubyBlbGVtZW50cy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoaXMgbGlzdCBjb250YWlucyBubyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uRWxlbWVudHMgPD0gMDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJyYXlzLnRvU3RyaW5nKHRoaXMudG9BcnJheSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUubm9kZUF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm5FbGVtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAodGhpcy5uRWxlbWVudHMgLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmZpcnN0Tm9kZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleCAmJiBub2RlICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50OiBpdGVtLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpbmtlZExpc3Q7XG59KCkpOyAvLyBFbmQgb2YgbGlua2VkIGxpc3RcbmV4cG9ydHMuZGVmYXVsdCA9IExpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5rZWRMaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpbmtlZExpc3RfMSA9IHJlcXVpcmUoXCIuL0xpbmtlZExpc3RcIik7XG52YXIgUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbXB0eSBxdWV1ZS5cbiAgICAgKiBAY2xhc3MgQSBxdWV1ZSBpcyBhIEZpcnN0LUluLUZpcnN0LU91dCAoRklGTykgZGF0YSBzdHJ1Y3R1cmUsIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYWRkZWQgdG8gdGhlIHF1ZXVlIHdpbGwgYmUgdGhlIGZpcnN0IG9uZSB0byBiZSByZW1vdmVkLiBUaGlzXG4gICAgICogaW1wbGVtZW50YXRpb24gdXNlcyBhIGxpbmtlZCBsaXN0IGFzIGEgY29udGFpbmVyLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgICAgICB0aGlzLmxpc3QgPSBuZXcgTGlua2VkTGlzdF8xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaW50byB0aGUgZW5kIG9mIHRoaXMgcXVldWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gdGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVsZW1lbnQgd2FzIGluc2VydGVkLCBvciBmYWxzZSBpZiBpdCBpcyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmFkZChlbGVtKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGludG8gdGhlIGVuZCBvZiB0aGlzIHF1ZXVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIHRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IHdhcyBpbnNlcnRlZCwgb3IgZmFsc2UgaWYgaXQgaXMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmFkZChlbGVtKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbmQgcmVtb3ZlcyB0aGUgaGVhZCBvZiB0aGlzIHF1ZXVlLlxuICAgICAqIEByZXR1cm4geyp9IHRoZSBoZWFkIG9mIHRoaXMgcXVldWUsIG9yIHVuZGVmaW5lZCBpZiB0aGlzIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saXN0LnNpemUoKSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5saXN0LmZpcnN0KCk7XG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlRWxlbWVudEF0SW5kZXgoMCk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcywgYnV0IGRvZXMgbm90IHJlbW92ZSwgdGhlIGhlYWQgb2YgdGhpcyBxdWV1ZS5cbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgaGVhZCBvZiB0aGlzIHF1ZXVlLCBvciB1bmRlZmluZWQgaWYgdGhpcyBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBRdWV1ZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplKCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3QuZmlyc3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoaXMgcXVldWUuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoaXMgcXVldWUuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3Quc2l6ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcXVldWUgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAqIDxwPklmIHRoZSBlbGVtZW50cyBpbnNpZGUgdGhpcyBzdGFjayBhcmVcbiAgICAgKiBub3QgY29tcGFyYWJsZSB3aXRoIHRoZSA9PT0gb3BlcmF0b3IsIGEgY3VzdG9tIGVxdWFscyBmdW5jdGlvbiBzaG91bGQgYmVcbiAgICAgKiBwcm92aWRlZCB0byBwZXJmb3JtIHNlYXJjaGVzLCB0aGUgZnVuY3Rpb24gbXVzdCByZWNlaXZlIHR3byBhcmd1bWVudHMgYW5kXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS4gRXhhbXBsZTo8L3A+XG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqIGNvbnN0IHBldHNBcmVFcXVhbEJ5TmFtZSAocGV0MSwgcGV0Mikge1xuICAgICAqICByZXR1cm4gcGV0MS5uYW1lID09PSBwZXQyLm5hbWU7XG4gICAgICogfVxuICAgICAqIDwvcHJlPlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIGVsZW1lbnQgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbFxuICAgICAqIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHR3byBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHF1ZXVlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudCxcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGVsZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuY29udGFpbnMoZWxlbSwgZXF1YWxzRnVuY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgcXVldWUgaXMgZW1wdHkuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGlzIHF1ZXVlIGNvbnRhaW5zIG5vIGl0ZW1zOyBmYWxzZVxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBRdWV1ZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5zaXplKCkgPD0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIG9mIHRoZSBlbGVtZW50cyBmcm9tIHRoaXMgcXVldWUuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpc3QuY2xlYXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQgcHJlc2VudCBpbiB0aGlzIHF1ZXVlIGluXG4gICAgICogRklGTyBvcmRlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6Kn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgaXQgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiB0aGUgZWxlbWVudCB2YWx1ZSwgdG8gYnJlYWsgdGhlIGl0ZXJhdGlvbiB5b3UgY2FuXG4gICAgICogb3B0aW9uYWxseSByZXR1cm4gZmFsc2UuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlO1xufSgpKTsgLy8gRW5kIG9mIHF1ZXVlXG5leHBvcnRzLmRlZmF1bHQgPSBRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgc3BlY2lmaWVkIGl0ZW1cbiAqIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGFycmF5LjRcbiAqIEBwYXJhbSB7Kn0gYXJyYXkgdGhlIGFycmF5IGluIHdoaWNoIHRvIHNlYXJjaCB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIHRoZSBlbGVtZW50IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudFxuICogd2l0aGluIHRoZSBzcGVjaWZpZWQgYXJyYXksIG9yIC0xIGlmIG5vdCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgaXRlbSwgZXF1YWxzRnVuY3Rpb24pIHtcbiAgICB2YXIgZXF1YWxzID0gZXF1YWxzRnVuY3Rpb24gfHwgdXRpbC5kZWZhdWx0RXF1YWxzO1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzKGFycmF5W2ldLCBpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZXhwb3J0cy5pbmRleE9mID0gaW5kZXhPZjtcbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnRcbiAqIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGFycmF5LlxuICogQHBhcmFtIHsqfSBhcnJheSB0aGUgYXJyYXkgaW4gd2hpY2ggdG8gc2VhcmNoIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gdGhlIGVsZW1lbnQgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gb3B0aW9uYWwgZnVuY3Rpb24gdXNlZCB0b1xuICogY2hlY2sgZXF1YWxpdHkgYmV0d2VlbiAyIGVsZW1lbnRzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnRcbiAqIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGFycmF5IG9yIC0xIGlmIG5vdCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgdmFyIGVxdWFscyA9IGVxdWFsc0Z1bmN0aW9uIHx8IHV0aWwuZGVmYXVsdEVxdWFscztcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoZXF1YWxzKGFycmF5W2ldLCBpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZXhwb3J0cy5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBhcnJheSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IGFycmF5IHRoZSBhcnJheSBpbiB3aGljaCB0byBzZWFyY2ggdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSB0aGUgZWxlbWVudCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbCBmdW5jdGlvbiB0b1xuICogY2hlY2sgZXF1YWxpdHkgYmV0d2VlbiAyIGVsZW1lbnRzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGluZGV4T2YoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSA+PSAwO1xufVxuZXhwb3J0cy5jb250YWlucyA9IGNvbnRhaW5zO1xuLyoqXG4gKiBSZW1vdmVzIHRoZSBmaXJzdCBvY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIHNwZWNpZmllZCBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gYXJyYXkgdGhlIGFycmF5IGluIHdoaWNoIHRvIHNlYXJjaCBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gdGhlIGVsZW1lbnQgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFycmF5IGNoYW5nZWQgYWZ0ZXIgdGhpcyBjYWxsLlxuICovXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnJheSwgaXRlbSwgZXF1YWxzRnVuY3Rpb24pO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc3BlY2lmaWVkIGFycmF5IGVxdWFsXG4gKiB0byB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IHRoZSBhcnJheSBpbiB3aGljaCB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIHRoZSBlbGVtZW50IHdob3NlIGZyZXF1ZW5jeSBpcyB0byBiZSBkZXRlcm1pbmVkLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gb3B0aW9uYWwgZnVuY3Rpb24gdXNlZCB0b1xuICogY2hlY2sgZXF1YWxpdHkgYmV0d2VlbiAyIGVsZW1lbnRzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBzcGVjaWZpZWQgYXJyYXlcbiAqIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBmcmVxdWVuY3koYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgdmFyIGVxdWFscyA9IGVxdWFsc0Z1bmN0aW9uIHx8IHV0aWwuZGVmYXVsdEVxdWFscztcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBmcmVxID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHMoYXJyYXlbaV0sIGl0ZW0pKSB7XG4gICAgICAgICAgICBmcmVxKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyZXE7XG59XG5leHBvcnRzLmZyZXF1ZW5jeSA9IGZyZXF1ZW5jeTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gc3BlY2lmaWVkIGFycmF5cyBhcmUgZXF1YWwgdG8gb25lIGFub3RoZXIuXG4gKiBUd28gYXJyYXlzIGFyZSBjb25zaWRlcmVkIGVxdWFsIGlmIGJvdGggYXJyYXlzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyXG4gKiBvZiBlbGVtZW50cywgYW5kIGFsbCBjb3JyZXNwb25kaW5nIHBhaXJzIG9mIGVsZW1lbnRzIGluIHRoZSB0d29cbiAqIGFycmF5cyBhcmUgZXF1YWwgYW5kIGFyZSBpbiB0aGUgc2FtZSBvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MSBvbmUgYXJyYXkgdG8gYmUgdGVzdGVkIGZvciBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MiB0aGUgb3RoZXIgYXJyYXkgdG8gYmUgdGVzdGVkIGZvciBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gZWxlbWVtZW50cyBpbiB0aGUgYXJyYXlzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHdvIGFycmF5cyBhcmUgZXF1YWxcbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGFycmF5MSwgYXJyYXkyLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHZhciBlcXVhbHMgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgaWYgKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkxLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZXF1YWxzKGFycmF5MVtpXSwgYXJyYXkyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG4vKipcbiAqIFJldHVybnMgc2hhbGxvdyBhIGNvcHkgb2YgdGhlIHNwZWNpZmllZCBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gYXJyYXkgdGhlIGFycmF5IHRvIGNvcHkuXG4gKiBAcmV0dXJuIHtBcnJheX0gYSBjb3B5IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gY29weShhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5jb25jYXQoKTtcbn1cbmV4cG9ydHMuY29weSA9IGNvcHk7XG4vKipcbiAqIFN3YXBzIHRoZSBlbGVtZW50cyBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9ucyBpbiB0aGUgc3BlY2lmaWVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IGluIHdoaWNoIHRvIHN3YXAgZWxlbWVudHMuXG4gKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggb2Ygb25lIGVsZW1lbnQgdG8gYmUgc3dhcHBlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBqIHRoZSBpbmRleCBvZiB0aGUgb3RoZXIgZWxlbWVudCB0byBiZSBzd2FwcGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJyYXkgaXMgZGVmaW5lZCBhbmQgdGhlIGluZGV4ZXMgYXJlIHZhbGlkLlxuICovXG5mdW5jdGlvbiBzd2FwKGFycmF5LCBpLCBqKSB7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gYXJyYXkubGVuZ3RoIHx8IGogPCAwIHx8IGogPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRlbXAgPSBhcnJheVtpXTtcbiAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgIGFycmF5W2pdID0gdGVtcDtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuc3dhcCA9IHN3YXA7XG5mdW5jdGlvbiB0b1N0cmluZyhhcnJheSkge1xuICAgIHJldHVybiAnWycgKyBhcnJheS50b1N0cmluZygpICsgJ10nO1xufVxuZXhwb3J0cy50b1N0cmluZyA9IHRvU3RyaW5nO1xuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnQgaW4gdGhpcyBhcnJheVxuICogc3RhcnRpbmcgZnJvbSBpbmRleCAwIHRvIGxlbmd0aCAtIDEuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgaW4gd2hpY2ggdG8gaXRlcmF0ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KToqfSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLCBpdCBpc1xuICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogdGhlIGVsZW1lbnQgdmFsdWUsIHRvIGJyZWFrIHRoZSBpdGVyYXRpb24geW91IGNhblxuICogb3B0aW9uYWxseSByZXR1cm4gZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBhcnJheV8xID0gYXJyYXk7IF9pIDwgYXJyYXlfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFycmF5XzFbX2ldO1xuICAgICAgICBpZiAoY2FsbGJhY2soZWxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZm9yRWFjaCA9IGZvckVhY2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydHMuaGFzID0gZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufTtcbi8qKlxuICogRGVmYXVsdCBmdW5jdGlvbiB0byBjb21wYXJlIGVsZW1lbnQgb3JkZXIuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRDb21wYXJlID0gZGVmYXVsdENvbXBhcmU7XG4vKipcbiAqIERlZmF1bHQgZnVuY3Rpb24gdG8gdGVzdCBlcXVhbGl0eS5cbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBkZWZhdWx0RXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbmV4cG9ydHMuZGVmYXVsdEVxdWFscyA9IGRlZmF1bHRFcXVhbHM7XG4vKipcbiAqIERlZmF1bHQgZnVuY3Rpb24gdG8gY29udmVydCBhbiBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRvU3RyaW5nKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ0NPTExFQ1RJT05fTlVMTCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiAnQ09MTEVDVElPTl9VTkRFRklORUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyhpdGVtKSkge1xuICAgICAgICByZXR1cm4gJyRzJyArIGl0ZW07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJyRvJyArIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRUb1N0cmluZyA9IGRlZmF1bHRUb1N0cmluZztcbi8qKlxuKiBKb2lucyBhbGwgdGhlIHByb3BlcmllcyBvZiB0aGUgb2JqZWN0IHVzaW5nIHRoZSBwcm92aWRlZCBqb2luIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIG1ha2VTdHJpbmcoaXRlbSwgam9pbikge1xuICAgIGlmIChqb2luID09PSB2b2lkIDApIHsgam9pbiA9ICcsJzsgfVxuICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnQ09MTEVDVElPTl9OVUxMJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNVbmRlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuICdDT0xMRUNUSU9OX1VOREVGSU5FRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdG9yZXQgPSAneyc7XG4gICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gaXRlbSkge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMuaGFzKGl0ZW0sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3JldCA9IHRvcmV0ICsgam9pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9yZXQgPSB0b3JldCArIHByb3AgKyAnOicgKyBpdGVtW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3JldCArICd9JztcbiAgICB9XG59XG5leHBvcnRzLm1ha2VTdHJpbmcgPSBtYWtlU3RyaW5nO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZnVuYykgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIHVuZGVmaW5lZC5cbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmopID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhIHN0cmluZy5cbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuLyoqXG4gKiBSZXZlcnNlcyBhIGNvbXBhcmUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmV2ZXJzZUNvbXBhcmVGdW5jdGlvbihjb21wYXJlRnVuY3Rpb24pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQoY29tcGFyZUZ1bmN0aW9uKSB8fCAhaXNGdW5jdGlvbihjb21wYXJlRnVuY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlRnVuY3Rpb24oZCwgdikgKiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLnJldmVyc2VDb21wYXJlRnVuY3Rpb24gPSByZXZlcnNlQ29tcGFyZUZ1bmN0aW9uO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVxdWFsIGZ1bmN0aW9uIGdpdmVuIGEgY29tcGFyZSBmdW5jdGlvbi5cbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjb21wYXJlVG9FcXVhbHMoY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlRnVuY3Rpb24oYSwgYikgPT09IDA7XG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcGFyZVRvRXF1YWxzID0gY29tcGFyZVRvRXF1YWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJpbXBvcnQgUXVldWUgZnJvbSBcInR5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvUXVldWVcIjtcbmltcG9ydCB7aXNVbmRlZmluZWR9IGZyb20gXCJ0eXBlc2NyaXB0LWNvbGxlY3Rpb25zL2Rpc3QvbGliL3V0aWxcIjtcbmxldCBzaWdtYSA9IHJlcXVpcmUoJ3NpZ21hJyk7XG4oPGFueT53aW5kb3cpLnNpZ21hID0gc2lnbWE7XG5yZXF1aXJlKCdzaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzJyk7XG5yZXF1aXJlKCdzaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZS9zaWdtYS5wbHVnaW5zLmFuaW1hdGUnKTtcbnJlcXVpcmUoJ3NpZ21hL3BsdWdpbnMvc2lnbWEubGF5b3V0Lm5vdmVybGFwL3NpZ21hLmxheW91dC5ub3ZlcmxhcCcpO1xuXG5leHBvcnQgZW51bSBTdGF0dXMge1xuICAgIFJVTk5JTkcsXG4gICAgU1VDQ0VTUyxcbiAgICBGQUlMVVJFXG59XG5cbmZ1bmN0aW9uIHRlcm1pbmF0ZUFuZFJldHVybihpZDogbnVtYmVyLCBibGFja2JvYXJkOiBhbnksIHN0YXR1czogU3RhdHVzKSB7XG4gICAgZGVsZXRlIGJsYWNrYm9hcmRbaWRdO1xuICAgIHJldHVybiBzdGF0dXM7XG59XG5cbmV4cG9ydCB0eXBlIEVmZmVjdCA9ICgpID0+IHZvaWRcbmV4cG9ydCB0eXBlIFByZWNvbmRpdGlvbiA9ICgpID0+IGJvb2xlYW5cbmV4cG9ydCB0eXBlIFRpY2sgPSAoKSA9PiBTdGF0dXNcbmV4cG9ydCB0eXBlIEFjdGlvblRpY2sgPSAocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGVmZmVjdDogRWZmZWN0LCB0aWNrc1JlcXVpcmVkPzogbnVtYmVyKSA9PiBUaWNrXG4vKipcbiAqIFRoZSBndWFyZCB0aWNrIGlzIHRvIGFkZCBhIHByZWNvbmRpdGlvbiB0byB0aGUgY29tcG9zaXRlIHRpY2tzXG4gKi9cbmV4cG9ydCB0eXBlIEd1YXJkVGljayA9IChwcmVjb25kaXRpb246IFByZWNvbmRpdGlvbiwgYXN0VGljazogVGljaywgbmVnYXRlPzogYm9vbGVhbikgPT4gVGlja1xuLyoqXG4gKiBTZXF1ZW5jZS9TZWxlY3RvclxuICovXG5leHBvcnQgdHlwZSBDb21wb3NpdGVUaWNrID0gKGFzdFRpY2tzOiBUaWNrW10pID0+IFRpY2tcblxudmFyIGJsYWNrYm9hcmQgPSB7fTtcblxuZnVuY3Rpb24gZ2V0QWN0aW9uVGljayhpZDogbnVtYmVyKTogQWN0aW9uVGljayB7XG4gICAgcmV0dXJuIChwcmVjb25kaXRpb24sIGVmZmVjdCwgdGlja3NSZXF1aXJlZCA9IDEpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVjb25kaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGlmICghYmxhY2tib2FyZFtpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0udGlja3NEb25lID0gdGlja3NSZXF1aXJlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmxhY2tib2FyZFtpZF0udGlja3NEb25lID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXS50aWNrc0RvbmUtLTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1cy5SVU5OSU5HO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVybWluYXRlQW5kUmV0dXJuKGlkLCBibGFja2JvYXJkLCBTdGF0dXMuU1VDQ0VTUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzLkZBSUxVUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEd1YXJkVGljaygpOiBHdWFyZFRpY2sge1xuICAgIHJldHVybiAocHJlY29uZGl0aW9uLCBhc3RUaWNrLCBuZWdhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByb2NlZWQgPSBuZWdhdGUgPyAhcHJlY29uZGl0aW9uKCkgOiBwcmVjb25kaXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZWVkID8gZXhlY3V0ZShhc3RUaWNrKSA6IFN0YXR1cy5GQUlMVVJFO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZVRpY2soaWQ6IG51bWJlcik6IENvbXBvc2l0ZVRpY2sge1xuICAgIHJldHVybiAoYXN0VGlja3MpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxhY2tib2FyZFtpZF0pIHtcbiAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXSA9IHt9O1xuICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChibGFja2JvYXJkW2lkXS5jdXJyZW50SW5kZXggPCBhc3RUaWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTdGF0dXMgPSBleGVjdXRlKGFzdFRpY2tzW2JsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkU3RhdHVzID09IFN0YXR1cy5SVU5OSU5HKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzLlJVTk5JTkc7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRTdGF0dXMgPT0gU3RhdHVzLkZBSUxVUkUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hdGVBbmRSZXR1cm4oaWQsIGJsYWNrYm9hcmQsIFN0YXR1cy5GQUlMVVJFKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFN0YXR1cyA9PSBTdGF0dXMuU1VDQ0VTUylcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVybWluYXRlQW5kUmV0dXJuKGlkLCBibGFja2JvYXJkLCBTdGF0dXMuU1VDQ0VTUyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yVGljayhpZDogbnVtYmVyKTogQ29tcG9zaXRlVGljayB7XG4gICAgcmV0dXJuIChhc3RUaWNrcykgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFibGFja2JvYXJkW2lkXSkge1xuICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdID0ge307XG4gICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGJsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleCA8IGFzdFRpY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFN0YXR1cyA9IGV4ZWN1dGUoYXN0VGlja3NbYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRTdGF0dXMgPT0gU3RhdHVzLlJVTk5JTkcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXMuUlVOTklORztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFN0YXR1cyA9PSBTdGF0dXMuU1VDQ0VTUylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlcm1pbmF0ZUFuZFJldHVybihpZCwgYmxhY2tib2FyZCwgU3RhdHVzLlNVQ0NFU1MpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkU3RhdHVzID09IFN0YXR1cy5GQUlMVVJFKVxuICAgICAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXS5jdXJyZW50SW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hdGVBbmRSZXR1cm4oaWQsIGJsYWNrYm9hcmQsIFN0YXR1cy5GQUlMVVJFKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGUoYXN0VGljazogVGljayk6IFN0YXR1cyB7XG4gICAgcmV0dXJuIGFzdFRpY2soKTtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb24ocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGVmZmVjdDogRWZmZWN0LCB0aWNrc1JlcXVpcmVkPzogbnVtYmVyKTogVGljayB7XG4gICAgcmV0dXJuIGdldEFjdGlvblRpY2soZ2xvYmFsSWRDb3VudGVyKyspKHByZWNvbmRpdGlvbiwgZWZmZWN0LCB0aWNrc1JlcXVpcmVkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3VhcmQocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGFzdFRpY2s6IFRpY2spOiBUaWNrIHtcbiAgICByZXR1cm4gZ2V0R3VhcmRUaWNrKCkocHJlY29uZGl0aW9uLCBhc3RUaWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ19ndWFyZChwcmVjb25kaXRpb246IFByZWNvbmRpdGlvbiwgYXN0VGljazogVGljayk6IFRpY2sge1xuICAgIHJldHVybiBnZXRHdWFyZFRpY2soKShwcmVjb25kaXRpb24sIGFzdFRpY2ssIHRydWUpO1xufVxuXG4vKipcbiAqIEN5Y2xlcyBvdmVyIGl0cyBjaGlsZHJlbjogaXRlcmF0ZXMgdG8gdGhlIG5leHQgY2hpbGQgb24gc3VjY2VzcyBvZiBhIGNoaWxkXG4gKiBTdWNjZWVkcyBpZiBhbGwgc3VjY2VlZCwgZWxzZSBmYWlsc1xuICogQHBhcmFtIHtUaWNrW119IGFzdFRpY2tzXG4gKiBAcmV0dXJucyB7VGlja31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbmNlKGFzdFRpY2tzOiBUaWNrW10pOiBUaWNrIHtcbiAgICByZXR1cm4gZ2V0U2VxdWVuY2VUaWNrKGdsb2JhbElkQ291bnRlcisrKShhc3RUaWNrcyk7XG59XG5cbi8qKlxuICogQ3ljbGVzIG92ZXIgaXRzIGNoaWxkcmVuOiBpdGVyYXRlcyB0byB0aGUgbmV4dCBjaGlsZCBvbiBmYWlsdXJlIG9mIGEgY2hpbGQodGhpbmsgb2YgaXQgYXMgaWYtZWxzZSBibG9ja3MpXG4gKiBTdWNjZWVkcyBpZiBldmVuIG9uZSBzdWNjZWVkcywgZWxzZSBmYWlsc1xuICogQHBhcmFtIHtUaWNrW119IGFzdFRpY2tzXG4gKiBAcmV0dXJucyB7VGlja31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdG9yKGFzdFRpY2tzOiBUaWNrW10pOiBUaWNrIHtcbiAgICByZXR1cm4gZ2V0U2VsZWN0b3JUaWNrKGdsb2JhbElkQ291bnRlcisrKShhc3RUaWNrcyk7XG59XG5cblxuLyotLS0tLS0tLS0tLS0tLS0gQVBJcyAtLS0tLS0tLS0tLS0tLS0gKi9cblxuXG4vLzAuIHV0aWxpdGllc1xuLy8gbWluIGFuZCBtYXggYXJlIGluY2x1c2l2ZVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmROdW1iZXIobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbn1cblxuLy8xLiBzdG9yeSBpbnN0YW5jZVxuXG4vLzEuMSBsb2NhdGlvbnNcbmV4cG9ydCB2YXIgbG9jYXRpb25HcmFwaCA9IHt9O1xuXG4vL2FkZCB0byBib3RoIHNpZGVzXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25OYW1lOiBzdHJpbmcsIGFkamFjZW50TG9jYXRpb25zOiBzdHJpbmdbXSkge1xuICAgIGlmIChsb2NhdGlvbkdyYXBoW2xvY2F0aW9uTmFtZV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2F0aW9uR3JhcGhbbG9jYXRpb25OYW1lXSA9IFtdO1xuICAgIH1cbiAgICBsb2NhdGlvbkdyYXBoW2xvY2F0aW9uTmFtZV0gPSBsb2NhdGlvbkdyYXBoW2xvY2F0aW9uTmFtZV0uY29uY2F0KGFkamFjZW50TG9jYXRpb25zKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRqYWNlbnRMb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uR3JhcGhbYWRqYWNlbnRMb2NhdGlvbnNbaV1dID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb25HcmFwaFthZGphY2VudExvY2F0aW9uc1tpXV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhdGlvbkdyYXBoW2FkamFjZW50TG9jYXRpb25zW2ldXS5wdXNoKGxvY2F0aW9uTmFtZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJlQWRqYWNlbnQobG9jYXRpb24xOiBzdHJpbmcsIGxvY2F0aW9uMjogc3RyaW5nKTpib29sZWFuIHtcbiAgICBjb25zb2xlLmxvZyhcIkFyZSBhZGphY2VudDogXCIgKyBsb2NhdGlvbjEgKyBcIiwgXCIrbG9jYXRpb24yKTtcbiAgICBpZiAobG9jYXRpb25HcmFwaFtsb2NhdGlvbjFdID09IHVuZGVmaW5lZCB8fCBsb2NhdGlvbkdyYXBoW2xvY2F0aW9uMl0gPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFaXRoZXIgb25lL2JvdGggbG9jYXRpb25zIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYXRpb25HcmFwaFtsb2NhdGlvbjFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbkdyYXBoW2xvY2F0aW9uMV1baV0gPT0gbG9jYXRpb24yKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9wYXRoZmluZGluZyBwcmltaXRpdmVzXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dExvY2F0aW9uKHN0YXJ0OiBzdHJpbmcsIGRlc3RpbmF0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHZhciB2aXNpdGVkID0ge307XG4gICAgdmFyIHByZXZpb3VzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGxvY2F0aW9uR3JhcGgpIHtcbiAgICAgICAgdmlzaXRlZFtrZXldID0gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0ZWRbc3RhcnRdID0gdHJ1ZTtcblxuICAgIHZhciBteVF1ZXVlID0gbmV3IFF1ZXVlPHN0cmluZz4oKTtcbiAgICBteVF1ZXVlLmVucXVldWUoc3RhcnQpO1xuXG4gICAgd2hpbGUgKCFteVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgY3VycmVudDogc3RyaW5nID0gbXlRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IGxvY2F0aW9uR3JhcGhbY3VycmVudF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtuZWlnaGJvcnNbaV1dKSB7XG4gICAgICAgICAgICAgICAgbXlRdWV1ZS5lbnF1ZXVlKG5laWdoYm9yc1tpXSk7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtuZWlnaGJvcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1tuZWlnaGJvcnNbaV1dID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjdXJyZW50OiBzdHJpbmcgPSBkZXN0aW5hdGlvbjtcbiAgICBpZiAoY3VycmVudCA9PSBzdGFydClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgd2hpbGUgKHByZXZpb3VzW2N1cnJlbnRdICE9IHN0YXJ0KSB7XG4gICAgICAgIGN1cnJlbnQgPSBwcmV2aW91c1tjdXJyZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudDtcbn1cblxuLy8xLjIgYWdlbnRzXG52YXIgYWdlbnRzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRBZ2VudChhZ2VudE5hbWU6IHN0cmluZykge1xuICAgIGFnZW50cy5wdXNoKGFnZW50TmFtZSk7XG4gICAgcmV0dXJuIGFnZW50TmFtZTtcbn1cblxuLy8xLjMgaXRlbXNcbnZhciBpdGVtcyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSXRlbShpdGVtTmFtZTogc3RyaW5nKSB7XG4gICAgaXRlbXMucHVzaChpdGVtTmFtZSk7XG4gICAgcmV0dXJuIGl0ZW1OYW1lO1xufVxuXG4vLzEuNCB2YXJpYWJsZXNcbnZhciB2YXJpYWJsZXMgPSB7fTtcbnZhciBhZ2VudFZhcmlhYmxlcyA9IHt9O1xudmFyIGl0ZW1WYXJpYWJsZXMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFZhcmlhYmxlKHZhck5hbWU6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIHZhcmlhYmxlc1t2YXJOYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB2YXJOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QWdlbnRWYXJpYWJsZShhZ2VudDogc3RyaW5nLCB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdKSlcbiAgICAgICAgYWdlbnRWYXJpYWJsZXNbYWdlbnRdID0ge307XG5cbiAgICBhZ2VudFZhcmlhYmxlc1thZ2VudF1bdmFyTmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYWJsZSh2YXJOYW1lOiBzdHJpbmcpOiBhbnkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh2YXJpYWJsZXNbdmFyTmFtZV0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyB2YXJOYW1lICsgXCIgbm90IHNldCFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlc1t2YXJOYW1lXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZW50VmFyaWFibGUoYWdlbnQ6IHN0cmluZywgdmFyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGFnZW50VmFyaWFibGVzW2FnZW50XSkgfHwgaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdW3Zhck5hbWVdKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZhcmlhYmxlIFwiICsgdmFyTmFtZSArIFwiIGZvciBhZ2VudCBcIiArIGFnZW50ICsgXCIgbm90IHNldCFcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYWdlbnRWYXJpYWJsZXNbYWdlbnRdW3Zhck5hbWVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYXJpYWJsZU5vdFNldCh2YXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmFyaWFibGVzW3Zhck5hbWVdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWdlbnRWYXJpYWJsZU5vdFNldChhZ2VudDogc3RyaW5nLCB2YXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdKSB8fCBpc1VuZGVmaW5lZChhZ2VudFZhcmlhYmxlc1thZ2VudF1bdmFyTmFtZV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SXRlbVZhcmlhYmxlKGl0ZW06IHN0cmluZywgdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV0pKVxuICAgICAgICBpdGVtVmFyaWFibGVzW2l0ZW1dID0ge307XG5cbiAgICBpdGVtVmFyaWFibGVzW2l0ZW1dW3Zhck5hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlbVZhcmlhYmxlKGl0ZW06IHN0cmluZywgdmFyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV0pIHx8IGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV1bdmFyTmFtZV0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyB2YXJOYW1lICsgXCIgZm9yIGl0ZW0gXCIgKyBpdGVtICsgXCIgbm90IHNldCFcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbVZhcmlhYmxlc1tpdGVtXVt2YXJOYW1lXTtcbn1cblxuXG4vLzJcbi8vYWdlbnQtYmVoYXZpb3IgdHJlZSBtYXBwaW5nXG52YXIgYWdlbnRUcmVlcyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoVHJlZVRvQWdlbnQoYWdlbnQ6IHN0cmluZywgdHJlZTogVGljaykge1xuICAgIGFnZW50VHJlZXNbYWdlbnRdID0gdHJlZTtcbn1cblxuLy8zLjFcbi8vdXNlciBhY3Rpb25zXG4vL1RPRE8gYWRkIHZhcmlhYmxlcyB0byB1c2VyIGFjdGlvbiB0ZXh0c1xudmFyIHVzZXJJbnRlcmFjdGlvbk9iamVjdCA9IHtcbiAgICB0ZXh0OiBcIlwiLFxuICAgIHVzZXJBY3Rpb25zVGV4dDogW10sXG4gICAgYWN0aW9uRWZmZWN0c1RleHQ6IFwiXCJcbn1cbnZhciB1c2VySW50ZXJhY3Rpb25UcmVlcyA9IFtdO1xudmFyIHVzZXJBY3Rpb25zID0ge307XG5cbmZ1bmN0aW9uIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCkge1xuICAgIHVzZXJJbnRlcmFjdGlvbk9iamVjdC50ZXh0ID0gXCJcIjtcbiAgICB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0ID0gW107XG4gICAgdXNlckFjdGlvbnMgPSB7fTsvL3tcIkdvIHRvIGxvY2F0aW9uIFhcIiA6IGVmZmVjdFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlckludGVyYWN0aW9uVHJlZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhlY3V0ZSh1c2VySW50ZXJhY3Rpb25UcmVlc1tpXSk7XG4gICAgfVxufVxuXG5leHBvcnQgbGV0IGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbiA9ICh0ZXh0OiBzdHJpbmcpID0+XG4gICAgYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiB1c2VySW50ZXJhY3Rpb25PYmplY3QudGV4dCArPSBcIlxcblwiICsgdGV4dCwgMFxuICAgICk7XG5leHBvcnQgbGV0IGRpc3BsYXlBY3Rpb25FZmZlY3RUZXh0ID0gKHRleHQ6IHN0cmluZykgPT4gdXNlckludGVyYWN0aW9uT2JqZWN0LmFjdGlvbkVmZmVjdHNUZXh0ICs9IFwiXFxuXCIgKyB0ZXh0O1xuXG5leHBvcnQgbGV0IGFkZFVzZXJBY3Rpb25UcmVlID0gKHRleHQ6IHN0cmluZywgZWZmZWN0VHJlZTogVGljaykgPT4gYWN0aW9uKFxuICAgICgpID0+IHRydWUsXG4gICAgKCkgPT4gbWFwVXNlckFjdGlvblRvVHJlZSh0ZXh0LCBlZmZlY3RUcmVlKSwgMFxuKTtcblxuZXhwb3J0IGxldCBhZGRVc2VyQWN0aW9uID0gKHRleHQ6IHN0cmluZywgZWZmZWN0OiAoKSA9PiBhbnkpID0+XG4gICAgYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiBtYXBVc2VyQWN0aW9uVG9UcmVlKHRleHQsIGFjdGlvbigoKT0+dHJ1ZSwgZWZmZWN0LCAwKSksIDBcbiAgICApO1xuXG5mdW5jdGlvbiBtYXBVc2VyQWN0aW9uVG9UcmVlKHRleHQ6IHN0cmluZywgdHJlZTogVGljaykge1xuICAgIHVzZXJBY3Rpb25zW3RleHRdID0gdHJlZTtcbiAgICB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0LnB1c2godGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKHRpY2s6IFRpY2spIHtcbiAgICB1c2VySW50ZXJhY3Rpb25UcmVlcy5wdXNoKHRpY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZVVzZXJBY3Rpb24odGV4dDogc3RyaW5nKSB7XG4gICAgLy9leGVjdXRlIHRoZSB1c2VyIGFjdGlvblxuICAgIHVzZXJJbnRlcmFjdGlvbk9iamVjdC5hY3Rpb25FZmZlY3RzVGV4dCA9IFwiXCI7XG4gICAgdmFyIHVzZXJBY3Rpb25FZmZlY3RUcmVlID0gdXNlckFjdGlvbnNbdGV4dF07XG4gICAgZXhlY3V0ZSh1c2VyQWN0aW9uRWZmZWN0VHJlZSk7XG59XG5cbi8vNC5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VySW50ZXJhY3Rpb25PYmplY3QoKSB7XG4gICAgcmV0dXJuIHVzZXJJbnRlcmFjdGlvbk9iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVGljaygpIHtcbiAgICAvL2FsbCBhZ2VudCB0aWNrc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWdlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmVlID0gYWdlbnRUcmVlc1thZ2VudHNbaV1dO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRyZWUpKSB7XG4gICAgICAgICAgICBzZXRWYXJpYWJsZShcImV4ZWN1dGluZ0FnZW50XCIsIGFnZW50c1tpXSk7XG4gICAgICAgICAgICBleGVjdXRlKHRyZWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCk7XG59IiwiLyogLy8vIDxyZWZlcmVuY2UgcGF0aD1cInNjcmlwdGluZy50c1wiLz4gKi9cbmltcG9ydCB7XG4gICAgYWRkQWdlbnQsIHNldEFnZW50VmFyaWFibGUsIGFkZEl0ZW0sIGFkZExvY2F0aW9uLCBzZXRWYXJpYWJsZSwgZ2V0TmV4dExvY2F0aW9uLCBhY3Rpb24sXG4gICAgZ2V0UmFuZE51bWJlciwgZ2V0VmFyaWFibGUsIHNlcXVlbmNlLCBzZWxlY3RvciwgZXhlY3V0ZSwgUHJlY29uZGl0aW9uLCBnZXRBZ2VudFZhcmlhYmxlLCBuZWdfZ3VhcmQsIGd1YXJkLFxuICAgIGlzVmFyaWFibGVOb3RTZXQsIGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbiwgYWRkVXNlckFjdGlvbiwgYWRkVXNlckludGVyYWN0aW9uVHJlZSwgaW5pdGlhbGl6ZSxcbiAgICBnZXRVc2VySW50ZXJhY3Rpb25PYmplY3QsIGV4ZWN1dGVVc2VyQWN0aW9uLCB3b3JsZFRpY2ssIGF0dGFjaFRyZWVUb0FnZW50LCBzZXRJdGVtVmFyaWFibGUsIGdldEl0ZW1WYXJpYWJsZSxcbiAgICBkaXNwbGF5QWN0aW9uRWZmZWN0VGV4dCwgYXJlQWRqYWNlbnQsIGFkZFVzZXJBY3Rpb25UcmVlLCBsb2NhdGlvbkdyYXBoLCBUaWNrXG59IGZyb20gXCIuL3NjcmlwdGluZ1wiO1xuaW1wb3J0IHtpc1VuZGVmaW5lZH0gZnJvbSBcInR5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvdXRpbFwiO1xuXG5sZXQgc2lnbWEgPSByZXF1aXJlKCdsaW5rdXJpb3VzJyk7XG4oPGFueT53aW5kb3cpLnNpZ21hID0gc2lnbWE7XG5yZXF1aXJlKCdsaW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMnKTtcbnJlcXVpcmUoJ2xpbmt1cmlvdXMvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmFuaW1hdGUvc2lnbWEucGx1Z2lucy5hbmltYXRlJyk7XG5yZXF1aXJlKCdsaW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEubGF5b3V0cy5ub3ZlcmxhcC9zaWdtYS5sYXlvdXRzLm5vdmVybGFwJyk7XG5yZXF1aXJlKCdsaW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucmVuZGVyZXJzLmxpbmt1cmlvdXMvY2FudmFzL3NpZ21hLmNhbnZhcy5ub2Rlcy5kZWYnKTtcblxudHlwZSBtYXBzID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9O1xuXG52YXIgZmlsZVByZWZpeCA9IFwiLi4vZGF0YS91bml2ZXJzaXR5L1wiO1xudmFyIGZpbGVTdWZmaXggPSBcIi5jc3ZcIlxubGV0IGZpbGVzID0gW1wiY2ZnR3JhbW1hXCIsIFwiUHJlZml4XCJdXG5cbmNsYXNzIGNmZ1RyZWVzIHtcbiAgICBwcml2YXRlIHZhbDogc3RyaW5nO1xuICAgIHByaXZhdGUgYnJhbmNoZXM6IGNmZ1RyZWVzW10gfCBudWxsO1xuICAgIHByaXZhdGUgaWRMYWJlbDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBydWxlOiBtYXBzLCBwcmVmaXg6IHN0cmluZ1tdLCBwcmV2TmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHZhciBjbGVhbk5hbWU6IHN0cmluZztcbiAgICAgICAgdGhpcy5icmFuY2hlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaWRMYWJlbCA9IHt9XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICAgICAgdGhpcy5icmFuY2hlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG5hbWUuZW5kc1dpdGgoJyonKSkge1xuICAgICAgICAgICAgICAgIGNsZWFuTmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWwgPSBjbGVhbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pZExhYmVsW3RoaXMudmFsXSA9IGNsZWFuTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5OYW1lID0gbmFtZS5zdWJzdHJpbmcoMSwgbmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbCA9IHByZXZOYW1lICsgXCIgXCIgKyBjbGVhbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pZExhYmVsW3RoaXMudmFsXSA9IGNsZWFuTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW5OYW1lID0gbmFtZS5zdWJzdHJpbmcoMSwgbmFtZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsID0gcmV0UmFuZChwcmVmaXgpICsgXCIgXCIgKyBjbGVhbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pZExhYmVsW3RoaXMudmFsXSA9IHRoaXMudmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW46IHN0cmluZ1tdID0gcnVsZVtjbGVhbk5hbWVdO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QnJhbmNoID0gbmV3IGNmZ1RyZWVzKHZhbHVlLCBydWxlLCBwcmVmaXgsIHRoaXMudmFsKTtcbiAgICAgICAgICAgICAgICBjb21iaW5lKHRoaXMuaWRMYWJlbCwgbmV3QnJhbmNoLmlkTGFiZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJhbmNoZXMucHVzaChuZXdCcmFuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUuZW5kc1dpdGgoJyonKSkge1xuICAgICAgICAgICAgY2xlYW5OYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHRoaXMudmFsID0gY2xlYW5OYW1lO1xuICAgICAgICAgICAgdGhpcy5pZExhYmVsW3RoaXMudmFsXSA9IGNsZWFuTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lLmVuZHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgIGNsZWFuTmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB0aGlzLnZhbCA9IHByZXZOYW1lICsgXCIgXCIgKyBjbGVhbk5hbWU7XG4gICAgICAgICAgICB0aGlzLmlkTGFiZWxbdGhpcy52YWxdID0gY2xlYW5OYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYW5OYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMudmFsID0gcmV0UmFuZChwcmVmaXgpICsgXCIgXCIgKyBjbGVhbk5hbWU7XG4gICAgICAgICAgICB0aGlzLmlkTGFiZWxbdGhpcy52YWxdID0gdGhpcy52YWxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbDtcbiAgICB9XG5cbiAgICBnZXRCcmFuY2hlcygpOiBjZmdUcmVlc1tdIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYW5jaGVzO1xuICAgIH1cblxuICAgIGlzTGVhZigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJyYW5jaGVzID09IG51bGwpO1xuICAgIH1cblxuICAgIGdldElkTGFiZWxQYWlyKCk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgICAgICByZXR1cm4gdGhpcy5pZExhYmVsO1xuICAgIH1cblxuICAgIGdldEJyYW5jaFZhbHVlcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIGxldCByZXQ6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmICh0aGlzLmJyYW5jaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHRoaXMuYnJhbmNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh2YWx1ZS52YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZ2V0RXhwYW5kTGlzdCgpOiBtYXBzIHtcbiAgICAgICAgbGV0IGV4cGFuZExpc3Q6IG1hcHMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYnJhbmNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXhwYW5kTGlzdFt0aGlzLnZhbF0gPSB0aGlzLmdldEJyYW5jaFZhbHVlcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSBvZiB0aGlzLmJyYW5jaGVzKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZShleHBhbmRMaXN0LCB0cmVlLmdldEV4cGFuZExpc3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGFuZExpc3Q7XG4gICAgfVxuXG4gICAgZ2V0UHJldm5hbWVMaXN0KCk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgICAgICBsZXQgUHJldm5hbWVMaXN0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgIGZvciAodmFyIG5hbWUgb2YgdGhpcy5nZXRCcmFuY2hWYWx1ZXMoKSkge1xuICAgICAgICAgICAgUHJldm5hbWVMaXN0W25hbWVdID0gdGhpcy52YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnJhbmNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSBvZiB0aGlzLmJyYW5jaGVzKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZShQcmV2bmFtZUxpc3QsIHRyZWUuZ2V0UHJldm5hbWVMaXN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcmV2bmFtZUxpc3Q7XG4gICAgfVxuXG4gICAgZ2V0RXhwYW5kR3JhcGgoKTogeyBba2V5OiBzdHJpbmddOiBtYXBzIH0ge1xuICAgICAgICBsZXQgZXhwYW5kTGlzdCA9IHRoaXMuZ2V0RXhwYW5kTGlzdCgpO1xuICAgICAgICBsZXQgZXhwYW5kR3JhcGg6IHsgW2tleTogc3RyaW5nXTogbWFwcyB9ID0ge307XG4gICAgICAgIGZvciAodmFyIGtleXMgb2YgT2JqZWN0LmtleXMoZXhwYW5kTGlzdCkpIHtcbiAgICAgICAgICAgIGV4cGFuZEdyYXBoW2tleXNdID0gY29ubmVjdE5vZGVzKGV4cGFuZExpc3Rba2V5c10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBhbmRHcmFwaDtcbiAgICB9XG5cbiAgICAvL1RoaXMgbWV0aG9kIGlnbm9yZXMgdGhlIGZpcnN0IHZhbHVlIG9mIHRoZSB0cmVlXG4gICAgZ2V0QWxsVmFsdWVzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgdmFyIHJldDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgcmV0ID0gcmV0LmNvbmNhdCh0aGlzLmdldEJyYW5jaFZhbHVlcygpKTtcbiAgICAgICAgaWYgKHRoaXMuYnJhbmNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSBvZiB0aGlzLmJyYW5jaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdCh0cmVlLmdldEJyYW5jaFZhbHVlcygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcHJpbnQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmJyYW5jaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYnJhbmNoZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdGhpcy5icmFuY2hlcykge1xuICAgICAgICAgICAgICAgIHZhbHVlLnByaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gY29tYmluZShkaWN0MTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSwgZGljdDI6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICBmb3IgKHZhciB2YWwgb2YgT2JqZWN0LmtleXMoZGljdDIpKSB7XG4gICAgICAgIGRpY3QxW3ZhbF0gPSBkaWN0Mlt2YWxdO1xuICAgIH1cbiAgICByZXR1cm4gZGljdDE7XG59XG5cbmZ1bmN0aW9uIHJldFJhbmQobGlzdDogYW55W10pIHtcbiAgICB2YXIgaW5kZXggPSBnZXRSYW5kTnVtYmVyKDAsIGxpc3QubGVuZ3RoIC0gMSk7XG4gICAgdmFyIHJldCA9IGxpc3RbaW5kZXhdO1xuICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZXMoKTogUHJvbWlzZTxtYXBzPiB7XG4gICAgbGV0IGRhdGE6IG1hcHMgPSB7fTtcblxuICAgIGZvciAodmFyIGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLnJlc3BvbnNlVGV4dC5zcGxpdCgvXFxufFxcclxcbi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZmlsZV0gPSBsaW5lcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKHJlcS5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxLm9wZW4oXCJHRVRcIiwgZmlsZVByZWZpeCArIGZpbGUgKyBmaWxlU3VmZml4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXEucmVzcG9uc2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgcmVxLnNlbmQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbn1cblxucmVhZEZpbGVzKCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgdHJlZTogY2ZnVHJlZXMgPSBwcm9jZXNzRGF0YSh2YWx1ZSk7XG4gICAgSW5pdGlhbGl6ZVZpbGlsbGFuZSh0cmVlKTtcbn0pXG5cbmZ1bmN0aW9uIHByb2Nlc3NEYXRhKGRhdGE6IG1hcHMpOiBjZmdUcmVlcyB7XG4gICAgbGV0IFByZWZpeDogc3RyaW5nW10gPSBkYXRhWydQcmVmaXgnXTtcbiAgICBsZXQgbmV3UnVsZTogbWFwcyA9IHt9O1xuICAgIGxldCByYXdSdWxlID0gZGF0YVsnY2ZnR3JhbW1hJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByb3dzID0gcmF3UnVsZVtpXS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByb3dzWzFdLnNwbGl0KCc7Jyk7XG4gICAgICAgIHZhciByZXN1bHQ6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IGNoaWxkcmVuW2pdLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBsZXQgbnVtID0gZ2V0UmFuZE51bWJlcihOdW1iZXIoZWxlbWVudHNbMV0pLCBOdW1iZXIoZWxlbWVudHNbMl0pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnVtOyBrKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50c1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3UnVsZVtyb3dzWzBdXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IG5ld1RyZWUgPSBuZXcgY2ZnVHJlZXMoJyNVbml2ZXJzaXR5JywgbmV3UnVsZSwgUHJlZml4LCAnJyk7XG4gICAgcmV0dXJuIG5ld1RyZWU7XG59XG5cblxuZnVuY3Rpb24gY29ubmVjdE5vZGVzKGxvY2F0aW9uOiBzdHJpbmdbXSk6IG1hcHMge1xuICAgIGxldCBub2RlczogbWFwcyA9IHt9O1xuICAgIGxldCB2aXNpdGVkOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmlzaXRlZFtsb2NhdGlvbltpXV0gPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCByZXN0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy9yYW5kb21seSBnZW5lcmF0ZSBhIGdyYXBoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQobm9kZXNbbG9jYXRpb25baV1dKSkge1xuICAgICAgICAgICAgbm9kZXNbbG9jYXRpb25baV1dID0gW11cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsb2NhdGlvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vZGVzW2xvY2F0aW9uW2pdXSkpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tsb2NhdGlvbltqXV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgKDIgLyBsb2NhdGlvbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbbG9jYXRpb25baV1dLnB1c2gobG9jYXRpb25bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vbWFraW5nIHN1cmUgaXQgaXMgY29ubmVjdGVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodmlzaXRlZFtsb2NhdGlvbltpXV0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxldCBpdGVtOiBzdHJpbmcgPSBsb2NhdGlvbltpXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobG9jYXRpb25baV0pO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW2N1cl0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbY3VyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2Ygbm9kZXNbY3VyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5vZGVzW3Jlc3RbaV1dLnB1c2gocmVzdFtpICsgMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5cblxuZnVuY3Rpb24gSW5pdGlhbGl6ZVZpbGlsbGFuZShUcmVlOiBjZmdUcmVlcykge1xuICAgIHZhciBleHBhbmRHcmFwaDogeyBba2V5OiBzdHJpbmddOiBtYXBzIH0gPSBUcmVlLmdldEV4cGFuZEdyYXBoKCk7XG4gICAgdmFyIGV4cGFuZExpc3Q6IG1hcHMgPSBUcmVlLmdldEV4cGFuZExpc3QoKTtcbiAgICB2YXIgaWRMYWJlbFBhaXI6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSBUcmVlLmdldElkTGFiZWxQYWlyKCk7XG4gICAgdmFyIFByZXZuYW1lTGlzdDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IFRyZWUuZ2V0UHJldm5hbWVMaXN0KCk7XG4gICAgdmFyIGJvb2w6IHsgW2tleXM6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuICAgIGZvciAodmFyIHZhbCBvZiBUcmVlLmdldEFsbFZhbHVlcygpKSB7XG4gICAgICAgIGJvb2xbdmFsXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vQWRkIGxvY2F0aW9ucyB0byB2aWxsYW5lbGxlXG4gICAgZnVuY3Rpb24gYWRkTG9jYXRpb25HcmFwaChncmFwaDogbWFwcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZ3JhcGgpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFRyZWUuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGFkZExvY2F0aW9uKGtleSwgZ3JhcGhba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRMb2NhdGlvbkdyYXBoKGV4cGFuZExpc3QpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGV4cGFuZEdyYXBoKSB7XG4gICAgICAgIGFkZExvY2F0aW9uR3JhcGgoZXhwYW5kR3JhcGhba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9ucyA9IE9iamVjdC5rZXlzKGxvY2F0aW9uR3JhcGgpO1xuLy8gYWdlbnRzXG4gICAgdmFyIGFsaWVuID0gYWRkQWdlbnQoXCJBbGllblwiKTtcblxuLy8gaXRlbXNcblxuICAgIHZhciBjcmV3Q2FyZDEgPSBhZGRJdGVtKFwiQ3JldyBjYXJkMVwiKTtcbiAgICB2YXIgY3Jld0NhcmQyID0gYWRkSXRlbShcIkNyZXcgY2FyZDJcIik7XG4gICAgc2V0SXRlbVZhcmlhYmxlKGNyZXdDYXJkMSwgXCJjdXJyZW50TG9jYXRpb25cIiwgcmV0UmFuZChsb2NhdGlvbnMpKTtcbiAgICBzZXRJdGVtVmFyaWFibGUoY3Jld0NhcmQyLCBcImN1cnJlbnRMb2NhdGlvblwiLCByZXRSYW5kKGxvY2F0aW9ucykpO1xuXG4vLyB2YXJpYWJsZXNcblxuLy9hbGllblxuXG4gICAgc2V0QWdlbnRWYXJpYWJsZShhbGllbiwgXCJjdXJyZW50TG9jYXRpb25cIiwgcmV0UmFuZChsb2NhdGlvbnMpKTtcblxuLy9wbGF5ZXJcbiAgICB2YXIgcGxheWVyTG9jYXRpb24gPSBzZXRWYXJpYWJsZShcInBsYXllckxvY2F0aW9uXCIsIHJldFJhbmQobG9jYXRpb25zKSk7XG4gICAgdmFyIGNyZXdDYXJkc0NvbGxlY3RlZCA9IHNldFZhcmlhYmxlKFwiY3Jld0NhcmRzQ29sbGVjdGVkXCIsIDApO1xuICAgIGNvbnNvbGUubG9nKGdldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKSk7XG5cbi8vIDIuIERlZmluZSBCVHNcbi8vIGNyZWF0ZSBncm91bmQgYWN0aW9uc1xuXG4gICAgLy9SZWNvdmVyIGxvY2F0aW9uIGFycmF5XG4gICAgbG9jYXRpb25zID0gT2JqZWN0LmtleXMobG9jYXRpb25HcmFwaCk7XG4gICAgbGV0IHNldFJhbmROdW1iZXIgPSBhY3Rpb24oXG4gICAgICAgICgpID0+IHRydWUsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHNldFZhcmlhYmxlKFwicmFuZE51bWJlclwiLCBnZXRSYW5kTnVtYmVyKDEsIGxvY2F0aW9ucy5sZW5ndGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICk7XG5cbiAgICB2YXIgQlRsaXN0OiBUaWNrW10gPSBbXTtcbiAgICBsZXQgaWQ6IG51bWJlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhsb2NhdGlvbnNbaV0pO1xuICAgICAgICBsZXQgYWN0aW9uczogVGljayA9IGFjdGlvbigoKSA9PiBnZXRWYXJpYWJsZShcInJhbmROdW1iZXJcIikgPT0gaSArIDEsICgpID0+IHNldFZhcmlhYmxlKFwiZGVzdGluYXRpb25cIiwgbG9jYXRpb25zW2ldKSwgMCk7XG4gICAgICAgIEJUbGlzdC5wdXNoKGFjdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgYXREZXN0aW5hdGlvbjogUHJlY29uZGl0aW9uID0gKCkgPT4gZ2V0VmFyaWFibGUoXCJkZXN0aW5hdGlvblwiKSA9PSBnZXRBZ2VudFZhcmlhYmxlKGFsaWVuLCBcImN1cnJlbnRMb2NhdGlvblwiKTtcbiAgICBsZXQgc2V0RGVzdGluYXRpb25QcmVjb25kOiBQcmVjb25kaXRpb24gPSAoKSA9PiBpc1ZhcmlhYmxlTm90U2V0KFwiZGVzdGluYXRpb25cIikgfHwgYXREZXN0aW5hdGlvbigpO1xuXG4vLyBjcmVhdGUgYmVoYXZpb3IgdHJlZXNcbiAgICBsZXQgc2V0TmV4dERlc3RpbmF0aW9uID0gc2VxdWVuY2UoW1xuICAgICAgICBzZXRSYW5kTnVtYmVyLFxuICAgICAgICBzZWxlY3RvcihCVGxpc3QpLFxuICAgIF0pO1xuXG4gICAgbGV0IGdvdG9OZXh0TG9jYXRpb24gPSBhY3Rpb24oXG4gICAgICAgICgpID0+IHRydWUsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHNldEFnZW50VmFyaWFibGUoYWxpZW4sIFwiY3VycmVudExvY2F0aW9uXCIsIGdldE5leHRMb2NhdGlvbihnZXRBZ2VudFZhcmlhYmxlKGFsaWVuLCBcImN1cnJlbnRMb2NhdGlvblwiKSwgZ2V0VmFyaWFibGUoXCJkZXN0aW5hdGlvblwiKSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBbGllbiBpcyBhdDogXCIgKyBnZXRBZ2VudFZhcmlhYmxlKGFsaWVuLCBcImN1cnJlbnRMb2NhdGlvblwiKSlcbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICk7XG5cbiAgICBsZXQgZWF0UGxheWVyID0gYWN0aW9uKCgpID0+IGdldEFnZW50VmFyaWFibGUoYWxpZW4sIFwiY3VycmVudExvY2F0aW9uXCIpID09IGdldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgc2V0VmFyaWFibGUoXCJlbmRHYW1lXCIsIFwibG9zZVwiKTtcbiAgICAgICAgICAgIHNldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uLCBcIk5BXCIpO1xuICAgICAgICB9LCAwXG4gICAgKTtcblxuICAgIGxldCBzZWFyY2ggPSBzZXF1ZW5jZShbXG4gICAgICAgIHNlbGVjdG9yKFtcbiAgICAgICAgICAgIGd1YXJkKHNldERlc3RpbmF0aW9uUHJlY29uZCwgc2V0TmV4dERlc3RpbmF0aW9uKSxcbiAgICAgICAgICAgIGFjdGlvbigoKSA9PiB0cnVlLCAoKSA9PiB7XG4gICAgICAgICAgICB9LCAwKVxuICAgICAgICBdKSxcbiAgICAgICAgZ290b05leHRMb2NhdGlvbixcbiAgICBdKTtcblxuICAgIGxldCBhbGllbkJUID0gc2VsZWN0b3IoW1xuICAgICAgICBlYXRQbGF5ZXIsXG4gICAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgICAgIHNlYXJjaCwgZWF0UGxheWVyXG4gICAgICAgIF0pXG4gICAgXSk7XG5cbi8vYXR0YWNoIGJlaGF2aW91ciB0cmVlcyB0byBhZ2VudHNcbiAgICBhdHRhY2hUcmVlVG9BZ2VudChhbGllbiwgYWxpZW5CVCk7XG4gICAgLy8gMy4gQ29uc3RydWN0IHN0b3J5XG4gICAgLy8gY3JlYXRlIHVzZXIgYWN0aW9uc1xuICAgIGZvciAobGV0IGtleSBpbiBsb2NhdGlvbkdyYXBoKSB7XG4gICAgICAgIGxldCBzZXE6IGFueVtdID0gW107XG4gICAgICAgIHNlcS5wdXNoKGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbihcIllvdSBlbnRlciB0aGUgXCIgKyBpZExhYmVsUGFpcltrZXldICsgXCIuXCIpKTtcbiAgICAgICAgc2VxLnB1c2goYWRkVXNlckFjdGlvbihcIlN0YXkgd2hlcmUgeW91IGFyZS5cIiwgKCkgPT4ge1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsb2NhdGlvbkdyYXBoKS5pbmNsdWRlcyhQcmV2bmFtZUxpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgIHNlcS5wdXNoKGFkZFVzZXJBY3Rpb24oXCJHbyBvdXRzaWRlIHRvIFwiICsgaWRMYWJlbFBhaXJbUHJldm5hbWVMaXN0W2tleV1dICsgXCIuXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiwgUHJldm5hbWVMaXN0W2tleV0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhleHBhbmRMaXN0KS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBzZXEucHVzaChhZGRVc2VyQWN0aW9uKFwiR28gaW5zaWRlIFwiICsgaWRMYWJlbFBhaXJba2V5XSArIFwiIHRvIGVudGVyIFwiICsgaWRMYWJlbFBhaXJbZXhwYW5kTGlzdFtrZXldWzBdXSArIFwiLlwiLCAoKSA9PiBzZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiwgZXhwYW5kTGlzdFtrZXldWzBdKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncmFwaCA9IGNvbXBsZXRlR3JhcGgoZXhwYW5kR3JhcGhbUHJldm5hbWVMaXN0W2tleV1dKVxuICAgICAgICBmb3IgKGxldCBhZGogb2YgZ3JhcGhba2V5XSkge1xuICAgICAgICAgICAgc2VxLnB1c2goYWRkVXNlckFjdGlvbihcIkVudGVyIHRoZSBcIiArIGlkTGFiZWxQYWlyW2Fkal0gKyBcIi5cIiwgKCkgPT4gc2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24sIGFkaikpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgU3RhdGVCVCA9IGd1YXJkKCgpID0+IGdldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKSA9PSBrZXksXG4gICAgICAgICAgICBzZXF1ZW5jZShzZXEpKTtcbiAgICAgICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShTdGF0ZUJUKTtcbiAgICB9XG5cblxuICAgIHZhciBjcmV3Q2FyZDFCVCA9IGd1YXJkKCgpID0+IGdldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKSA9PSBnZXRJdGVtVmFyaWFibGUoY3Jld0NhcmQxLCBcImN1cnJlbnRMb2NhdGlvblwiKSxcbiAgICAgICAgc2VxdWVuY2UoW1xuICAgICAgICAgICAgICAgIGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbihcIllvdSBub3RpY2UgYSBjcmV3IGNhcmQgbHlpbmcgYXJvdW5kLlwiKSxcbiAgICAgICAgICAgICAgICBhZGRVc2VyQWN0aW9uVHJlZShcIlBpY2sgdXAgdGhlIGNyZXcgY2FyZFwiLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZShbXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKCkgPT4gdHJ1ZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlBY3Rpb25FZmZlY3RUZXh0KFwiWW91IHBpY2sgdXAgdGhlIGNyZXcgY2FyZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXRlbVZhcmlhYmxlKGNyZXdDYXJkMSwgXCJjdXJyZW50TG9jYXRpb25cIiwgXCJwbGF5ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUoY3Jld0NhcmRzQ29sbGVjdGVkLCBnZXRWYXJpYWJsZShjcmV3Q2FyZHNDb2xsZWN0ZWQpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbigoKSA9PiB0cnVlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUFjdGlvbkVmZmVjdFRleHQoXCJXb3cgeW91IGtub3cgaG93IHRvIHBpY2sgdXAgdGhpbmdzLlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdXG4gICAgICAgICkpO1xuXG4gICAgdmFyIGNyZXdDYXJkMkJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IGdldEl0ZW1WYXJpYWJsZShjcmV3Q2FyZDIsIFwiY3VycmVudExvY2F0aW9uXCIpLFxuICAgICAgICBzZXF1ZW5jZShbXG4gICAgICAgICAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKFwiWW91IG5vdGljZSBhIGNyZXcgY2FyZCBseWluZyBhcm91bmQuXCIpLFxuICAgICAgICAgICAgICAgIGFkZFVzZXJBY3Rpb24oXCJQaWNrIHVwIHRoZSBjcmV3IGNhcmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5QWN0aW9uRWZmZWN0VGV4dChcIllvdSBwaWNrIHVwIHRoZSBjcmV3IGNhcmQuXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtVmFyaWFibGUoY3Jld0NhcmQyLCBcImN1cnJlbnRMb2NhdGlvblwiLCBcInBsYXllclwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUoY3Jld0NhcmRzQ29sbGVjdGVkLCBnZXRWYXJpYWJsZShjcmV3Q2FyZHNDb2xsZWN0ZWQpICsgMSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSk7XG5cbiAgICB2YXIgRXhpdEJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IFwiRXhpdFwiLFxuICAgICAgICBzZWxlY3RvcihbXG4gICAgICAgICAgICBndWFyZCgoKSA9PiBnZXRWYXJpYWJsZShjcmV3Q2FyZHNDb2xsZWN0ZWQpID49IDIsXG4gICAgICAgICAgICAgICAgc2VxdWVuY2UoW1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24oXCJZb3UgY2FuIG5vdyBhY3RpdmF0ZSB0aGUgZXhpdCBhbmQgZmxlZSFcIiksXG4gICAgICAgICAgICAgICAgICAgIGFkZFVzZXJBY3Rpb24oXCJBY3RpdmF0ZSBhbmQgZ2V0IG91dCFcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUoXCJlbmRHYW1lXCIsIFwid2luXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24sIFwiTkFcIilcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdKSksXG4gICAgICAgICAgICBkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24oXCJZb3UgbmVlZCAyIGNyZXcgY2FyZHMgdG8gYWN0aXZhdGUgdGhlIGV4aXQgZWxldmF0b3Igc3lzdGVtLlwiKVxuICAgICAgICBdKSk7XG5cbiAgICBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKGNyZXdDYXJkMUJUKTtcbiAgICBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKGNyZXdDYXJkMkJUKTtcbiAgICBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKEV4aXRCVCk7XG5cbiAgICB2YXIgYWxpZW5OZWFyYnkgPSBndWFyZCgoKSA9PiBhcmVBZGphY2VudChnZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiksIGdldEFnZW50VmFyaWFibGUoYWxpZW4sIFwiY3VycmVudExvY2F0aW9uXCIpKSxcbiAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKFwiWW91IGhlYXIgYSB0aHVtcGluZyBzb3VuZC4gVGhlIGFsaWVuIGlzIG5lYXJieS5cIikpO1xuICAgIGFkZFVzZXJJbnRlcmFjdGlvblRyZWUoYWxpZW5OZWFyYnkpO1xuXG4gICAgdmFyIGdhbWVPdmVyID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IFwiTkFcIixcbiAgICAgICAgc2VsZWN0b3IoW1xuICAgICAgICAgICAgICAgIGd1YXJkKCgpID0+IGdldFZhcmlhYmxlKFwiZW5kR2FtZVwiKSA9PSBcIndpblwiLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24oXCJZb3UgaGF2ZSBtYW5hZ2VkIHRvIGVzY2FwZSFcIikpLFxuICAgICAgICAgICAgICAgIGd1YXJkKCgpID0+IGdldFZhcmlhYmxlKFwiZW5kR2FtZVwiKSA9PSBcImxvc2VcIixcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKFwiVGhlIGNyZWF0dXJlIGdyYWJzIHlvdSBiZWZvcmUgeW91IGNhbiByZWFjdCEgWW91IHN0cnVnZ2xlIGZvciBhIGJpdCBiZWZvcmUgcmVhbGlzaW5nIGl0J3MgYWxsIG92ZXIuLlwiKSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSk7XG4gICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShnYW1lT3Zlcik7XG4gICAgXG4vL0luaXRpYWxpemUgc2lnbWFcbiAgICB2YXIgc2lnbWFJbnN0YW5jZSA9IG5ldyBzaWdtYSh7XG4gICAgICAgIGdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICBlZGdlczogW11cbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjYW52YXMnLFxuICAgICAgICAgICAgY29udGFpbmVyOiAnZ3JhcGgtY29udGFpbmVyJ1xuICAgICAgICB9LFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbm9kZUJvcmRlclNpemU6IDUsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZUJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZUhvdmVyQm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIGRlZmF1bHROb2RlQ29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIGRlZmF1bHRMYWJlbENvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBlZGdlQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgIG1heE5vZGVTaXplOiAyMCxcbiAgICAgICAgICAgIHNpZGVNYXJnaW46IDE1XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBlZGdlSUQ6IG51bWJlciA9IDA7XG5cbiAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gc2lnbWFJbnN0YW5jZS5ncmFwaC5ub2RlcygpO1xuICAgICAgICBmb3IgKHZhciBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBzaWdtYUluc3RhbmNlLmdyYXBoLmRyb3BOb2RlKG5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVHcmFwaChncmFwaDogbWFwcykge1xuICAgICAgICB2YXIgcmV0R3JhcGg6IG1hcHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGdyYXBoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQocmV0R3JhcGhba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXRHcmFwaFtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXRHcmFwaFtrZXldID0gcmV0R3JhcGhba2V5XS5jb25jYXQoZ3JhcGhba2V5XSk7XG4gICAgICAgICAgICBmb3IgKHZhciBsb2Mgb2YgZ3JhcGhba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChyZXRHcmFwaFtsb2NdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRHcmFwaFtsb2NdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldEdyYXBoW2xvY10ucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRHcmFwaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93QXJvdW5kKGlucHV0OiBzdHJpbmcpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gY29tcGxldGVHcmFwaChleHBhbmRHcmFwaFtQcmV2bmFtZUxpc3RbaW5wdXRdXSk7XG4gICAgICAgIHZhciBhZGphY2VudCA9IGdyYXBoW2lucHV0XTtcbiAgICAgICAgdmFyIG51bWJlckxheWVyID0gYWRqYWNlbnQubGVuZ3RoO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2lnbWFJbnN0YW5jZS5ncmFwaC5ub2RlcyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWdtYUluc3RhbmNlLmdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgICAgIC8vIE1haW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBpZDogaW5wdXQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGlkTGFiZWxQYWlyW2lucHV0XSxcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgc2l6ZTogMTUsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZmZmJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJMYXllcjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2lnbWFJbnN0YW5jZS5ncmFwaC5ub2RlcyhhZGphY2VudFtpXSkpKSB7XG4gICAgICAgICAgICAgICAgc2lnbWFJbnN0YW5jZS5ncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFpbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBpZDogYWRqYWNlbnRbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZExhYmVsUGFpclthZGphY2VudFtpXV0sXG4gICAgICAgICAgICAgICAgICAgIHg6IE1hdGguY29zKE1hdGguUEkgKiAyICogKGkgLSAxIC8gMykgLyBudW1iZXJMYXllcikgKiA0MCArIHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoaW5wdXQpLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IE1hdGguc2luKE1hdGguUEkgKiAyICogKGkgLSAxIC8gMykgLyBudW1iZXJMYXllcikgKiA0MCArIHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoaW5wdXQpLnksXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDE1LFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZmYnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ21hSW5zdGFuY2UuZ3JhcGguYWRkRWRnZSh7XG4gICAgICAgICAgICAgICAgaWQ6ICdlZGdlJyArIChlZGdlSUQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGFkamFjZW50W2ldLFxuICAgICAgICAgICAgICAgIHRhcmdldDogc2lnbWFJbnN0YW5jZS5ncmFwaC5ub2RlcyhpbnB1dCkuaWQsXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjZmZmXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdyhpbnB1dGlkOiBzdHJpbmcpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gY29tcGxldGVHcmFwaChleHBhbmRHcmFwaFtQcmV2bmFtZUxpc3RbaW5wdXRpZF1dKTtcbiAgICAgICAgdmFyIGFkamFjZW50ID0gZ3JhcGhbaW5wdXRpZF07XG4gICAgICAgIHZhciBudW1iZXJMYXllciA9IGFkamFjZW50Lmxlbmd0aDtcbiAgICAgICAgc2hvd0Fyb3VuZChpbnB1dGlkKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGdyYXBoKS5sZW5ndGggPCAxMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgbGF5ZXIxIG9mIGFkamFjZW50KSB7XG4gICAgICAgICAgICAgICAgc2hvd0Fyb3VuZChsYXllcjEpO1xuICAgICAgICAgICAgICAgIGxldCBuZXdBZGphY2VudCA9IGdyYXBoW2xheWVyMV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGF5ZXIyIG9mIG5ld0FkamFjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dBcm91bmQoKGxheWVyMikpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRyYWdMaXN0ZW5lciA9IHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzKFxuICAgICAgICBzaWdtYUluc3RhbmNlLCBzaWdtYUluc3RhbmNlLnJlbmRlcmVyc1swXSk7XG5cbiAgICBkcmFnTGlzdGVuZXIuYmluZCgnc3RhcnRkcmFnJywgZnVuY3Rpb24gKGV2ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuICAgIGRyYWdMaXN0ZW5lci5iaW5kKCdkcmFnJywgZnVuY3Rpb24gKGV2ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuICAgIGRyYWdMaXN0ZW5lci5iaW5kKCdkcm9wJywgZnVuY3Rpb24gKGV2ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuICAgIGRyYWdMaXN0ZW5lci5iaW5kKCdkcmFnZW5kJywgZnVuY3Rpb24gKGV2ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG5cbi8vNC4gUnVuIHRoZSB3b3JsZFxuICAgIGluaXRpYWxpemUoKTtcbiAgICB2YXIgdXNlckludGVyYWN0aW9uT2JqZWN0ID0gZ2V0VXNlckludGVyYWN0aW9uT2JqZWN0KCk7XG5cbi8vUkVOREVSSU5HLS0tLS1cbi8vdmFyIGRpc3BsYXlQYW5lbCA9IHt4OiA1MDAsIHk6IDB9O1xuICAgIHZhciB0ZXh0UGFuZWwgPSB7eDogNDAwLCB5OiAzNTB9O1xuICAgIHZhciBhY3Rpb25zUGFuZWwgPSB7eDogNDIwLCB5OiAzNzV9O1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBsZXQgYWxpZW5Mb2NhdGlvbiA9IGdldEFnZW50VmFyaWFibGUoYWxpZW4sIFwiY3VycmVudExvY2F0aW9uXCIpO1xuICAgICAgICBsZXQgcGxheWVyTCA9IGdldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxvY2F0aW9uR3JhcGgpLmluY2x1ZGVzKHBsYXllckwpKSB7XG4gICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgc2hvdyhwbGF5ZXJMKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBub2RlIG9mIHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gYWxpZW5Mb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIG5vZGUuaW1hZ2UgPSB7dXJsOiAnLi4vaW1hZ2VzL3hlbm9tb3JwaC5wbmcnfTs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBwbGF5ZXJMKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pbWFnZSA9IHt1cmw6ICcuLi9pbWFnZXMvcGxheWVyMi5wbmcnfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpZ21hSW5zdGFuY2UucmVmcmVzaCgpO1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgbm9kZU1hcmdpbjogNTAsXG4gICAgICAgICAgICBncmlkU2l6ZTogNSxcbiAgICAgICAgfTtcblxuLy9Db25maWd1cmUgdGhlIGFsZ29yaXRobVxuICAgICAgICB2YXIgbGlzdGVuZXIgPSBzaWdtYUluc3RhbmNlLmNvbmZpZ05vdmVybGFwKGNvbmZpZyk7XG5cbi8vQmluZCBhbGwgZXZlbnRzOlxuICAgICAgICBsaXN0ZW5lci5iaW5kKCdzdGFydCBzdG9wIGludGVycG9sYXRlJywgZnVuY3Rpb24gKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnR5cGUpO1xuICAgICAgICB9KTtcblxuLy9TdGFydCB0aGUgYWxnb3JpdGhtOlxuICAgICAgICBzaWdtYUluc3RhbmNlLnN0YXJ0Tm92ZXJsYXAoKTtcbiAgICAgICAgLy9zaWdtYUluc3RhbmNlLnN0YXJ0Rm9yY2VBdGxhczIoKTtcblxuICAgICAgICBkaXNwbGF5VGV4dEFuZEFjdGlvbnMoKTtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gPEhUTUxDYW52YXNFbGVtZW50PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlzcGxheScpO1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICB2YXIgY3VycmVudFNlbGVjdGlvbjtcbiAgICB2YXIgeU9mZnNldCA9IGFjdGlvbnNQYW5lbC55ICsgMjU7XG4gICAgdmFyIHlPZmZzZXRJbmNyZW1lbnQgPSA1MDtcblxuICAgIGZ1bmN0aW9uIGRpc3BsYXlUZXh0QW5kQWN0aW9ucygpIHtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QodGV4dFBhbmVsLngsIHRleHRQYW5lbC55LCAxMDAwLCAxMDAwKTtcbiAgICAgICAgeU9mZnNldCA9IGFjdGlvbnNQYW5lbC55ICsgMjU7XG5cbiAgICAgICAgY29udGV4dC5mb250ID0gXCIxNXB0IENhbGlicmlcIjtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFjdGlvbnMgZWZmZWN0IHRleHQ6IFwiICsgdXNlckludGVyYWN0aW9uT2JqZWN0LmFjdGlvbkVmZmVjdHNUZXh0KTtcbiAgICAgICAgdmFyIHRleHRUb0Rpc3BsYXkgPSB1c2VySW50ZXJhY3Rpb25PYmplY3QuYWN0aW9uRWZmZWN0c1RleHQubGVuZ3RoICE9IDAgPyB1c2VySW50ZXJhY3Rpb25PYmplY3QuYWN0aW9uRWZmZWN0c1RleHQgOiB1c2VySW50ZXJhY3Rpb25PYmplY3QudGV4dDtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0VG9EaXNwbGF5LCB0ZXh0UGFuZWwueCwgdGV4dFBhbmVsLnkgKyAyMCk7XG5cbiAgICAgICAgY29udGV4dC5mb250ID0gXCIxNXB0IENhbGlicmlcIjtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVzZXJJbnRlcmFjdGlvbk9iamVjdC51c2VyQWN0aW9uc1RleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB1c2VyQWN0aW9uVGV4dCA9IHVzZXJJbnRlcmFjdGlvbk9iamVjdC51c2VyQWN0aW9uc1RleHRbaV07XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHVzZXJBY3Rpb25UZXh0LCBhY3Rpb25zUGFuZWwueCArIDIwLCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlPZmZzZXQgKz0geU9mZnNldEluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXlBcnJvdygpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNyZXcgY2FyZHM6IFwiICsgZ2V0VmFyaWFibGUoY3Jld0NhcmRzQ29sbGVjdGVkKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGxheUFycm93KCkge1xuICAgICAgICBpZiAodXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dC5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoYWN0aW9uc1BhbmVsLngsIGFjdGlvbnNQYW5lbC55LCAyMCwgMTAwMCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KFwiPiBcIiwgNDIwLCBhY3Rpb25zUGFuZWwueSArIDI1ICsgKGN1cnJlbnRTZWxlY3Rpb24gKiB5T2Zmc2V0SW5jcmVtZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vVXNlciBpbnB1dFxuICAgIGZ1bmN0aW9uIGtleVByZXNzKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkQWN0aW9uID0gdXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dFtjdXJyZW50U2VsZWN0aW9uXTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc2VsZWN0ZWRBY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVVzZXJBY3Rpb24oc2VsZWN0ZWRBY3Rpb24pO1xuICAgICAgICAgICAgICAgIHdvcmxkVGljaygpO1xuICAgICAgICAgICAgICAgIHJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5RG93bihlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gNDApIHsvL2Rvd25cbiAgICAgICAgICAgIGlmICh1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbisrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uICUgdXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZGlzcGxheUFycm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDM4KSB7Ly91cFxuICAgICAgICAgICAgaWYgKHVzZXJJbnRlcmFjdGlvbk9iamVjdC51c2VyQWN0aW9uc1RleHQubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLS07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24gPCAwKVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uID0gdXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlBcnJvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwga2V5UHJlc3MsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlEb3duLCBmYWxzZSk7XG59Il19
